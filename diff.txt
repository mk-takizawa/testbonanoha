########################## benchmark.cpp
2c2
<   NanohaMini, a USI shogi(japanese-chess) playing engine derived from Stockfish 2.1
---
>   Stockfish, a UCI chess playing engine derived from Glaurung 2.1
4,5c4
<   Copyright (C) 2008-2010 Marco Costalba, Joona Kiiski, Tord Romstad (Stockfish author)
<   Copyright (C) 2014 Kazuyuki Kawabata
---
>   Copyright (C) 2008-2010 Marco Costalba, Joona Kiiski, Tord Romstad
7c6
<   NanohaMini is free software: you can redistribute it and/or modify
---
>   Stockfish is free software: you can redistribute it and/or modify
12c11
<   NanohaMini is distributed in the hope that it will be useful,
---
>   Stockfish is distributed in the hope that it will be useful,
28,31d26
< #if defined(NANOHA)
< #include "movegen.h"
< #include "evaluate.h"
< #endif
35,53d29
< #if defined(NANOHA)
< // 指し手生成；指し手生成祭り局面と初期局面
< static const string GenMoves[] = {
< 	"l6nl/5+P1gk/2np1S3/p1p4Pp/3P2Sp1/1PPb2P1P/P5GS1/R8/LN4bKL w RGgsn5p 1",
< 	"lnsgkgsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL b - 1",
< 	""
< };
< static const string EvalPos[] = {
< 	// 初期局面.
< 	"lnsgkgsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL b - 1",
< 	// 歩を突いた局面の左右反転と先後反転させたもので対称性を確認する.
< 	"lnsgkgsnl/1r5b1/ppppppppp/9/9/2P6/PP1PPPPPP/1B5R1/LNSGKGSNL b - 1",
< 	"lnsgkgsnl/1b5r1/ppppppppp/9/9/6P2/PPPPPP1PP/1R5B1/LNSGKGSNL b - 1",
< 	"lnsgkgsnl/1r5b1/ppppppppp/9/9/2P6/PP1PPPPPP/1B5R1/LNSGKGSNL w - 1",
< 	"lnsgkgsnl/1b5r1/ppppppppp/9/9/6P2/PPPPPP1PP/1R5B1/LNSGKGSNL w - 1",
< 	""
< };
< #endif
< 
55,93c31,47
< #if defined(NANOHA)
< 	// 局面数を 16 にする
< 	// 進歩本2の棋力判定問題のNo.1 - No.16
< 	"lR1B3nl/2gp5/ngk1+BspPp/1s2p2p1/p4S3/1Pp6/P5P1P/LGG6/KN5NL b Prs5p 1",
< 	"5S2l/1rP2s1k1/p2+B1gnp1/5np2/3G3n1/5S2p/P1+p1PpPP1/1P1PG2KP/L2+rLPGNL b Bs3p 1",
< 	"lR6l/1s1g5/1k1s1+P2p/1+bpp1+Bs2/1n1n2Pp1/2P6/S2R4P/K1GG5/9 b 2NPg2l9p 1",
< 	"l4g1nl/4g1k2/2n1sp1p1/p5pPp/5Ps2/1P1p2s2/P1G1+p1N1P/6K2/LN5RL b RBG3Pbs3p 1",
< 	"1n4g1k/6r2/1+P1psg1p+L/2p1pp3/3P5/p1P1PPPP1/3SGS3/1+p1K1G2r/9 b 2BNLPs2n2l3p 1",
< 	"+B2+R3n1/3+L2gk1/5gss1/p1p1p1ppl/5P2p/PPPnP1PP1/3+p2N2/6K2/L4S1RL b BGS3Pgnp 1",
< 	"3R4l/1kg6/2ns5/spppp2+Bb/p7p/1PPPP1g2/nSNSNP2P/KG1G5/5r2L b L4Pl2p 1",
< 	"ln5nl/2r2gk2/1p2sgbpp/pRspppp2/L1p4PP/3PP1G2/N4PP2/3BS1SK1/5G1NL b 3P 1",
< 	"ln7/1r2k1+P2/p3gs3/1b1g1p+B2/1p5R1/2pPP4/PP1S1P3/2G2G3/LN1K5 b SNL3Psnl5p 1",
< 	"3+P3+Rl/2+P2kg2/+B2psp1p1/4p1p1p/9/2+p1P+bnKP/P6P1/4G1S2/L4G2L b G2S2NLrn5p 1",
< 	"ln1gb2nl/1ks4r1/1p1g4p/p1pppspB1/5p3/PPPPP1P2/1KNG1PS1P/2S4R1/L2G3NL b Pp 1",
< 	"lr6l/4g1k1p/1s1p1pgp1/p3P1N1P/2Pl5/PPbBSP3/6PP1/4S1SK1/1+r3G1NL b N3Pgn2p 1",
< 	"l1ks3+Bl/2g2+P3/p1npp4/1sNn2B2/5p2p/2PP5/PPN1P1+p1P/1KSSg2P1/L1G5+r b GL4Pr 1",
< 	"ln3k1nl/2P1g4/p1lpsg1pp/4p4/1p1P1p3/2SBP4/PP1G1P1PP/1K1G3+r1/LN1s2PNR b BSPp 1",
< 	"+N6nl/1+R2pGgk1/5Pgp1/p2p1sp2/3B1p2p/P1pP4P/6PP1/L3G1K2/7NL b RNL2Pb3s2p 1",
< 	"ln1g5/1r4k2/p2pppn2/2ps2p2/1p7/2P6/PPSPPPPLP/2G2K1pr/LN4G1b b BG2SLPnp 1",
< 	""
< #else
< 	"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",
< 	"r3k2r/p1ppqpb1/bn2pnp1/3PN3/1p2P3/2N2Q1p/PPPBBPPP/R3K2R w KQkq - 0 10",
< 	"8/2p5/3p4/KP5r/1R3p1k/8/4P1P1/8 w - - 0 11",
< 	"4rrk1/pp1n3p/3q2pQ/2p1pb2/2PP4/2P3N1/P2B2PP/4RRK1 b - - 7 19",
< 	"rq3rk1/ppp2ppp/1bnpb3/3N2B1/3NP3/7P/PPPQ1PP1/2KR3R w - - 7 14",
< 	"r1bq1r1k/1pp1n1pp/1p1p4/4p2Q/4Pp2/1BNP4/PPP2PPP/3R1RK1 w - - 2 14",
< 	"r3r1k1/2p2ppp/p1p1bn2/8/1q2P3/2NPQN2/PPP3PP/R4RK1 b - - 2 15",
< 	"r1bbk1nr/pp3p1p/2n5/1N4p1/2Np1B2/8/PPP2PPP/2KR1B1R w kq - 0 13",
< 	"r1bq1rk1/ppp1nppp/4n3/3p3Q/3P4/1BP1B3/PP1N2PP/R4RK1 w - - 1 16",
< 	"4r1k1/r1q2ppp/ppp2n2/4P3/5Rb1/1N1BQ3/PPP3PP/R5K1 w - - 1 17",
< 	"2rqkb1r/ppp2p2/2npb1p1/1N1Nn2p/2P1PP2/8/PP2B1PP/R1BQK2R b KQ - 0 11",
< 	"r1bq1r1k/b1p1npp1/p2p3p/1p6/3PP3/1B2NN2/PP3PPP/R2Q1RK1 w - - 1 16",
< 	"3r1rk1/p5pp/bpp1pp2/8/q1PP1P2/b3P3/P2NQRPP/1R2B1K1 b - - 6 22",
< 	"r1q2rk1/2p1bppp/2Pp4/p6b/Q1PNp3/4B3/PP1R1PPP/2K4R w - - 2 18",
< 	"4k2r/1pb2ppp/1p2p3/1R1p4/3P4/2r1PN2/P4PPP/1R4K1 b - - 3 22",
< 	"3q2k1/pb3p1p/4pbp1/2r5/PpN2N2/1P2P2P/5PP1/Q2R2K1 b - - 4 26",
< 	""
< #endif
---
>   "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",
>   "r3k2r/p1ppqpb1/bn2pnp1/3PN3/1p2P3/2N2Q1p/PPPBBPPP/R3K2R w KQkq -",
>   "8/2p5/3p4/KP5r/1R3p1k/8/4P1P1/8 w - -",
>   "4rrk1/pp1n3p/3q2pQ/2p1pb2/2PP4/2P3N1/P2B2PP/4RRK1 b - - 7 19",
>   "rq3rk1/ppp2ppp/1bnpb3/3N2B1/3NP3/7P/PPPQ1PP1/2KR3R w - - 7 14",
>   "r1bq1r1k/1pp1n1pp/1p1p4/4p2Q/4Pp2/1BNP4/PPP2PPP/3R1RK1 w - - 2 14",
>   "r3r1k1/2p2ppp/p1p1bn2/8/1q2P3/2NPQN2/PPP3PP/R4RK1 b - - 2 15",
>   "r1bbk1nr/pp3p1p/2n5/1N4p1/2Np1B2/8/PPP2PPP/2KR1B1R w kq - 0 13",
>   "r1bq1rk1/ppp1nppp/4n3/3p3Q/3P4/1BP1B3/PP1N2PP/R4RK1 w - - 1 16",
>   "4r1k1/r1q2ppp/ppp2n2/4P3/5Rb1/1N1BQ3/PPP3PP/R5K1 w - - 1 17",
>   "2rqkb1r/ppp2p2/2npb1p1/1N1Nn2p/2P1PP2/8/PP2B1PP/R1BQK2R b KQ - 0 11",
>   "r1bq1r1k/b1p1npp1/p2p3p/1p6/3PP3/1B2NN2/PP3PPP/R2Q1RK1 w - - 1 16",
>   "3r1rk1/p5pp/bpp1pp2/8/q1PP1P2/b3P3/P2NQRPP/1R2B1K1 b - - 6 22",
>   "r1q2rk1/2p1bppp/2Pp4/p6b/Q1PNp3/4B3/PP1R1PPP/2K4R w - - 2 18",
>   "4k2r/1pb2ppp/1p2p3/1R1p4/3P4/2r1PN2/P4PPP/1R4K1 b - - 3 22",
>   "3q2k1/pb3p1p/4pbp1/2r5/PpN2N2/1P2P2P/5PP1/Q2R2K1 b - - 4 26",
>   ""
100,103c54,58
< /// be used, the limit value spent for each position (optional, default is
< /// depth 12), an optional file name where to look for positions in fen
< /// format (defaults are the positions defined above) and the type of the
< /// limit value: depth (default), time in secs or number of nodes.
---
> /// be used, the limit value spent for each position (optional, default
> /// is ply 12), an optional file name where to look for positions in fen
> /// format (default are the BenchmarkPositions defined above) and the type
> /// of the limit value: depth (default), time in secs or number of nodes.
> /// The analysis is written to a file named bench.txt.
107,527c62,152
< 	vector<string> fenList;
< 	SearchLimits limits;
< 	int64_t totalNodes;
< 	int time;
< 
< 	// Assign default values to missing arguments
< 	string ttSize  = argc > 2 ? argv[2] : "128";
< 	string threads = argc > 3 ? argv[3] : "1";
< 	string valStr  = argc > 4 ? argv[4] : "12";
< 	string fenFile = argc > 5 ? argv[5] : "default";
< 	string valType = argc > 6 ? argv[6] : "depth";
< 
< 	Options["Hash"].set_value(ttSize);
< 	Options["Threads"].set_value(threads);
< 	Options["OwnBook"].set_value("false");
< 
< 	// Search should be limited by nodes, time or depth ?
< 	if (valType == "nodes")
< 		limits.maxNodes = atoi(valStr.c_str());
< 	else if (valType == "time")
< 		limits.maxTime = 1000 * atoi(valStr.c_str()); // maxTime is in ms
< 	else
< 		limits.maxDepth = atoi(valStr.c_str());
< 
< 	// Do we need to load positions from a given FEN file ?
< 	if (fenFile != "default")
< 	{
< 		string fen;
< 		ifstream f(fenFile.c_str());
< 
< 		if (!f.is_open())
< 		{
< 			cerr << "Unable to open file " << fenFile << endl;
< 			exit(EXIT_FAILURE);
< 		}
< 
< 		while (getline(f, fen))
< 			if (!fen.empty())
< 				fenList.push_back(fen);
< 
< 		f.close();
< 	}
< 	else // Load default positions
< 		for (int i = 0; !Defaults[i].empty(); i++)
< 			fenList.push_back(Defaults[i]);
< 
< 	// Ok, let's start the benchmark !
< 	totalNodes = 0;
< #if defined(NANOHA)
< 	int64_t totalTNodes = 0;
< #endif
< 	time = get_system_time();
< 
< 	for (size_t i = 0; i < fenList.size(); i++)
< 	{
< 		Move moves[] = { MOVE_NONE };
< #if defined(NANOHA)
< 		Position pos(fenList[i], 0);
< #else
< 		Position pos(fenList[i], false, 0);
< #endif
< 		cerr << "\nBench position: " << i + 1 << '/' << fenList.size() << endl;
< 
< 		if (valType == "perft")
< 		{
< 			int64_t cnt = perft(pos, limits.maxDepth * ONE_PLY);
< 
< 			cerr << "\nPerft " << limits.maxDepth
< 			     << " nodes counted: " << cnt << endl;
< 
< 			totalNodes += cnt;
< 		}
< 		else
< 		{
< 			if (!think(pos, limits, moves))
< 				break;
< 
< 			totalNodes += pos.nodes_searched();
< #if defined(NANOHA)
< 			totalTNodes += pos.tnodes_searched();
< #endif
< 		}
< 	}
< 
< 	time = get_system_time() - time;
< 
< 	cerr << "\n==============================="
< 		 << "\nTotal time (ms) : " << time
< 		 << "\nNodes searched  : " << totalNodes
< #if !defined(NANOHA)
< 		 << "\nNodes/second    : " << (int)(totalNodes / (time / 1000.0)) << endl;
< #else
< 		 << "\nTNodes searched : " << totalTNodes
< 		 << "\nNodes/second    : " << (int)(totalNodes / (time / 1000.0))
< 		 << "\nNodes/s(all)    : " << (int)((totalNodes+totalTNodes) / (time / 1000.0)) << endl;
< #endif
< }
< 
< #if defined(NANOHA)
< 
< namespace {
< 	struct ResultMate1 {
< 		int msec;
< 		int result;
< 		Move m;
< 	};
< 	void disp_moves(MoveStack mstack[], size_t n)
< 	{
< 		cerr << "     ";
< 		for (size_t i = 0; i < n; i++) {
< 			cerr << " " << move_to_csa(mstack[i].move);
< 			if (i % 6 == 5) cerr << endl << "     ";
< 		}
< 		cerr << endl;
< 	}
< 	string conv_per_s(const double loops, int t)
< 	{
< 		if (t == 0) t++;
< 		double nps = loops * 1000 / t;
< 		char buf[64];
< 		if (nps > 1000*1000) {snprintf(buf, sizeof(buf), "%.3f M", nps / 1000000.0); }
< 		else if (nps > 1000) {snprintf(buf, sizeof(buf), "%.3f k", nps / 1000.0); }
< 		else  {snprintf(buf, sizeof(buf), "%d ", int(nps)); }
< 		return string(buf);
< 	}
< }
< 
< // 1手詰め or 3手詰め
< void bench_mate(int argc, char* argv[]) {
< 
< 	vector<string> sfenList;
< 	int time;
< 	vector<ResultMate1> result;
< 	int type = (string(argv[1]) == "mate1") ? 0 : 1;
< 	const char *typestr[] = { "Mate1ply", "Mate3play" };
< 
< 	// デフォルト値を設定
< 	string fenFile = argc > 2 ? argv[2] : "default";
< 	bool bLoop    = argc > 3 ? (string(argv[3]) == "yes" ? true : false) : true;
< 	bool bDisplay = argc > 4 ? (string(argv[4]) == "no" ? false : true) : false;
< 
< 	cerr << "Benchmark type: " << typestr[type] << " routine." << endl;
< 
< 	if (fenFile != "default")
< 	{
< 		string fen;
< 		ifstream f(fenFile.c_str());
< 
< 		if (!f.is_open())
< 		{
< 			cerr << "Unable to open file " << fenFile << endl;
< 			exit(EXIT_FAILURE);
< 		}
< 
< 		while (getline(f, fen)) {
< 			if (!fen.empty()) {
< 				if (fen.compare(0, 5, "sfen ") == 0) {
< 					fen.erase(0, 5);
< 				}
< 				sfenList.push_back(fen);
< 			}
< 		}
< 
< 		f.close();
< 	}
< 	else {
< 		for (int i = 0; !Defaults[i].empty(); i++) {
< 			sfenList.push_back(Defaults[i]);
< 		}
< 	}
< 
< 	// ベンチ開始
< 	int loops = (bLoop ? 1000*1000 : 1000); // 1M回
< 	if (type != 0) loops /= 10;	// mate3はmate1より時間がかかるので、1/10にする
< 
< 	ResultMate1 record;
< 
< 	time = get_system_time();
< 	int total = 0;
< 	size_t i;
< 	for (i = 0; i < sfenList.size(); i++)
< 	{
< 		Move move = MOVE_NONE;
< 			Position pos(sfenList[i], 0);
< #if defined(_DEBUG) || !defined(NDEBUG)
< 		int failState;
< 		assert(pos.is_ok(&failState));
< #endif
< 
< 		if (bLoop)
< 				cerr << "\nBench position: " << i + 1 << '/' << sfenList.size() << "  c=" << pos.side_to_move() << endl;
< 
< 		volatile int v = 0;
< 		uint32_t info;
< 		int j;
< 		int rap_time = get_system_time();
< 		if (type == 0) {
< 			// 1手詰め
< 			if (pos.side_to_move() == BLACK) {
< 				for (j = 0; j < loops; j++) {
< 					v = pos.Mate1ply<BLACK>(move, info);
< 				}
< 			} else {
< 				for (j = 0; j < loops; j++) {
< 					v = pos.Mate1ply<WHITE>(move, info);
< 				}
< 			}
< 		} else {
< 			// 3手詰め
< 			for (j = 0; j < loops; j++) {
< 				v = pos.Mate3(pos.side_to_move(), move);
< 			}
< 		}
< 		rap_time = get_system_time() - rap_time;
< 		total += rap_time;
< 		if (bLoop && bDisplay) pos.print_csa(move);
< 
< 		record.msec = rap_time;
< 		record.result = v;
< 		record.m = move;
< 		result.push_back(record);
< 
< 		if (bLoop) cerr << v << "\t" << move_to_csa(move) << "  " << rap_time << "(ms)  "
< 		                << conv_per_s(loops, rap_time) << " times/s" << endl;
< 	}
< 
< 	time = get_system_time() - time;
< 	if (time == 0) time = 1;
< 
< 	cerr << "\n==============================="
< 		 << "\nTotal time (ms) : " << time << "(" << total << ")";
< 	cerr << "\n  Average : " << conv_per_s(static_cast<const double>(loops*sfenList.size()), time) << " times/s" << endl;
< 
< 	int solved = 0;
< 	int unknown = 0;
< 	for (i = 0; i < result.size(); i++) {
< 		if (result[i].result == VALUE_MATE) {
< 			solved++;
< 		} else {
< 			unknown++;
< 		}
< 	}
< 	cerr << "Mate    =  " << solved  << endl;
< 	cerr << "Unknown =  " << unknown << endl;
< 	cerr << "Ave.time=  " << double(time) / result.size() << "(ms)" << endl;
< 	cerr << "Lopps   =  " << loops << endl;
< 	cerr << "Average =  " << conv_per_s(static_cast<const double>(loops*result.size()), time) << " times/s" << endl;
< }
< 
< void bench_genmove(int argc, char* argv[]) {
< 
< 	vector<string> sfenList;
< 	int time;
< 
< 	// デフォルト値を設定
< 	string fenFile = argc > 2 ? argv[2] : "default";
< 	bool bDisplay = argc > 3 ? (string(argv[3]) == "yes" ? true : false) : false;
< 
< 	cerr << "Benchmark type: generate moves." << endl;
< 
< 	if (fenFile != "default")
< 	{
< 		string fen;
< 		ifstream f(fenFile.c_str());
< 
< 		if (!f.is_open())
< 		{
< 			cerr << "Unable to open file " << fenFile << endl;
< 			exit(EXIT_FAILURE);
< 		}
< 
< 		while (getline(f, fen)) {
< 			if (!fen.empty()) {
< 				if (fen.compare(0, 5, "sfen ") == 0) {
< 					fen.erase(0, 5);
< 				}
< 				sfenList.push_back(fen);
< 			}
< 		}
< 
< 		f.close();
< 		cerr << "SFEN file is" << fenFile << "." << endl;
< 	}
< 	else {
< 		for (int i = 0; !GenMoves[i].empty(); i++) {
< 			sfenList.push_back(GenMoves[i]);
< 		}
< 		cerr << "SFENs is default." << endl;
< 	}
< 
< 	time = get_system_time();
< 
< 	MoveStack ss[MAX_MOVES];
< 	volatile MoveStack *mlist = NULL;
< #if defined(NDEBUG)
< 	int loops = 1000*1000; // 1M回
< #else
< 	int loops = 500*1000; // 500k回
< #endif
< 	int j;
< 	for (size_t i = 0; i < sfenList.size(); i++)
< 	{
< 		Position pos(sfenList[i], 0);
< #if defined(_DEBUG)
< 		int failState;
< 		assert(pos.is_ok(&failState));
< #endif
< 
< 		cerr << "\nBench position: " << i + 1 << '/' << sfenList.size() << endl;
< 		int rap_time = get_system_time();
< 		for (j = 0; j < loops; j++) {
< 			mlist = generate<MV_LEGAL>(pos, ss);
< 		}
< 		rap_time = get_system_time() - rap_time;
< 		if (bDisplay) pos.print_csa();
< 		cerr << "  Genmove(" << mlist - ss << "): " << rap_time << "(ms), " << conv_per_s(loops, rap_time) << "times/s" << endl;
< 		if (bDisplay) disp_moves(ss, mlist - ss);
< 
< 		rap_time = get_system_time();
< 		for (j = 0; j < loops; j++) {
< 			mlist = generate<MV_CAPTURE>(pos, ss);
< 		}
< 		rap_time = get_system_time() - rap_time;
< 		cerr << "  Gencapture(" << mlist - ss << "): " << rap_time << "(ms), " << conv_per_s(loops, rap_time) << "times/s" << endl;
< 		if (bDisplay) disp_moves(ss, mlist - ss);
< 
< 		rap_time = get_system_time();
< 		for (j = 0; j < loops; j++) {
< 			mlist = generate<MV_NON_CAPTURE>(pos, ss);
< 		}
< 		rap_time = get_system_time() - rap_time;
< 		cerr << "  noncapture(" << mlist - ss << "): " << rap_time << "(ms), " << conv_per_s(loops, rap_time) << "times/s" << endl;
< 		if (bDisplay) disp_moves(ss, mlist - ss);
< 
< 		rap_time = get_system_time();
< 		for (j = 0; j < loops; j++) {
< 			mlist = generate<MV_CHECK>(pos, ss);
< 		}
< 		rap_time = get_system_time() - rap_time;
< 		cerr << "  gen_check(" << mlist - ss << "): " << rap_time << "(ms), " << conv_per_s(loops, rap_time) << "times/s" << endl;
< 		if (bDisplay) disp_moves(ss, mlist - ss);
< 	}
< 
< 	time = get_system_time() - time;
< 
< 	cerr << "\n==============================="
< 		 << "\nTotal time (ms) : " << time << endl;
< }
< 
< void bench_eval(int argc, char* argv[]) {
< 
< 	vector<string> sfenList;
< 	int time;
< 
< 	// デフォルト値を設定
< 	string fenFile = argc > 2 ? argv[2] : "default";
< 	bool bDisplay = argc > 3 ? (string(argv[3]) == "yes" ? true : false) : false;
< 
< 	cerr << "Benchmark type: evaluate." << endl;
< 
< 	if (fenFile != "default")
< 	{
< 		string fen;
< 		ifstream f(fenFile.c_str());
< 
< 		if (!f.is_open())
< 		{
< 			cerr << "Unable to open file " << fenFile << endl;
< 			exit(EXIT_FAILURE);
< 		}
< 
< 		while (getline(f, fen)) {
< 			if (!fen.empty()) {
< 				if (fen.compare(0, 5, "sfen ") == 0) {
< 					fen.erase(0, 5);
< 				}
< 				sfenList.push_back(fen);
< 			}
< 		}
< 
< 		f.close();
< 		cerr << "SFEN file is" << fenFile << "." << endl;
< 	}
< 	else {
< 		for (int i = 0; !EvalPos[i].empty(); i++) {
< 			sfenList.push_back(EvalPos[i]);
< 		}
< 	}
< 
< 	time = get_system_time();
< 
< #if defined(NDEBUG)
< 	int loops = 1000*1000;	// 1M回
< #else
< 	int loops =   50*1000;	// 50k回
< #endif
< 	int j;
< 	volatile Value v = VALUE_ZERO;
< 	Value m = VALUE_ZERO;
< 	for (size_t i = 0; i < sfenList.size(); i++)
< 	{
< 		Position pos(sfenList[i], 0);
< #if defined(_DEBUG)
< 		int failState;
< 		assert(pos.is_ok(&failState));
< #endif
< 
< 		cerr << "\nBench position: " << i + 1 << '/' << sfenList.size() << endl;
< 		int rap_time = get_system_time();
< 		for (j = 0; j < loops; j++) {
< 			v = evaluate(pos, m);
< 		}
< 		rap_time = get_system_time() - rap_time;
< 		if (bDisplay) pos.print_csa();
< 		cerr << "  evaluate():m=" << pos.get_material() << ", v= " << int(v) << ", margin=" << int(m) << ", time= " << rap_time << "(ms), " << conv_per_s(loops, rap_time) << " evaluate/s" << endl;
< 	}
< 
< 	time = get_system_time() - time;
< 
< 	cerr << "\n==============================="
< 		 << "\nTotal time (ms) : " << time << endl;
---
>   vector<string> fenList;
>   SearchLimits limits;
>   int64_t totalNodes;
>   int time;
> 
>   // Load default positions
>   for (int i = 0; !Defaults[i].empty(); i++)
>       fenList.push_back(Defaults[i]);
> 
>   // Assign default values to missing arguments
>   string ttSize  = argc > 2 ? argv[2] : "128";
>   string threads = argc > 3 ? argv[3] : "1";
>   string valStr  = argc > 4 ? argv[4] : "12";
>   string fenFile = argc > 5 ? argv[5] : "default";
>   string valType = argc > 6 ? argv[6] : "depth";
> 
>   Options["Hash"].set_value(ttSize);
>   Options["Threads"].set_value(threads);
>   Options["OwnBook"].set_value("false");
> 
>   // Search should be limited by nodes, time or depth ?
>   if (valType == "nodes")
>       limits.maxNodes = atoi(valStr.c_str());
>   else if (valType == "time")
>       limits.maxTime = 1000 * atoi(valStr.c_str()); // maxTime is in ms
>   else
>       limits.maxDepth = atoi(valStr.c_str());
> 
>   // Do we need to load positions from a given FEN file ?
>   if (fenFile != "default")
>   {
>       string fen;
>       ifstream f(fenFile.c_str());
> 
>       if (f.is_open())
>       {
>           fenList.clear();
> 
>           while (getline(f, fen))
>               if (!fen.empty())
>                   fenList.push_back(fen);
> 
>           f.close();
>       }
>       else
>       {
>           cerr << "Unable to open FEN file " << fenFile << endl;
>           exit(EXIT_FAILURE);
>       }
>   }
> 
>   // Ok, let's start the benchmark !
>   totalNodes = 0;
>   time = get_system_time();
> 
>   for (size_t i = 0; i < fenList.size(); i++)
>   {
>       Move moves[] = { MOVE_NONE };
>       Position pos(fenList[i], false, 0);
> 
>       cerr << "\nBench position: " << i + 1 << '/' << fenList.size() << endl;
> 
>       if (valType == "perft")
>       {
>           int64_t cnt = perft(pos, limits.maxDepth * ONE_PLY);
>           totalNodes += cnt;
> 
>           cerr << "\nPerft " << limits.maxDepth << " nodes counted: " << cnt << endl;
>       }
>       else
>       {
>           if (!think(pos, limits, moves))
>               break;
> 
>           totalNodes += pos.nodes_searched();
>       }
>   }
> 
>   time = get_system_time() - time;
> 
>   cerr << "\n==============================="
>        << "\nTotal time (ms) : " << time
>        << "\nNodes searched  : " << totalNodes
>        << "\nNodes/second    : " << (int)(totalNodes / (time / 1000.0)) << endl << endl;
> 
>   // MS Visual C++ debug window always unconditionally closes when program
>   // exits, this is bad because we want to read results before.
>   #if (defined(WINDOWS) || defined(WIN32) || defined(WIN64))
>   cerr << "Press any key to exit" << endl;
>   cin >> time;
>   #endif
529d153
< #endif
########################## book.cpp
2c2
<   NanohaMini, a USI shogi(japanese-chess) playing engine derived from Stockfish 2.1
---
>   Stockfish, a UCI chess playing engine derived from Glaurung 2.1
4,5c4
<   Copyright (C) 2008-2010 Marco Costalba, Joona Kiiski, Tord Romstad (Stockfish author)
<   Copyright (C) 2014 Kazuyuki Kawabata
---
>   Copyright (C) 2008-2010 Marco Costalba, Joona Kiiski, Tord Romstad
7c6
<   NanohaMini is free software: you can redistribute it and/or modify
---
>   Stockfish is free software: you can redistribute it and/or modify
12c11
<   NanohaMini is distributed in the hope that it will be useful,
---
>   Stockfish is distributed in the hope that it will be useful,
20a20,26
> 
> /*
>   The code in this file is based on the opening book code in PolyGlot
>   by Fabien Letouzey. PolyGlot is available under the GNU General
>   Public License, and can be downloaded from http://wbec-ridderkerk.nl
> */
> 
26d31
< #include "position.h"
28c33,527
< Book *book;
---
> using namespace std;
> 
> namespace {
> 
>   // Random numbers from PolyGlot, used to compute book hash keys
>   const uint64_t Random64[781] = {
>     0x9D39247E33776D41ULL, 0x2AF7398005AAA5C7ULL, 0x44DB015024623547ULL,
>     0x9C15F73E62A76AE2ULL, 0x75834465489C0C89ULL, 0x3290AC3A203001BFULL,
>     0x0FBBAD1F61042279ULL, 0xE83A908FF2FB60CAULL, 0x0D7E765D58755C10ULL,
>     0x1A083822CEAFE02DULL, 0x9605D5F0E25EC3B0ULL, 0xD021FF5CD13A2ED5ULL,
>     0x40BDF15D4A672E32ULL, 0x011355146FD56395ULL, 0x5DB4832046F3D9E5ULL,
>     0x239F8B2D7FF719CCULL, 0x05D1A1AE85B49AA1ULL, 0x679F848F6E8FC971ULL,
>     0x7449BBFF801FED0BULL, 0x7D11CDB1C3B7ADF0ULL, 0x82C7709E781EB7CCULL,
>     0xF3218F1C9510786CULL, 0x331478F3AF51BBE6ULL, 0x4BB38DE5E7219443ULL,
>     0xAA649C6EBCFD50FCULL, 0x8DBD98A352AFD40BULL, 0x87D2074B81D79217ULL,
>     0x19F3C751D3E92AE1ULL, 0xB4AB30F062B19ABFULL, 0x7B0500AC42047AC4ULL,
>     0xC9452CA81A09D85DULL, 0x24AA6C514DA27500ULL, 0x4C9F34427501B447ULL,
>     0x14A68FD73C910841ULL, 0xA71B9B83461CBD93ULL, 0x03488B95B0F1850FULL,
>     0x637B2B34FF93C040ULL, 0x09D1BC9A3DD90A94ULL, 0x3575668334A1DD3BULL,
>     0x735E2B97A4C45A23ULL, 0x18727070F1BD400BULL, 0x1FCBACD259BF02E7ULL,
>     0xD310A7C2CE9B6555ULL, 0xBF983FE0FE5D8244ULL, 0x9F74D14F7454A824ULL,
>     0x51EBDC4AB9BA3035ULL, 0x5C82C505DB9AB0FAULL, 0xFCF7FE8A3430B241ULL,
>     0x3253A729B9BA3DDEULL, 0x8C74C368081B3075ULL, 0xB9BC6C87167C33E7ULL,
>     0x7EF48F2B83024E20ULL, 0x11D505D4C351BD7FULL, 0x6568FCA92C76A243ULL,
>     0x4DE0B0F40F32A7B8ULL, 0x96D693460CC37E5DULL, 0x42E240CB63689F2FULL,
>     0x6D2BDCDAE2919661ULL, 0x42880B0236E4D951ULL, 0x5F0F4A5898171BB6ULL,
>     0x39F890F579F92F88ULL, 0x93C5B5F47356388BULL, 0x63DC359D8D231B78ULL,
>     0xEC16CA8AEA98AD76ULL, 0x5355F900C2A82DC7ULL, 0x07FB9F855A997142ULL,
>     0x5093417AA8A7ED5EULL, 0x7BCBC38DA25A7F3CULL, 0x19FC8A768CF4B6D4ULL,
>     0x637A7780DECFC0D9ULL, 0x8249A47AEE0E41F7ULL, 0x79AD695501E7D1E8ULL,
>     0x14ACBAF4777D5776ULL, 0xF145B6BECCDEA195ULL, 0xDABF2AC8201752FCULL,
>     0x24C3C94DF9C8D3F6ULL, 0xBB6E2924F03912EAULL, 0x0CE26C0B95C980D9ULL,
>     0xA49CD132BFBF7CC4ULL, 0xE99D662AF4243939ULL, 0x27E6AD7891165C3FULL,
>     0x8535F040B9744FF1ULL, 0x54B3F4FA5F40D873ULL, 0x72B12C32127FED2BULL,
>     0xEE954D3C7B411F47ULL, 0x9A85AC909A24EAA1ULL, 0x70AC4CD9F04F21F5ULL,
>     0xF9B89D3E99A075C2ULL, 0x87B3E2B2B5C907B1ULL, 0xA366E5B8C54F48B8ULL,
>     0xAE4A9346CC3F7CF2ULL, 0x1920C04D47267BBDULL, 0x87BF02C6B49E2AE9ULL,
>     0x092237AC237F3859ULL, 0xFF07F64EF8ED14D0ULL, 0x8DE8DCA9F03CC54EULL,
>     0x9C1633264DB49C89ULL, 0xB3F22C3D0B0B38EDULL, 0x390E5FB44D01144BULL,
>     0x5BFEA5B4712768E9ULL, 0x1E1032911FA78984ULL, 0x9A74ACB964E78CB3ULL,
>     0x4F80F7A035DAFB04ULL, 0x6304D09A0B3738C4ULL, 0x2171E64683023A08ULL,
>     0x5B9B63EB9CEFF80CULL, 0x506AACF489889342ULL, 0x1881AFC9A3A701D6ULL,
>     0x6503080440750644ULL, 0xDFD395339CDBF4A7ULL, 0xEF927DBCF00C20F2ULL,
>     0x7B32F7D1E03680ECULL, 0xB9FD7620E7316243ULL, 0x05A7E8A57DB91B77ULL,
>     0xB5889C6E15630A75ULL, 0x4A750A09CE9573F7ULL, 0xCF464CEC899A2F8AULL,
>     0xF538639CE705B824ULL, 0x3C79A0FF5580EF7FULL, 0xEDE6C87F8477609DULL,
>     0x799E81F05BC93F31ULL, 0x86536B8CF3428A8CULL, 0x97D7374C60087B73ULL,
>     0xA246637CFF328532ULL, 0x043FCAE60CC0EBA0ULL, 0x920E449535DD359EULL,
>     0x70EB093B15B290CCULL, 0x73A1921916591CBDULL, 0x56436C9FE1A1AA8DULL,
>     0xEFAC4B70633B8F81ULL, 0xBB215798D45DF7AFULL, 0x45F20042F24F1768ULL,
>     0x930F80F4E8EB7462ULL, 0xFF6712FFCFD75EA1ULL, 0xAE623FD67468AA70ULL,
>     0xDD2C5BC84BC8D8FCULL, 0x7EED120D54CF2DD9ULL, 0x22FE545401165F1CULL,
>     0xC91800E98FB99929ULL, 0x808BD68E6AC10365ULL, 0xDEC468145B7605F6ULL,
>     0x1BEDE3A3AEF53302ULL, 0x43539603D6C55602ULL, 0xAA969B5C691CCB7AULL,
>     0xA87832D392EFEE56ULL, 0x65942C7B3C7E11AEULL, 0xDED2D633CAD004F6ULL,
>     0x21F08570F420E565ULL, 0xB415938D7DA94E3CULL, 0x91B859E59ECB6350ULL,
>     0x10CFF333E0ED804AULL, 0x28AED140BE0BB7DDULL, 0xC5CC1D89724FA456ULL,
>     0x5648F680F11A2741ULL, 0x2D255069F0B7DAB3ULL, 0x9BC5A38EF729ABD4ULL,
>     0xEF2F054308F6A2BCULL, 0xAF2042F5CC5C2858ULL, 0x480412BAB7F5BE2AULL,
>     0xAEF3AF4A563DFE43ULL, 0x19AFE59AE451497FULL, 0x52593803DFF1E840ULL,
>     0xF4F076E65F2CE6F0ULL, 0x11379625747D5AF3ULL, 0xBCE5D2248682C115ULL,
>     0x9DA4243DE836994FULL, 0x066F70B33FE09017ULL, 0x4DC4DE189B671A1CULL,
>     0x51039AB7712457C3ULL, 0xC07A3F80C31FB4B4ULL, 0xB46EE9C5E64A6E7CULL,
>     0xB3819A42ABE61C87ULL, 0x21A007933A522A20ULL, 0x2DF16F761598AA4FULL,
>     0x763C4A1371B368FDULL, 0xF793C46702E086A0ULL, 0xD7288E012AEB8D31ULL,
>     0xDE336A2A4BC1C44BULL, 0x0BF692B38D079F23ULL, 0x2C604A7A177326B3ULL,
>     0x4850E73E03EB6064ULL, 0xCFC447F1E53C8E1BULL, 0xB05CA3F564268D99ULL,
>     0x9AE182C8BC9474E8ULL, 0xA4FC4BD4FC5558CAULL, 0xE755178D58FC4E76ULL,
>     0x69B97DB1A4C03DFEULL, 0xF9B5B7C4ACC67C96ULL, 0xFC6A82D64B8655FBULL,
>     0x9C684CB6C4D24417ULL, 0x8EC97D2917456ED0ULL, 0x6703DF9D2924E97EULL,
>     0xC547F57E42A7444EULL, 0x78E37644E7CAD29EULL, 0xFE9A44E9362F05FAULL,
>     0x08BD35CC38336615ULL, 0x9315E5EB3A129ACEULL, 0x94061B871E04DF75ULL,
>     0xDF1D9F9D784BA010ULL, 0x3BBA57B68871B59DULL, 0xD2B7ADEEDED1F73FULL,
>     0xF7A255D83BC373F8ULL, 0xD7F4F2448C0CEB81ULL, 0xD95BE88CD210FFA7ULL,
>     0x336F52F8FF4728E7ULL, 0xA74049DAC312AC71ULL, 0xA2F61BB6E437FDB5ULL,
>     0x4F2A5CB07F6A35B3ULL, 0x87D380BDA5BF7859ULL, 0x16B9F7E06C453A21ULL,
>     0x7BA2484C8A0FD54EULL, 0xF3A678CAD9A2E38CULL, 0x39B0BF7DDE437BA2ULL,
>     0xFCAF55C1BF8A4424ULL, 0x18FCF680573FA594ULL, 0x4C0563B89F495AC3ULL,
>     0x40E087931A00930DULL, 0x8CFFA9412EB642C1ULL, 0x68CA39053261169FULL,
>     0x7A1EE967D27579E2ULL, 0x9D1D60E5076F5B6FULL, 0x3810E399B6F65BA2ULL,
>     0x32095B6D4AB5F9B1ULL, 0x35CAB62109DD038AULL, 0xA90B24499FCFAFB1ULL,
>     0x77A225A07CC2C6BDULL, 0x513E5E634C70E331ULL, 0x4361C0CA3F692F12ULL,
>     0xD941ACA44B20A45BULL, 0x528F7C8602C5807BULL, 0x52AB92BEB9613989ULL,
>     0x9D1DFA2EFC557F73ULL, 0x722FF175F572C348ULL, 0x1D1260A51107FE97ULL,
>     0x7A249A57EC0C9BA2ULL, 0x04208FE9E8F7F2D6ULL, 0x5A110C6058B920A0ULL,
>     0x0CD9A497658A5698ULL, 0x56FD23C8F9715A4CULL, 0x284C847B9D887AAEULL,
>     0x04FEABFBBDB619CBULL, 0x742E1E651C60BA83ULL, 0x9A9632E65904AD3CULL,
>     0x881B82A13B51B9E2ULL, 0x506E6744CD974924ULL, 0xB0183DB56FFC6A79ULL,
>     0x0ED9B915C66ED37EULL, 0x5E11E86D5873D484ULL, 0xF678647E3519AC6EULL,
>     0x1B85D488D0F20CC5ULL, 0xDAB9FE6525D89021ULL, 0x0D151D86ADB73615ULL,
>     0xA865A54EDCC0F019ULL, 0x93C42566AEF98FFBULL, 0x99E7AFEABE000731ULL,
>     0x48CBFF086DDF285AULL, 0x7F9B6AF1EBF78BAFULL, 0x58627E1A149BBA21ULL,
>     0x2CD16E2ABD791E33ULL, 0xD363EFF5F0977996ULL, 0x0CE2A38C344A6EEDULL,
>     0x1A804AADB9CFA741ULL, 0x907F30421D78C5DEULL, 0x501F65EDB3034D07ULL,
>     0x37624AE5A48FA6E9ULL, 0x957BAF61700CFF4EULL, 0x3A6C27934E31188AULL,
>     0xD49503536ABCA345ULL, 0x088E049589C432E0ULL, 0xF943AEE7FEBF21B8ULL,
>     0x6C3B8E3E336139D3ULL, 0x364F6FFA464EE52EULL, 0xD60F6DCEDC314222ULL,
>     0x56963B0DCA418FC0ULL, 0x16F50EDF91E513AFULL, 0xEF1955914B609F93ULL,
>     0x565601C0364E3228ULL, 0xECB53939887E8175ULL, 0xBAC7A9A18531294BULL,
>     0xB344C470397BBA52ULL, 0x65D34954DAF3CEBDULL, 0xB4B81B3FA97511E2ULL,
>     0xB422061193D6F6A7ULL, 0x071582401C38434DULL, 0x7A13F18BBEDC4FF5ULL,
>     0xBC4097B116C524D2ULL, 0x59B97885E2F2EA28ULL, 0x99170A5DC3115544ULL,
>     0x6F423357E7C6A9F9ULL, 0x325928EE6E6F8794ULL, 0xD0E4366228B03343ULL,
>     0x565C31F7DE89EA27ULL, 0x30F5611484119414ULL, 0xD873DB391292ED4FULL,
>     0x7BD94E1D8E17DEBCULL, 0xC7D9F16864A76E94ULL, 0x947AE053EE56E63CULL,
>     0xC8C93882F9475F5FULL, 0x3A9BF55BA91F81CAULL, 0xD9A11FBB3D9808E4ULL,
>     0x0FD22063EDC29FCAULL, 0xB3F256D8ACA0B0B9ULL, 0xB03031A8B4516E84ULL,
>     0x35DD37D5871448AFULL, 0xE9F6082B05542E4EULL, 0xEBFAFA33D7254B59ULL,
>     0x9255ABB50D532280ULL, 0xB9AB4CE57F2D34F3ULL, 0x693501D628297551ULL,
>     0xC62C58F97DD949BFULL, 0xCD454F8F19C5126AULL, 0xBBE83F4ECC2BDECBULL,
>     0xDC842B7E2819E230ULL, 0xBA89142E007503B8ULL, 0xA3BC941D0A5061CBULL,
>     0xE9F6760E32CD8021ULL, 0x09C7E552BC76492FULL, 0x852F54934DA55CC9ULL,
>     0x8107FCCF064FCF56ULL, 0x098954D51FFF6580ULL, 0x23B70EDB1955C4BFULL,
>     0xC330DE426430F69DULL, 0x4715ED43E8A45C0AULL, 0xA8D7E4DAB780A08DULL,
>     0x0572B974F03CE0BBULL, 0xB57D2E985E1419C7ULL, 0xE8D9ECBE2CF3D73FULL,
>     0x2FE4B17170E59750ULL, 0x11317BA87905E790ULL, 0x7FBF21EC8A1F45ECULL,
>     0x1725CABFCB045B00ULL, 0x964E915CD5E2B207ULL, 0x3E2B8BCBF016D66DULL,
>     0xBE7444E39328A0ACULL, 0xF85B2B4FBCDE44B7ULL, 0x49353FEA39BA63B1ULL,
>     0x1DD01AAFCD53486AULL, 0x1FCA8A92FD719F85ULL, 0xFC7C95D827357AFAULL,
>     0x18A6A990C8B35EBDULL, 0xCCCB7005C6B9C28DULL, 0x3BDBB92C43B17F26ULL,
>     0xAA70B5B4F89695A2ULL, 0xE94C39A54A98307FULL, 0xB7A0B174CFF6F36EULL,
>     0xD4DBA84729AF48ADULL, 0x2E18BC1AD9704A68ULL, 0x2DE0966DAF2F8B1CULL,
>     0xB9C11D5B1E43A07EULL, 0x64972D68DEE33360ULL, 0x94628D38D0C20584ULL,
>     0xDBC0D2B6AB90A559ULL, 0xD2733C4335C6A72FULL, 0x7E75D99D94A70F4DULL,
>     0x6CED1983376FA72BULL, 0x97FCAACBF030BC24ULL, 0x7B77497B32503B12ULL,
>     0x8547EDDFB81CCB94ULL, 0x79999CDFF70902CBULL, 0xCFFE1939438E9B24ULL,
>     0x829626E3892D95D7ULL, 0x92FAE24291F2B3F1ULL, 0x63E22C147B9C3403ULL,
>     0xC678B6D860284A1CULL, 0x5873888850659AE7ULL, 0x0981DCD296A8736DULL,
>     0x9F65789A6509A440ULL, 0x9FF38FED72E9052FULL, 0xE479EE5B9930578CULL,
>     0xE7F28ECD2D49EECDULL, 0x56C074A581EA17FEULL, 0x5544F7D774B14AEFULL,
>     0x7B3F0195FC6F290FULL, 0x12153635B2C0CF57ULL, 0x7F5126DBBA5E0CA7ULL,
>     0x7A76956C3EAFB413ULL, 0x3D5774A11D31AB39ULL, 0x8A1B083821F40CB4ULL,
>     0x7B4A38E32537DF62ULL, 0x950113646D1D6E03ULL, 0x4DA8979A0041E8A9ULL,
>     0x3BC36E078F7515D7ULL, 0x5D0A12F27AD310D1ULL, 0x7F9D1A2E1EBE1327ULL,
>     0xDA3A361B1C5157B1ULL, 0xDCDD7D20903D0C25ULL, 0x36833336D068F707ULL,
>     0xCE68341F79893389ULL, 0xAB9090168DD05F34ULL, 0x43954B3252DC25E5ULL,
>     0xB438C2B67F98E5E9ULL, 0x10DCD78E3851A492ULL, 0xDBC27AB5447822BFULL,
>     0x9B3CDB65F82CA382ULL, 0xB67B7896167B4C84ULL, 0xBFCED1B0048EAC50ULL,
>     0xA9119B60369FFEBDULL, 0x1FFF7AC80904BF45ULL, 0xAC12FB171817EEE7ULL,
>     0xAF08DA9177DDA93DULL, 0x1B0CAB936E65C744ULL, 0xB559EB1D04E5E932ULL,
>     0xC37B45B3F8D6F2BAULL, 0xC3A9DC228CAAC9E9ULL, 0xF3B8B6675A6507FFULL,
>     0x9FC477DE4ED681DAULL, 0x67378D8ECCEF96CBULL, 0x6DD856D94D259236ULL,
>     0xA319CE15B0B4DB31ULL, 0x073973751F12DD5EULL, 0x8A8E849EB32781A5ULL,
>     0xE1925C71285279F5ULL, 0x74C04BF1790C0EFEULL, 0x4DDA48153C94938AULL,
>     0x9D266D6A1CC0542CULL, 0x7440FB816508C4FEULL, 0x13328503DF48229FULL,
>     0xD6BF7BAEE43CAC40ULL, 0x4838D65F6EF6748FULL, 0x1E152328F3318DEAULL,
>     0x8F8419A348F296BFULL, 0x72C8834A5957B511ULL, 0xD7A023A73260B45CULL,
>     0x94EBC8ABCFB56DAEULL, 0x9FC10D0F989993E0ULL, 0xDE68A2355B93CAE6ULL,
>     0xA44CFE79AE538BBEULL, 0x9D1D84FCCE371425ULL, 0x51D2B1AB2DDFB636ULL,
>     0x2FD7E4B9E72CD38CULL, 0x65CA5B96B7552210ULL, 0xDD69A0D8AB3B546DULL,
>     0x604D51B25FBF70E2ULL, 0x73AA8A564FB7AC9EULL, 0x1A8C1E992B941148ULL,
>     0xAAC40A2703D9BEA0ULL, 0x764DBEAE7FA4F3A6ULL, 0x1E99B96E70A9BE8BULL,
>     0x2C5E9DEB57EF4743ULL, 0x3A938FEE32D29981ULL, 0x26E6DB8FFDF5ADFEULL,
>     0x469356C504EC9F9DULL, 0xC8763C5B08D1908CULL, 0x3F6C6AF859D80055ULL,
>     0x7F7CC39420A3A545ULL, 0x9BFB227EBDF4C5CEULL, 0x89039D79D6FC5C5CULL,
>     0x8FE88B57305E2AB6ULL, 0xA09E8C8C35AB96DEULL, 0xFA7E393983325753ULL,
>     0xD6B6D0ECC617C699ULL, 0xDFEA21EA9E7557E3ULL, 0xB67C1FA481680AF8ULL,
>     0xCA1E3785A9E724E5ULL, 0x1CFC8BED0D681639ULL, 0xD18D8549D140CAEAULL,
>     0x4ED0FE7E9DC91335ULL, 0xE4DBF0634473F5D2ULL, 0x1761F93A44D5AEFEULL,
>     0x53898E4C3910DA55ULL, 0x734DE8181F6EC39AULL, 0x2680B122BAA28D97ULL,
>     0x298AF231C85BAFABULL, 0x7983EED3740847D5ULL, 0x66C1A2A1A60CD889ULL,
>     0x9E17E49642A3E4C1ULL, 0xEDB454E7BADC0805ULL, 0x50B704CAB602C329ULL,
>     0x4CC317FB9CDDD023ULL, 0x66B4835D9EAFEA22ULL, 0x219B97E26FFC81BDULL,
>     0x261E4E4C0A333A9DULL, 0x1FE2CCA76517DB90ULL, 0xD7504DFA8816EDBBULL,
>     0xB9571FA04DC089C8ULL, 0x1DDC0325259B27DEULL, 0xCF3F4688801EB9AAULL,
>     0xF4F5D05C10CAB243ULL, 0x38B6525C21A42B0EULL, 0x36F60E2BA4FA6800ULL,
>     0xEB3593803173E0CEULL, 0x9C4CD6257C5A3603ULL, 0xAF0C317D32ADAA8AULL,
>     0x258E5A80C7204C4BULL, 0x8B889D624D44885DULL, 0xF4D14597E660F855ULL,
>     0xD4347F66EC8941C3ULL, 0xE699ED85B0DFB40DULL, 0x2472F6207C2D0484ULL,
>     0xC2A1E7B5B459AEB5ULL, 0xAB4F6451CC1D45ECULL, 0x63767572AE3D6174ULL,
>     0xA59E0BD101731A28ULL, 0x116D0016CB948F09ULL, 0x2CF9C8CA052F6E9FULL,
>     0x0B090A7560A968E3ULL, 0xABEEDDB2DDE06FF1ULL, 0x58EFC10B06A2068DULL,
>     0xC6E57A78FBD986E0ULL, 0x2EAB8CA63CE802D7ULL, 0x14A195640116F336ULL,
>     0x7C0828DD624EC390ULL, 0xD74BBE77E6116AC7ULL, 0x804456AF10F5FB53ULL,
>     0xEBE9EA2ADF4321C7ULL, 0x03219A39EE587A30ULL, 0x49787FEF17AF9924ULL,
>     0xA1E9300CD8520548ULL, 0x5B45E522E4B1B4EFULL, 0xB49C3B3995091A36ULL,
>     0xD4490AD526F14431ULL, 0x12A8F216AF9418C2ULL, 0x001F837CC7350524ULL,
>     0x1877B51E57A764D5ULL, 0xA2853B80F17F58EEULL, 0x993E1DE72D36D310ULL,
>     0xB3598080CE64A656ULL, 0x252F59CF0D9F04BBULL, 0xD23C8E176D113600ULL,
>     0x1BDA0492E7E4586EULL, 0x21E0BD5026C619BFULL, 0x3B097ADAF088F94EULL,
>     0x8D14DEDB30BE846EULL, 0xF95CFFA23AF5F6F4ULL, 0x3871700761B3F743ULL,
>     0xCA672B91E9E4FA16ULL, 0x64C8E531BFF53B55ULL, 0x241260ED4AD1E87DULL,
>     0x106C09B972D2E822ULL, 0x7FBA195410E5CA30ULL, 0x7884D9BC6CB569D8ULL,
>     0x0647DFEDCD894A29ULL, 0x63573FF03E224774ULL, 0x4FC8E9560F91B123ULL,
>     0x1DB956E450275779ULL, 0xB8D91274B9E9D4FBULL, 0xA2EBEE47E2FBFCE1ULL,
>     0xD9F1F30CCD97FB09ULL, 0xEFED53D75FD64E6BULL, 0x2E6D02C36017F67FULL,
>     0xA9AA4D20DB084E9BULL, 0xB64BE8D8B25396C1ULL, 0x70CB6AF7C2D5BCF0ULL,
>     0x98F076A4F7A2322EULL, 0xBF84470805E69B5FULL, 0x94C3251F06F90CF3ULL,
>     0x3E003E616A6591E9ULL, 0xB925A6CD0421AFF3ULL, 0x61BDD1307C66E300ULL,
>     0xBF8D5108E27E0D48ULL, 0x240AB57A8B888B20ULL, 0xFC87614BAF287E07ULL,
>     0xEF02CDD06FFDB432ULL, 0xA1082C0466DF6C0AULL, 0x8215E577001332C8ULL,
>     0xD39BB9C3A48DB6CFULL, 0x2738259634305C14ULL, 0x61CF4F94C97DF93DULL,
>     0x1B6BACA2AE4E125BULL, 0x758F450C88572E0BULL, 0x959F587D507A8359ULL,
>     0xB063E962E045F54DULL, 0x60E8ED72C0DFF5D1ULL, 0x7B64978555326F9FULL,
>     0xFD080D236DA814BAULL, 0x8C90FD9B083F4558ULL, 0x106F72FE81E2C590ULL,
>     0x7976033A39F7D952ULL, 0xA4EC0132764CA04BULL, 0x733EA705FAE4FA77ULL,
>     0xB4D8F77BC3E56167ULL, 0x9E21F4F903B33FD9ULL, 0x9D765E419FB69F6DULL,
>     0xD30C088BA61EA5EFULL, 0x5D94337FBFAF7F5BULL, 0x1A4E4822EB4D7A59ULL,
>     0x6FFE73E81B637FB3ULL, 0xDDF957BC36D8B9CAULL, 0x64D0E29EEA8838B3ULL,
>     0x08DD9BDFD96B9F63ULL, 0x087E79E5A57D1D13ULL, 0xE328E230E3E2B3FBULL,
>     0x1C2559E30F0946BEULL, 0x720BF5F26F4D2EAAULL, 0xB0774D261CC609DBULL,
>     0x443F64EC5A371195ULL, 0x4112CF68649A260EULL, 0xD813F2FAB7F5C5CAULL,
>     0x660D3257380841EEULL, 0x59AC2C7873F910A3ULL, 0xE846963877671A17ULL,
>     0x93B633ABFA3469F8ULL, 0xC0C0F5A60EF4CDCFULL, 0xCAF21ECD4377B28CULL,
>     0x57277707199B8175ULL, 0x506C11B9D90E8B1DULL, 0xD83CC2687A19255FULL,
>     0x4A29C6465A314CD1ULL, 0xED2DF21216235097ULL, 0xB5635C95FF7296E2ULL,
>     0x22AF003AB672E811ULL, 0x52E762596BF68235ULL, 0x9AEBA33AC6ECC6B0ULL,
>     0x944F6DE09134DFB6ULL, 0x6C47BEC883A7DE39ULL, 0x6AD047C430A12104ULL,
>     0xA5B1CFDBA0AB4067ULL, 0x7C45D833AFF07862ULL, 0x5092EF950A16DA0BULL,
>     0x9338E69C052B8E7BULL, 0x455A4B4CFE30E3F5ULL, 0x6B02E63195AD0CF8ULL,
>     0x6B17B224BAD6BF27ULL, 0xD1E0CCD25BB9C169ULL, 0xDE0C89A556B9AE70ULL,
>     0x50065E535A213CF6ULL, 0x9C1169FA2777B874ULL, 0x78EDEFD694AF1EEDULL,
>     0x6DC93D9526A50E68ULL, 0xEE97F453F06791EDULL, 0x32AB0EDB696703D3ULL,
>     0x3A6853C7E70757A7ULL, 0x31865CED6120F37DULL, 0x67FEF95D92607890ULL,
>     0x1F2B1D1F15F6DC9CULL, 0xB69E38A8965C6B65ULL, 0xAA9119FF184CCCF4ULL,
>     0xF43C732873F24C13ULL, 0xFB4A3D794A9A80D2ULL, 0x3550C2321FD6109CULL,
>     0x371F77E76BB8417EULL, 0x6BFA9AAE5EC05779ULL, 0xCD04F3FF001A4778ULL,
>     0xE3273522064480CAULL, 0x9F91508BFFCFC14AULL, 0x049A7F41061A9E60ULL,
>     0xFCB6BE43A9F2FE9BULL, 0x08DE8A1C7797DA9BULL, 0x8F9887E6078735A1ULL,
>     0xB5B4071DBFC73A66ULL, 0x230E343DFBA08D33ULL, 0x43ED7F5A0FAE657DULL,
>     0x3A88A0FBBCB05C63ULL, 0x21874B8B4D2DBC4FULL, 0x1BDEA12E35F6A8C9ULL,
>     0x53C065C6C8E63528ULL, 0xE34A1D250E7A8D6BULL, 0xD6B04D3B7651DD7EULL,
>     0x5E90277E7CB39E2DULL, 0x2C046F22062DC67DULL, 0xB10BB459132D0A26ULL,
>     0x3FA9DDFB67E2F199ULL, 0x0E09B88E1914F7AFULL, 0x10E8B35AF3EEAB37ULL,
>     0x9EEDECA8E272B933ULL, 0xD4C718BC4AE8AE5FULL, 0x81536D601170FC20ULL,
>     0x91B534F885818A06ULL, 0xEC8177F83F900978ULL, 0x190E714FADA5156EULL,
>     0xB592BF39B0364963ULL, 0x89C350C893AE7DC1ULL, 0xAC042E70F8B383F2ULL,
>     0xB49B52E587A1EE60ULL, 0xFB152FE3FF26DA89ULL, 0x3E666E6F69AE2C15ULL,
>     0x3B544EBE544C19F9ULL, 0xE805A1E290CF2456ULL, 0x24B33C9D7ED25117ULL,
>     0xE74733427B72F0C1ULL, 0x0A804D18B7097475ULL, 0x57E3306D881EDB4FULL,
>     0x4AE7D6A36EB5DBCBULL, 0x2D8D5432157064C8ULL, 0xD1E649DE1E7F268BULL,
>     0x8A328A1CEDFE552CULL, 0x07A3AEC79624C7DAULL, 0x84547DDC3E203C94ULL,
>     0x990A98FD5071D263ULL, 0x1A4FF12616EEFC89ULL, 0xF6F7FD1431714200ULL,
>     0x30C05B1BA332F41CULL, 0x8D2636B81555A786ULL, 0x46C9FEB55D120902ULL,
>     0xCCEC0A73B49C9921ULL, 0x4E9D2827355FC492ULL, 0x19EBB029435DCB0FULL,
>     0x4659D2B743848A2CULL, 0x963EF2C96B33BE31ULL, 0x74F85198B05A2E7DULL,
>     0x5A0F544DD2B1FB18ULL, 0x03727073C2E134B1ULL, 0xC7F6AA2DE59AEA61ULL,
>     0x352787BAA0D7C22FULL, 0x9853EAB63B5E0B35ULL, 0xABBDCDD7ED5C0860ULL,
>     0xCF05DAF5AC8D77B0ULL, 0x49CAD48CEBF4A71EULL, 0x7A4C10EC2158C4A6ULL,
>     0xD9E92AA246BF719EULL, 0x13AE978D09FE5557ULL, 0x730499AF921549FFULL,
>     0x4E4B705B92903BA4ULL, 0xFF577222C14F0A3AULL, 0x55B6344CF97AAFAEULL,
>     0xB862225B055B6960ULL, 0xCAC09AFBDDD2CDB4ULL, 0xDAF8E9829FE96B5FULL,
>     0xB5FDFC5D3132C498ULL, 0x310CB380DB6F7503ULL, 0xE87FBB46217A360EULL,
>     0x2102AE466EBB1148ULL, 0xF8549E1A3AA5E00DULL, 0x07A69AFDCC42261AULL,
>     0xC4C118BFE78FEAAEULL, 0xF9F4892ED96BD438ULL, 0x1AF3DBE25D8F45DAULL,
>     0xF5B4B0B0D2DEEEB4ULL, 0x962ACEEFA82E1C84ULL, 0x046E3ECAAF453CE9ULL,
>     0xF05D129681949A4CULL, 0x964781CE734B3C84ULL, 0x9C2ED44081CE5FBDULL,
>     0x522E23F3925E319EULL, 0x177E00F9FC32F791ULL, 0x2BC60A63A6F3B3F2ULL,
>     0x222BBFAE61725606ULL, 0x486289DDCC3D6780ULL, 0x7DC7785B8EFDFC80ULL,
>     0x8AF38731C02BA980ULL, 0x1FAB64EA29A2DDF7ULL, 0xE4D9429322CD065AULL,
>     0x9DA058C67844F20CULL, 0x24C0E332B70019B0ULL, 0x233003B5A6CFE6ADULL,
>     0xD586BD01C5C217F6ULL, 0x5E5637885F29BC2BULL, 0x7EBA726D8C94094BULL,
>     0x0A56A5F0BFE39272ULL, 0xD79476A84EE20D06ULL, 0x9E4C1269BAA4BF37ULL,
>     0x17EFEE45B0DEE640ULL, 0x1D95B0A5FCF90BC6ULL, 0x93CBE0B699C2585DULL,
>     0x65FA4F227A2B6D79ULL, 0xD5F9E858292504D5ULL, 0xC2B5A03F71471A6FULL,
>     0x59300222B4561E00ULL, 0xCE2F8642CA0712DCULL, 0x7CA9723FBB2E8988ULL,
>     0x2785338347F2BA08ULL, 0xC61BB3A141E50E8CULL, 0x150F361DAB9DEC26ULL,
>     0x9F6A419D382595F4ULL, 0x64A53DC924FE7AC9ULL, 0x142DE49FFF7A7C3DULL,
>     0x0C335248857FA9E7ULL, 0x0A9C32D5EAE45305ULL, 0xE6C42178C4BBB92EULL,
>     0x71F1CE2490D20B07ULL, 0xF1BCC3D275AFE51AULL, 0xE728E8C83C334074ULL,
>     0x96FBF83A12884624ULL, 0x81A1549FD6573DA5ULL, 0x5FA7867CAF35E149ULL,
>     0x56986E2EF3ED091BULL, 0x917F1DD5F8886C61ULL, 0xD20D8C88C8FFE65FULL,
>     0x31D71DCE64B2C310ULL, 0xF165B587DF898190ULL, 0xA57E6339DD2CF3A0ULL,
>     0x1EF6E6DBB1961EC9ULL, 0x70CC73D90BC26E24ULL, 0xE21A6B35DF0C3AD7ULL,
>     0x003A93D8B2806962ULL, 0x1C99DED33CB890A1ULL, 0xCF3145DE0ADD4289ULL,
>     0xD0E4427A5514FB72ULL, 0x77C621CC9FB3A483ULL, 0x67A34DAC4356550BULL,
>     0xF8D626AAAF278509ULL
>   };
> 
>   // Indices to the Random64[] array
>   const int PieceIdx     = 0;
>   const int CastleIdx    = 768;
>   const int EnPassantIdx = 772;
>   const int TurnIdx      = 780;
> 
>   // book_key() builds up a PolyGlot hash key out of a position
>   uint64_t book_key(const Position& pos) {
> 
>     // Piece offset is calculated as (64 * PolyPieceType + square), where
>     // PolyPieceType is: BP = 0, WP = 1, BN = 2, WN = 3 .... BK = 10, WK = 11
>     static const int PieceToPoly[] = { 0, 1, 3, 5, 7, 9, 11, 0, 0, 0, 2, 4, 6, 8, 10 };
> 
>     uint64_t result = 0;
>     Bitboard b = pos.occupied_squares();
> 
>     while (b)
>     {
>         Square s = pop_1st_bit(&b);
>         int p = PieceToPoly[int(pos.piece_on(s))];
>         result ^= Random64[PieceIdx + 64 * p + int(s)];
>     }
> 
>     if (pos.can_castle_kingside(WHITE))
>         result ^= Random64[CastleIdx + 0];
> 
>     if (pos.can_castle_queenside(WHITE))
>         result ^= Random64[CastleIdx + 1];
> 
>     if (pos.can_castle_kingside(BLACK))
>         result ^= Random64[CastleIdx + 2];
> 
>     if (pos.can_castle_queenside(BLACK))
>         result ^= Random64[CastleIdx + 3];
> 
>     if (pos.ep_square() != SQ_NONE)
>         result ^= Random64[EnPassantIdx + square_file(pos.ep_square())];
> 
>     if (pos.side_to_move() == WHITE)
>         result ^= Random64[TurnIdx];
> 
>     return result;
>   }
> 
> }
> 
> 
> /// Book c'tor. Make random number generation less deterministic, for book moves
> Book::Book() {
> 
>   for (int i = abs(get_system_time() % 10000); i > 0; i--)
>       RKiss.rand<unsigned>();
> }
> 
> 
> /// Book destructor. Be sure file is closed before we leave.
> 
> Book::~Book() {
> 
>   close();
> }
> 
> 
> /// Book::close() closes the file only if it is open, otherwise
> /// we can end up in a little mess due to how std::ifstream works.
> 
> void Book::close() {
> 
>   if (bookFile.is_open())
>       bookFile.close();
> 
>   bookName = "";
> }
> 
> 
> /// Book::open() opens a book file with a given file name
> 
> void Book::open(const string& fileName) {
> 
>   // Close old file before opening the new
>   close();
> 
>   bookFile.open(fileName.c_str(), ifstream::in | ifstream::binary);
> 
>   // Silently return when asked to open a non-exsistent file
>   if (!bookFile.is_open())
>       return;
> 
>   // Get the book size in number of entries
>   bookFile.seekg(0, ios::end);
>   bookSize = long(bookFile.tellg()) / sizeof(BookEntry);
> 
>   if (!bookFile.good())
>   {
>       cerr << "Failed to open book file " << fileName << endl;
>       exit(EXIT_FAILURE);
>   }
> 
>   // Set only if successful
>   bookName = fileName;
> }
> 
> 
> /// Book::get_move() gets a book move for a given position. Returns
> /// MOVE_NONE if no book move is found. If findBestMove is true then
> /// return always the highest rated book move.
> 
> Move Book::get_move(const Position& pos, bool findBestMove) {
> 
>   if (!bookFile.is_open() || bookSize == 0)
>       return MOVE_NONE;
> 
>   BookEntry entry;
>   int bookMove = MOVE_NONE;
>   unsigned score, scoresSum = 0, bestScore = 0;
>   uint64_t key = book_key(pos);
> 
>   // Choose a book move among the possible moves for the given position
>   for (int idx = find_entry(key); idx < bookSize; idx++)
>   {
>       entry = read_entry(idx);
> 
>       if (entry.key != key)
>           break;
> 
>       score = entry.count;
> 
>       if (!findBestMove)
>       {
>           // Choose book move according to its score. If a move has a very
>           // high score it has more probability to be choosen then a one with
>           // lower score. Note that first entry is always chosen.
>           scoresSum += score;
>           if (RKiss.rand<unsigned>() % scoresSum < score)
>               bookMove = entry.move;
>       }
>       else if (score > bestScore)
>       {
>           bestScore = score;
>           bookMove = entry.move;
>       }
>   }
> 
>   // A PolyGlot book move is encoded as follows:
>   //
>   // bit  0- 5: destination square (from 0 to 63)
>   // bit  6-11: origin square (from 0 to 63)
>   // bit 12-13-14: promotion piece (from KNIGHT == 1 to QUEEN == 4)
>   //
>   // Castling moves follow "king captures rook" representation. So in case
>   // book move is a promotion we have to convert to our representation, in
>   // all other cases we can directly compare with a Move after having
>   // masked out special Move's flags that are not supported by PolyGlot.
>   int p = (bookMove >> 12) & 7;
> 
>   if (p)
>       bookMove = int(make_promotion_move(move_from(Move(bookMove)),
>                  move_to(Move(bookMove)), PieceType(p + 1)));
> 
>   // Verify the book move (if any) is legal
>   MoveStack mlist[MAX_MOVES];
>   MoveStack* last = generate<MV_LEGAL>(pos, mlist);
>   for (MoveStack* cur = mlist; cur != last; cur++)
>       if ((int(cur->move) & ~(3 << 14)) == bookMove) // Mask out special flags
>           return cur->move;
> 
>   return MOVE_NONE;
> }
> 
> 
> /// Book::find_entry() takes a book key as input, and does a binary search
> /// through the book file for the given key. The index to the first book
> /// entry with the same key as the input is returned. When the key is not
> /// found in the book file, bookSize is returned.
> 
> int Book::find_entry(uint64_t key) {
> 
>   int left, right, mid;
> 
>   // Binary search (finds the leftmost entry)
>   left = 0;
>   right = bookSize - 1;
> 
>   assert(left <= right);
> 
>   while (left < right)
>   {
>       mid = (left + right) / 2;
> 
>       assert(mid >= left && mid < right);
> 
>       if (key <= read_entry(mid).key)
>           right = mid;
>       else
>           left = mid + 1;
>   }
> 
>   assert(left == right);
> 
>   return read_entry(left).key == key ? left : bookSize;
> }
> 
> 
> /// Book::get_number() reads sizeof(T) chars from the file's binary byte
> /// stream and converts them in a number of type T.
> template<typename T>
> void Book::get_number(T& n) {
> 
>   n = 0;
> 
>   for (size_t i = 0; i < sizeof(T); i++)
>       n = (n << 8) + (T)bookFile.get();
> }
> 
> 
> /// Book::read_entry() takes an integer index, and returns the BookEntry
> /// at the given index in the book file.
> 
> BookEntry Book::read_entry(int idx) {
> 
>   assert(idx >= 0 && idx < bookSize);
>   assert(bookFile.is_open());
> 
>   BookEntry e;
> 
>   bookFile.seekg(idx * sizeof(BookEntry), ios_base::beg);
30,207c529,532
< Book::Book() : joseki(), RKiss()
< {
< 	for (int i = abs(get_system_time() % 10000); i > 0; i--)
< 		RKiss.rand<unsigned>();
< }
< Book::~Book() {}
< void Book::open(const std::string& fileName)
< {
< 	FILE *fp = fopen(fileName.c_str(), "rb");
< 	if (fp == NULL) {
< 		perror(fileName.c_str());
< 		return;
< 	}
< 
< 	BookKey key;
< 	BookEntry data;
< 
< 	for (;;) {
< 		size_t n;
< 		n = fread(&key, sizeof(key), 1, fp);
< 		if (n == 0) break;
< 		n = fread(&data, sizeof(data), 1, fp);
< 		if (n == 0) break;
< 		Joseki_type::iterator p;
< 		p = joseki.find(key);
< 		if (p == joseki.end()) {
< 			joseki.insert(Joseki_value(key, data));
< 		} else {
< 			output_info("Error!:Duplicated opening data\n");
< 		}
< 	}
< 
< 	fclose(fp);
< }
< void Book::close(){}
< // 定跡データから、現在の局面kの合法手がその局面でどれくらいの頻度で指されたかを返す。
< void Book::fromJoseki(Position &pos, int &mNum, MoveStack moves[], BookEntry data[])
< {
< 	BookKey key;
< 	BookEntry d_null;
< 	MoveStack *last = generate<MV_LEGAL>(pos, moves);
< 	mNum = last - moves;
< 	memset(&d_null, 0, sizeof(d_null));
< 
< 	int i;
< 	StateInfo newSt;
< 	for (i = 0; i < mNum; i++) {
< 		Move m = moves[i].move;
< 		pos.do_move(m, newSt);
< 		int ret = pos.EncodeHuffman(key.data);
< 		pos.undo_move(m);
< 		if (ret < 0) {
< 			pos.print_csa(m);
< 			output_info("Error!:Huffman encode!\n");
< 			continue;
< 		}
< 		Joseki_type::iterator p;
< 		p = joseki.find(key);
< 		if (p == joseki.end()) {
< 			// データなし
< 			data[i] = d_null;
< 		} else {
< 			// データあり
< 			data[i] = p->second;
< 		}
< 	}
< }
< 
< // 現在の局面がどのくらいの頻度で指されたか定跡データを調べる
< int Book::getHindo(const Position &pos)
< {
< 	BookKey key;
< 	int hindo = 0;
< 
< 	int ret = pos.EncodeHuffman(key.data);
< 	if (ret < 0) {
< 		pos.print_csa();
< 		output_info("Error!:Huffman encode!\n");
< 		return 0;
< 	}
< 	Joseki_type::iterator p;
< 	p = joseki.find(key);
< 	if (p != joseki.end()) {
< 		// データあり
< 		hindo = p->second.hindo;
< 	}
< 
< 	return hindo;
< }
< 
< Move Book::get_move(Position& pos, bool findBestMove)
< {
< 	// 定跡データに手があればそれを使う.
< 	// 新形式を優先する
< 	if (size() > 0) {
< 		int teNum = 0;
< 		MoveStack moves[MAX_MOVES];
< 		BookEntry hindo2[MAX_MOVES];
< 		BookEntry candidate[4];
< 		int i;
< 		memset(candidate, 0, sizeof(candidate));
< 
< 		fromJoseki(pos, teNum, moves, hindo2);
< 		// 一番勝率の高い手を選ぶ。
< 		float swin = 0.5f;
< 		float win_max = 0.0f;
< 		int max = -1;
< 		int max_hindo = -1;
< 		// 極端に少ない手は選択しない ⇒最頻出数の10分の1以下とする
< 		for (i = 0; i < teNum; i++) {
< 			if (max_hindo < hindo2[i].hindo) {
< 				max_hindo = hindo2[i].hindo;
< 			}
< 		}
< 		for (i = 0; i < teNum; i++) {
< 			if (hindo2[i].hindo > 0) {
< 				// 多いものを候補に入れる
< 				if (candidate[3].hindo < hindo2[i].hindo) {
< 					for (int j = 0; j < 4; j++) {
< 						if (candidate[j].hindo < hindo2[i].hindo) {
< 							for (int k = 3; k > j; k--) {
< 								candidate[k] = candidate[k-1];
< 							}
< 							candidate[j] = hindo2[i];
< 							candidate[j].eval = i;
< 							break;
< 						}
< 					}
< 				}
< 
< 				// 勝率算出
< 				if (hindo2[i].swin + hindo2[i].gwin > 0) {
< 					swin = hindo2[i].swin / float(hindo2[i].swin + hindo2[i].gwin);
< 				} else {
< 					swin = 0.5f;
< 				}
< 				if (pos.side_to_move() != BLACK) swin = 1.0f - swin;
< 
< 				// 極端に少ない手は選択しない ⇒最頻出数の10分の1以下とする
< 				if (max_hindo / 10 < hindo2[i].hindo && win_max < swin) {
< 					max = i;
< 					win_max = swin;
< 				}
< 			}
< 		}
< 
< 		if (max >= 0) {
< 			if (!findBestMove) {
< 				// 乱数で返す
< 				int n = Min(teNum, 4);
< 				int total = 0;
< 				for (i = 0; i < n; i++) {
< 					total += candidate[i].hindo;
< 				}
< 				float p = RKiss.rand<unsigned short>() / 65536.0f;
< 				max = candidate[0].eval;
< 				int sum = 0;
< 				for (i = 0; i < n; i++) {
< 					sum += candidate[i].hindo;
< 					if (float(sum) / total >= p) {
< 						max = candidate[i].eval;
< 						break;
< 					}
< 				}
< 				if (hindo2[max].swin + hindo2[max].gwin > 0) {
< 					swin = hindo2[max].swin / float(hindo2[max].swin + hindo2[max].gwin);
< 					if (pos.side_to_move() != BLACK) swin = 1.0f - swin;
< 				} else {
< 					swin = 0.5f;
< 				}
< 			}
< 			// もっともよさそうな手を返す
< 			output_info("info string %5.1f%%, P(%d, %d)\n", swin*100.0f, hindo2[max].swin, hindo2[max].gwin);
< 			return moves[max].move;
< 		} else {
< 			output_info("info string No book data(plys=%d)\n", pos.startpos_ply_counter());
< 		}
< 	}
---
>   get_number(e.key);
>   get_number(e.move);
>   get_number(e.count);
>   get_number(e.learn);
209c534,539
< 	return MOVE_NONE;
---
>   if (!bookFile.good())
>   {
>       cerr << "Failed to read book entry at index " << idx << endl;
>       exit(EXIT_FAILURE);
>   }
>   return e;
########################## evaluate.cpp
2c2
<   NanohaMini, a USI shogi(japanese-chess) playing engine derived from Stockfish 2.1
---
>   Stockfish, a UCI chess playing engine derived from Glaurung 2.1
4,5c4
<   Copyright (C) 2008-2010 Marco Costalba, Joona Kiiski, Tord Romstad (Stockfish author)
<   Copyright (C) 2014 Kazuyuki Kawabata
---
>   Copyright (C) 2008-2010 Marco Costalba, Joona Kiiski, Tord Romstad
7c6
<   NanohaMini is free software: you can redistribute it and/or modify
---
>   Stockfish is free software: you can redistribute it and/or modify
12c11
<   NanohaMini is distributed in the hope that it will be useful,
---
>   Stockfish is distributed in the hope that it will be useful,
22c21,23
< #include <cstdio>
---
> #include <iostream>
> #include <iomanip>
> #include <sstream>
24c25
< #include "position.h"
---
> #include "bitcount.h"
26,129c27,30
< 
< // 評価関数関連定義
< #if defined(EVAL_MICRO)
< #include "param_micro.h"
< #elif defined(EVAL_OLD)
< #include "param_old.h"
< #define FV_BIN "fv_mini.bin"
< #else
< #include "param_new.h"
< #define FV_BIN "fv_mini2.bin"
< #endif
< #define NLIST	38
< 
< #define FV_SCALE                32
< 
< #define MATERIAL            (this->material)
< 
< #define SQ_BKING            NanohaTbl::z2sq[kingS]
< #define SQ_WKING            NanohaTbl::z2sq[kingG]
< #define HAND_B              (this->hand[BLACK].h)
< #define HAND_W              (this->hand[WHITE].h)
< 
< #define Inv(sq)             (nsquare-1-sq)
< #define PcOnSq(k,i)         fv_kp[k][i]
< #define PcPcOn(i,j)         fv_pp[i][j]
< 
< #define I2HandPawn(hand)    (((hand) & HAND_FU_MASK) >> HAND_FU_SHIFT)
< #define I2HandLance(hand)   (((hand) & HAND_KY_MASK) >> HAND_KY_SHIFT)
< #define I2HandKnight(hand)  (((hand) & HAND_KE_MASK) >> HAND_KE_SHIFT)
< #define I2HandSilver(hand)  (((hand) & HAND_GI_MASK) >> HAND_GI_SHIFT)
< #define I2HandGold(hand)    (((hand) & HAND_KI_MASK) >> HAND_KI_SHIFT)
< #define I2HandBishop(hand)  (((hand) & HAND_KA_MASK) >> HAND_KA_SHIFT)
< #define I2HandRook(hand)    (((hand) & HAND_HI_MASK) >> HAND_HI_SHIFT)
< 
< enum {
< 	promote = 8, EMPTY = 0,	/* VC++でemptyがぶつかるので変更 */
< 	pawn, lance, knight, silver, gold, bishop, rook, king, pro_pawn,
< 	pro_lance, pro_knight, pro_silver, piece_null, horse, dragon
< };
< 
< enum { nhand = 7, nfile = 9,  nrank = 9,  nsquare = 81 };
< 
< #if !defined(EVAL_MICRO)
< enum {
< 	// PP用の定義
< 	pp_bpawn      =  -9,            		//   -9: 先手Pの位置は 9-80(72箇所)、これを  0- 71にマップ
< 	pp_blance     = pp_bpawn   + 72,		//   63: 先手Lの位置は 9-80(72箇所)、これを 72-143にマップ
< 	pp_bknight    = pp_blance  + 63,		//  126: 先手Nの位置は18-80(63箇所)、これを144-206にマップ
< 	pp_bsilver    = pp_bknight + 81,		//  207: 先手Sの位置は 0-80(81箇所)、これを207-287にマップ
< 	pp_bgold      = pp_bsilver + 81,		//  288: 先手Gの位置は 0-80(81箇所)、これを288-368にマップ
< 	pp_bbishop    = pp_bgold   + 81,		//  369: 先手Bの位置は 0-80(81箇所)、これを369-449にマップ
< 	pp_bhorse     = pp_bbishop + 81,		//  450: 先手Hの位置は 0-80(81箇所)、これを450-530にマップ
< 	pp_brook      = pp_bhorse  + 81,		//  531: 先手Rの位置は 0-80(81箇所)、これを531-611にマップ
< 	pp_bdragon    = pp_brook   + 81,		//  612: 先手Dの位置は 0-80(81箇所)、これを612-692にマップ
< 	pp_bend       = pp_bdragon + 81,		//  693: 先手の最終位置
< 
< 	pp_wpawn      = pp_bdragon + 81,		//  693: 後手Pの位置は 0-71(72箇所)、これを 693- 764にマップ
< 	pp_wlance     = pp_wpawn   + 72,		//  765: 後手Lの位置は 0-71(72箇所)、これを 765- 836にマップ
< 	pp_wknight    = pp_wlance  + 72,		//  837: 後手Nの位置は 0-62(63箇所)、これを 837- 899にマップ
< 	pp_wsilver    = pp_wknight + 63,		//  900: 後手Sの位置は 0-80(81箇所)、これを 900- 980にマップ
< 	pp_wgold      = pp_wsilver + 81,		//  981: 後手Gの位置は 0-80(81箇所)、これを 981-1061にマップ
< 	pp_wbishop    = pp_wgold   + 81,		// 1062: 後手Bの位置は 0-80(81箇所)、これを1062-1142にマップ
< 	pp_whorse     = pp_wbishop + 81,		// 1143: 後手Hの位置は 0-80(81箇所)、これを1143-1223にマップ
< 	pp_wrook      = pp_whorse  + 81,		// 1224: 後手Rの位置は 0-80(81箇所)、これを1224-1304にマップ
< 	pp_wdragon    = pp_wrook   + 81,		// 1305: 後手Dの位置は 0-80(81箇所)、これを1305-1385にマップ
< 	pp_end        = pp_wdragon + 81,		// 1386: 後手の最終位置
< 
< 	// K(P+H)用の定義
< 	kp_hand_bpawn   =    0,
< 	kp_hand_wpawn   =   19,
< 	kp_hand_blance  =   38,
< 	kp_hand_wlance  =   43,
< 	kp_hand_bknight =   48,
< 	kp_hand_wknight =   53,
< 	kp_hand_bsilver =   58,
< 	kp_hand_wsilver =   63,
< 	kp_hand_bgold   =   68,
< 	kp_hand_wgold   =   73,
< 	kp_hand_bbishop =   78,
< 	kp_hand_wbishop =   81,
< 	kp_hand_brook   =   84,
< 	kp_hand_wrook   =   87,
< 	kp_hand_end     =   90,
< 	kp_bpawn        =   81,
< 	kp_wpawn        =  162,
< 	kp_blance       =  225,
< 	kp_wlance       =  306,
< 	kp_bknight      =  360,
< 	kp_wknight      =  441,
< 	kp_bsilver      =  504,
< 	kp_wsilver      =  585,
< 	kp_bgold        =  666,
< 	kp_wgold        =  747,
< 	kp_bbishop      =  828,
< 	kp_wbishop      =  909,
< 	kp_bhorse       =  990,
< 	kp_whorse       = 1071,
< 	kp_brook        = 1152,
< 	kp_wrook        = 1233,
< 	kp_bdragon      = 1314,
< 	kp_wdragon      = 1395,
< 	kp_end          = 1476
< };
< #endif
---
> #include "material.h"
> #include "pawns.h"
> #include "thread.h"
> #include "ucioption.h"
132d32
< 	short p_value[31];
134,137c34,256
< #if !defined(EVAL_MICRO)
< 	short fv_pp[pp_bend][pp_end];
< 	short fv_kp[nsquare][kp_end];
< #endif
---
>   // Struct EvalInfo contains various information computed and collected
>   // by the evaluation functions.
>   struct EvalInfo {
> 
>     // Pointers to material and pawn hash table entries
>     MaterialInfo* mi;
>     PawnInfo* pi;
> 
>     // attackedBy[color][piece type] is a bitboard representing all squares
>     // attacked by a given color and piece type, attackedBy[color][0] contains
>     // all squares attacked by the given color.
>     Bitboard attackedBy[2][8];
> 
>     // kingZone[color] is the zone around the enemy king which is considered
>     // by the king safety evaluation. This consists of the squares directly
>     // adjacent to the king, and the three (or two, for a king on an edge file)
>     // squares two ranks in front of the king. For instance, if black's king
>     // is on g8, kingZone[WHITE] is a bitboard containing the squares f8, h8,
>     // f7, g7, h7, f6, g6 and h6.
>     Bitboard kingZone[2];
> 
>     // kingAttackersCount[color] is the number of pieces of the given color
>     // which attack a square in the kingZone of the enemy king.
>     int kingAttackersCount[2];
> 
>     // kingAttackersWeight[color] is the sum of the "weight" of the pieces of the
>     // given color which attack a square in the kingZone of the enemy king. The
>     // weights of the individual piece types are given by the variables
>     // QueenAttackWeight, RookAttackWeight, BishopAttackWeight and
>     // KnightAttackWeight in evaluate.cpp
>     int kingAttackersWeight[2];
> 
>     // kingAdjacentZoneAttacksCount[color] is the number of attacks to squares
>     // directly adjacent to the king of the given color. Pieces which attack
>     // more than one square are counted multiple times. For instance, if black's
>     // king is on g8 and there's a white knight on g5, this knight adds
>     // 2 to kingAdjacentZoneAttacksCount[BLACK].
>     int kingAdjacentZoneAttacksCount[2];
>   };
> 
>   // Evaluation grain size, must be a power of 2
>   const int GrainSize = 8;
> 
>   // Evaluation weights, initialized from UCI options
>   enum { Mobility, PassedPawns, Space, KingDangerUs, KingDangerThem };
>   Score Weights[6];
> 
>   typedef Value V;
>   #define S(mg, eg) make_score(mg, eg)
> 
>   // Internal evaluation weights. These are applied on top of the evaluation
>   // weights read from UCI parameters. The purpose is to be able to change
>   // the evaluation weights while keeping the default values of the UCI
>   // parameters at 100, which looks prettier.
>   //
>   // Values modified by Joona Kiiski
>   const Score WeightsInternal[] = {
>       S(248, 271), S(252, 259), S(46, 0), S(247, 0), S(259, 0)
>   };
> 
>   // MobilityBonus[PieceType][attacked] contains mobility bonuses for middle and
>   // end game, indexed by piece type and number of attacked squares not occupied
>   // by friendly pieces.
>   const Score MobilityBonus[][32] = {
>      {}, {},
>      { S(-38,-33), S(-25,-23), S(-12,-13), S( 0, -3), S(12,  7), S(25, 17), // Knights
>        S( 31, 22), S( 38, 27), S( 38, 27) },
>      { S(-25,-30), S(-11,-16), S(  3, -2), S(17, 12), S(31, 26), S(45, 40), // Bishops
>        S( 57, 52), S( 65, 60), S( 71, 65), S(74, 69), S(76, 71), S(78, 73),
>        S( 79, 74), S( 80, 75), S( 81, 76), S(81, 76) },
>      { S(-20,-36), S(-14,-19), S( -8, -3), S(-2, 13), S( 4, 29), S(10, 46), // Rooks
>        S( 14, 62), S( 19, 79), S( 23, 95), S(26,106), S(27,111), S(28,114),
>        S( 29,116), S( 30,117), S( 31,118), S(32,118) },
>      { S(-10,-18), S( -8,-13), S( -6, -7), S(-3, -2), S(-1,  3), S( 1,  8), // Queens
>        S(  3, 13), S(  5, 19), S(  8, 23), S(10, 27), S(12, 32), S(15, 34),
>        S( 16, 35), S( 17, 35), S( 18, 35), S(20, 35), S(20, 35), S(20, 35),
>        S( 20, 35), S( 20, 35), S( 20, 35), S(20, 35), S(20, 35), S(20, 35),
>        S( 20, 35), S( 20, 35), S( 20, 35), S(20, 35), S(20, 35), S(20, 35),
>        S( 20, 35), S( 20, 35) }
>   };
> 
>   // OutpostBonus[PieceType][Square] contains outpost bonuses of knights and
>   // bishops, indexed by piece type and square (from white's point of view).
>   const Value OutpostBonus[][64] = {
>   {
>   //  A     B     C     D     E     F     G     H
>     V(0), V(0), V(0), V(0), V(0), V(0), V(0), V(0), // Knights
>     V(0), V(0), V(0), V(0), V(0), V(0), V(0), V(0),
>     V(0), V(0), V(4), V(8), V(8), V(4), V(0), V(0),
>     V(0), V(4),V(17),V(26),V(26),V(17), V(4), V(0),
>     V(0), V(8),V(26),V(35),V(35),V(26), V(8), V(0),
>     V(0), V(4),V(17),V(17),V(17),V(17), V(4), V(0) },
>   {
>     V(0), V(0), V(0), V(0), V(0), V(0), V(0), V(0), // Bishops
>     V(0), V(0), V(0), V(0), V(0), V(0), V(0), V(0),
>     V(0), V(0), V(5), V(5), V(5), V(5), V(0), V(0),
>     V(0), V(5),V(10),V(10),V(10),V(10), V(5), V(0),
>     V(0),V(10),V(21),V(21),V(21),V(21),V(10), V(0),
>     V(0), V(5), V(8), V(8), V(8), V(8), V(5), V(0) }
>   };
> 
>   // ThreatBonus[attacking][attacked] contains threat bonuses according to
>   // which piece type attacks which one.
>   const Score ThreatBonus[][8] = {
>     {}, {},
>     { S(0, 0), S( 7, 39), S( 0,  0), S(24, 49), S(41,100), S(41,100) }, // KNIGHT
>     { S(0, 0), S( 7, 39), S(24, 49), S( 0,  0), S(41,100), S(41,100) }, // BISHOP
>     { S(0, 0), S(-1, 29), S(15, 49), S(15, 49), S( 0,  0), S(24, 49) }, // ROOK
>     { S(0, 0), S(15, 39), S(15, 39), S(15, 39), S(15, 39), S( 0,  0) }  // QUEEN
>   };
> 
>   // ThreatenedByPawnPenalty[PieceType] contains a penalty according to which
>   // piece type is attacked by an enemy pawn.
>   const Score ThreatenedByPawnPenalty[] = {
>     S(0, 0), S(0, 0), S(56, 70), S(56, 70), S(76, 99), S(86, 118)
>   };
> 
>   #undef S
> 
>   // Rooks and queens on the 7th rank (modified by Joona Kiiski)
>   const Score RookOn7thBonus  = make_score(47, 98);
>   const Score QueenOn7thBonus = make_score(27, 54);
> 
>   // Rooks on open files (modified by Joona Kiiski)
>   const Score RookOpenFileBonus = make_score(43, 43);
>   const Score RookHalfOpenFileBonus = make_score(19, 19);
> 
>   // Penalty for rooks trapped inside a friendly king which has lost the
>   // right to castle.
>   const Value TrappedRookPenalty = Value(180);
> 
>   // Penalty for a bishop on a1/h1 (a8/h8 for black) which is trapped by
>   // a friendly pawn on b2/g2 (b7/g7 for black). This can obviously only
>   // happen in Chess960 games.
>   const Score TrappedBishopA1H1Penalty = make_score(100, 100);
> 
>   // The SpaceMask[Color] contains the area of the board which is considered
>   // by the space evaluation. In the middle game, each side is given a bonus
>   // based on how many squares inside this area are safe and available for
>   // friendly minor pieces.
>   const Bitboard SpaceMask[] = {
>     (1ULL << SQ_C2) | (1ULL << SQ_D2) | (1ULL << SQ_E2) | (1ULL << SQ_F2) |
>     (1ULL << SQ_C3) | (1ULL << SQ_D3) | (1ULL << SQ_E3) | (1ULL << SQ_F3) |
>     (1ULL << SQ_C4) | (1ULL << SQ_D4) | (1ULL << SQ_E4) | (1ULL << SQ_F4),
>     (1ULL << SQ_C7) | (1ULL << SQ_D7) | (1ULL << SQ_E7) | (1ULL << SQ_F7) |
>     (1ULL << SQ_C6) | (1ULL << SQ_D6) | (1ULL << SQ_E6) | (1ULL << SQ_F6) |
>     (1ULL << SQ_C5) | (1ULL << SQ_D5) | (1ULL << SQ_E5) | (1ULL << SQ_F5)
>   };
> 
>   // King danger constants and variables. The king danger scores are taken
>   // from the KingDangerTable[]. Various little "meta-bonuses" measuring
>   // the strength of the enemy attack are added up into an integer, which
>   // is used as an index to KingDangerTable[].
>   //
>   // KingAttackWeights[PieceType] contains king attack weights by piece type
>   const int KingAttackWeights[] = { 0, 0, 2, 2, 3, 5 };
> 
>   // Bonuses for enemy's safe checks
>   const int QueenContactCheckBonus = 6;
>   const int RookContactCheckBonus  = 4;
>   const int QueenCheckBonus        = 3;
>   const int RookCheckBonus         = 2;
>   const int BishopCheckBonus       = 1;
>   const int KnightCheckBonus       = 1;
> 
>   // InitKingDanger[Square] contains penalties based on the position of the
>   // defending king, indexed by king's square (from white's point of view).
>   const int InitKingDanger[] = {
>      2,  0,  2,  5,  5,  2,  0,  2,
>      2,  2,  4,  8,  8,  4,  2,  2,
>      7, 10, 12, 12, 12, 12, 10,  7,
>     15, 15, 15, 15, 15, 15, 15, 15,
>     15, 15, 15, 15, 15, 15, 15, 15,
>     15, 15, 15, 15, 15, 15, 15, 15,
>     15, 15, 15, 15, 15, 15, 15, 15,
>     15, 15, 15, 15, 15, 15, 15, 15
>   };
> 
>   // KingDangerTable[Color][attackUnits] contains the actual king danger
>   // weighted scores, indexed by color and by a calculated integer number.
>   Score KingDangerTable[2][128];
> 
>   // TracedTerms[Color][PieceType || TracedType] contains a breakdown of the
>   // evaluation terms, used when tracing.
>   Score TracedScores[2][16];
>   std::stringstream TraceStream;
> 
>   enum TracedType {
>       PST = 8, IMBALANCE = 9, MOBILITY = 10, THREAT = 11,
>       PASSED = 12, UNSTOPPABLE = 13, SPACE = 14, TOTAL = 15
>   };
> 
>   // Function prototypes
>   template<bool HasPopCnt, bool Trace>
>   Value do_evaluate(const Position& pos, Value& margin);
> 
>   template<Color Us, bool HasPopCnt>
>   void init_eval_info(const Position& pos, EvalInfo& ei);
> 
>   template<Color Us, bool HasPopCnt, bool Trace>
>   Score evaluate_pieces_of_color(const Position& pos, EvalInfo& ei, Score& mobility);
> 
>   template<Color Us, bool HasPopCnt, bool Trace>
>   Score evaluate_king(const Position& pos, EvalInfo& ei, Value margins[]);
> 
>   template<Color Us>
>   Score evaluate_threats(const Position& pos, EvalInfo& ei);
> 
>   template<Color Us, bool HasPopCnt>
>   int evaluate_space(const Position& pos, EvalInfo& ei);
> 
>   template<Color Us>
>   Score evaluate_passed_pawns(const Position& pos, EvalInfo& ei);
> 
>   template<bool HasPopCnt>
>   Score evaluate_unstoppable_pawns(const Position& pos, EvalInfo& ei);
> 
>   inline Score apply_weight(Score v, Score weight);
>   Value scale_by_game_phase(const Score& v, Phase ph, ScaleFactor sf);
>   Score weight_option(const std::string& mgOpt, const std::string& egOpt, Score internalWeight);
>   void init_safety();
>   double to_cp(Value v);
>   void trace_add(int idx, Score term_w, Score term_b = SCORE_ZERO);
140,153d258
< namespace NanohaTbl {
< 	const short z2sq[] = {
< 		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
< 		-1,  0,  9, 18, 27, 36, 45, 54, 63, 72, -1, -1, -1, -1, -1, -1,
< 		-1,  1, 10, 19, 28, 37, 46, 55, 64, 73, -1, -1, -1, -1, -1, -1,
< 		-1,  2, 11, 20, 29, 38, 47, 56, 65, 74, -1, -1, -1, -1, -1, -1,
< 		-1,  3, 12, 21, 30, 39, 48, 57, 66, 75, -1, -1, -1, -1, -1, -1,
< 		-1,  4, 13, 22, 31, 40, 49, 58, 67, 76, -1, -1, -1, -1, -1, -1,
< 		-1,  5, 14, 23, 32, 41, 50, 59, 68, 77, -1, -1, -1, -1, -1, -1,
< 		-1,  6, 15, 24, 33, 42, 51, 60, 69, 78, -1, -1, -1, -1, -1, -1,
< 		-1,  7, 16, 25, 34, 43, 52, 61, 70, 79, -1, -1, -1, -1, -1, -1,
< 		-1,  8, 17, 26, 35, 44, 53, 62, 71, 80, -1, -1, -1, -1, -1, -1,
< 	};
< }
155,230c260,266
< void Position::init_evaluate()
< {
< 	int iret=0;
< #if !defined(EVAL_MICRO)
< 	FILE *fp;
< 	const char *fname ="評価ベクトル";
< 
< 	do {
< 		size_t size;
< 
< 		fname = FV_BIN;
< 		fp = fopen(fname, "rb");
< 		if ( fp == NULL ) { iret = -2; break;}
< 
< 		size = pp_bend * pp_end;
< 		if ( fread( fv_pp, sizeof(short), size, fp ) != size )
< 		{
< 			iret = -2;
< 			break;
< 		}
< 
< 		size = nsquare * kp_end;
< 		if ( fread( fv_kp, sizeof(short), size, fp ) != size ) {
< 			iret = -2;
< 			break;
< 		}
< 
< 		if (fgetc(fp) != EOF) {
< 			iret = -2;
< 			break;
< 		}
< 	} while (0);
< 	if (fp) fclose( fp );
< 
< 	if (iret < 0) {
< #if !defined(NDEBUG)
< 		std::cerr << "Can't load " FV_BIN "." << std::endl;
< #endif
< #if defined(CSADLL) || defined(CSA_DIRECT)
< 		::MessageBox(NULL, "評価ベクトルがロードできません\n終了します", "Error!", MB_OK);
< 		exit(1);
< #endif	// defined(CSA_DLL) || defined(CSA_DIRECT)
< 	}
< #endif
< 
< 	for (int i = 0; i < 31; i++) { p_value[i]       = 0; }
< 
< 	p_value[15+pawn]       = DPawn;
< 	p_value[15+lance]      = DLance;
< 	p_value[15+knight]     = DKnight;
< 	p_value[15+silver]     = DSilver;
< 	p_value[15+gold]       = DGold;
< 	p_value[15+bishop]     = DBishop;
< 	p_value[15+rook]       = DRook;
< 	p_value[15+king]       = DKing;
< 	p_value[15+pro_pawn]   = DProPawn;
< 	p_value[15+pro_lance]  = DProLance;
< 	p_value[15+pro_knight] = DProKnight;
< 	p_value[15+pro_silver] = DProSilver;
< 	p_value[15+horse]      = DHorse;
< 	p_value[15+dragon]     = DDragon;
< 
< 	p_value[15-pawn]          = p_value[15+pawn];
< 	p_value[15-lance]         = p_value[15+lance];
< 	p_value[15-knight]        = p_value[15+knight];
< 	p_value[15-silver]        = p_value[15+silver];
< 	p_value[15-gold]          = p_value[15+gold];
< 	p_value[15-bishop]        = p_value[15+bishop];
< 	p_value[15-rook]          = p_value[15+rook];
< 	p_value[15-king]          = p_value[15+king];
< 	p_value[15-pro_pawn]      = p_value[15+pro_pawn];
< 	p_value[15-pro_lance]     = p_value[15+pro_lance];
< 	p_value[15-pro_knight]    = p_value[15+pro_knight];
< 	p_value[15-pro_silver]    = p_value[15+pro_silver];
< 	p_value[15-horse]         = p_value[15+horse];
< 	p_value[15-dragon]        = p_value[15+dragon];
---
> /// evaluate() is the main evaluation function. It always computes two
> /// values, an endgame score and a middle game score, and interpolates
> /// between them based on the remaining material.
> Value evaluate(const Position& pos, Value& margin) {
> 
>   return CpuHasPOPCNT ? do_evaluate<true, false>(pos, margin)
>                       : do_evaluate<false, false>(pos, margin);
233,309c269,272
< int Position::compute_material() const
< {
< 	int v, item, itemp;
< 	int i;
< 
< 	item  = 0;
< 	itemp = 0;
< 	for (i = KNS_FU; i <= KNE_FU; i++) {
< 		if (knkind[i] == SFU) item++;
< 		if (knkind[i] == GFU) item--;
< 		if (knkind[i] == STO) itemp++;
< 		if (knkind[i] == GTO) itemp--;
< 	}
< 	v  = item  * p_value[15+pawn];
< 	v += itemp * p_value[15+pro_pawn];
< 
< 	item  = 0;
< 	itemp = 0;
< 	for (i = KNS_KY; i <= KNE_KY; i++) {
< 		if (knkind[i] == SKY) item++;
< 		if (knkind[i] == GKY) item--;
< 		if (knkind[i] == SNY) itemp++;
< 		if (knkind[i] == GNY) itemp--;
< 	}
< 	v += item  * p_value[15+lance];
< 	v += itemp * p_value[15+pro_lance];
< 
< 	item  = 0;
< 	itemp = 0;
< 	for (i = KNS_KE; i <= KNE_KE; i++) {
< 		if (knkind[i] == SKE) item++;
< 		if (knkind[i] == GKE) item--;
< 		if (knkind[i] == SNK) itemp++;
< 		if (knkind[i] == GNK) itemp--;
< 	}
< 	v += item  * p_value[15+knight];
< 	v += itemp * p_value[15+pro_knight];
< 
< 	item  = 0;
< 	itemp = 0;
< 	for (i = KNS_GI; i <= KNE_GI; i++) {
< 		if (knkind[i] == SGI) item++;
< 		if (knkind[i] == GGI) item--;
< 		if (knkind[i] == SNG) itemp++;
< 		if (knkind[i] == GNG) itemp--;
< 	}
< 	v += item  * p_value[15+silver];
< 	v += itemp * p_value[15+pro_silver];
< 
< 	item  = 0;
< 	for (i = KNS_KI; i <= KNE_KI; i++) {
< 		if (knkind[i] == SKI) item++;
< 		if (knkind[i] == GKI) item--;
< 	}
< 	v += item  * p_value[15+gold];
< 
< 	item  = 0;
< 	itemp = 0;
< 	for (i = KNS_KA; i <= KNE_KA; i++) {
< 		if (knkind[i] == SKA) item++;
< 		if (knkind[i] == GKA) item--;
< 		if (knkind[i] == SUM) itemp++;
< 		if (knkind[i] == GUM) itemp--;
< 	}
< 	v += item  * p_value[15+bishop];
< 	v += itemp * p_value[15+horse];
< 
< 	item  = 0;
< 	itemp = 0;
< 	for (i = KNS_HI; i <= KNE_HI; i++) {
< 		if (knkind[i] == SHI) item++;
< 		if (knkind[i] == GHI) item--;
< 		if (knkind[i] == SRY) itemp++;
< 		if (knkind[i] == GRY) itemp--;
< 	}
< 	v += item  * p_value[15+rook];
< 	v += itemp * p_value[15+dragon];
---
> namespace {
> 
> template<bool HasPopCnt, bool Trace>
> Value do_evaluate(const Position& pos, Value& margin) {
311c274,392
< 	return v;
---
>   EvalInfo ei;
>   Value margins[2];
>   Score score, mobilityWhite, mobilityBlack;
> 
>   assert(pos.is_ok());
>   assert(pos.thread() >= 0 && pos.thread() < MAX_THREADS);
>   assert(!pos.in_check());
> 
>   // Initialize score by reading the incrementally updated scores included
>   // in the position object (material + piece square tables).
>   score = pos.value();
> 
>   // margins[] store the uncertainty estimation of position's evaluation
>   // that typically is used by the search for pruning decisions.
>   margins[WHITE] = margins[BLACK] = VALUE_ZERO;
> 
>   // Probe the material hash table
>   ei.mi = Threads[pos.thread()].materialTable.get_material_info(pos);
>   score += ei.mi->material_value();
> 
>   // If we have a specialized evaluation function for the current material
>   // configuration, call it and return.
>   if (ei.mi->specialized_eval_exists())
>   {
>       margin = VALUE_ZERO;
>       return ei.mi->evaluate(pos);
>   }
> 
>   // Probe the pawn hash table
>   ei.pi = Threads[pos.thread()].pawnTable.get_pawn_info(pos);
>   score += ei.pi->pawns_value();
> 
>   // Initialize attack and king safety bitboards
>   init_eval_info<WHITE, HasPopCnt>(pos, ei);
>   init_eval_info<BLACK, HasPopCnt>(pos, ei);
> 
>   // Evaluate pieces and mobility
>   score +=  evaluate_pieces_of_color<WHITE, HasPopCnt, Trace>(pos, ei, mobilityWhite)
>           - evaluate_pieces_of_color<BLACK, HasPopCnt, Trace>(pos, ei, mobilityBlack);
> 
>   score += apply_weight(mobilityWhite - mobilityBlack, Weights[Mobility]);
> 
>   // Evaluate kings after all other pieces because we need complete attack
>   // information when computing the king safety evaluation.
>   score +=  evaluate_king<WHITE, HasPopCnt, Trace>(pos, ei, margins)
>           - evaluate_king<BLACK, HasPopCnt, Trace>(pos, ei, margins);
> 
>   // Evaluate tactical threats, we need full attack information including king
>   score +=  evaluate_threats<WHITE>(pos, ei)
>           - evaluate_threats<BLACK>(pos, ei);
> 
>   // Evaluate passed pawns, we need full attack information including king
>   score +=  evaluate_passed_pawns<WHITE>(pos, ei)
>           - evaluate_passed_pawns<BLACK>(pos, ei);
> 
>   // If one side has only a king, check whether exists any unstoppable passed pawn
>   if (!pos.non_pawn_material(WHITE) || !pos.non_pawn_material(BLACK))
>       score += evaluate_unstoppable_pawns<HasPopCnt>(pos, ei);
> 
>   // Evaluate space for both sides, only in middle-game.
>   if (ei.mi->space_weight())
>   {
>       int s = evaluate_space<WHITE, HasPopCnt>(pos, ei) - evaluate_space<BLACK, HasPopCnt>(pos, ei);
>       score += apply_weight(make_score(s * ei.mi->space_weight(), 0), Weights[Space]);
>   }
> 
>   // Scale winning side if position is more drawish that what it appears
>   ScaleFactor sf = eg_value(score) > VALUE_DRAW ? ei.mi->scale_factor(pos, WHITE)
>                                                 : ei.mi->scale_factor(pos, BLACK);
> 
>   // If we don't already have an unusual scale factor, check for opposite
>   // colored bishop endgames, and use a lower scale for those.
>   if (   ei.mi->game_phase() < PHASE_MIDGAME
>       && pos.opposite_colored_bishops()
>       && sf == SCALE_FACTOR_NORMAL)
>   {
>       // Only the two bishops ?
>       if (   pos.non_pawn_material(WHITE) == BishopValueMidgame
>           && pos.non_pawn_material(BLACK) == BishopValueMidgame)
>       {
>           // Check for KBP vs KB with only a single pawn that is almost
>           // certainly a draw or at least two pawns.
>           bool one_pawn = (pos.piece_count(WHITE, PAWN) + pos.piece_count(BLACK, PAWN) == 1);
>           sf = one_pawn ? ScaleFactor(8) : ScaleFactor(32);
>       }
>       else
>           // Endgame with opposite-colored bishops, but also other pieces. Still
>           // a bit drawish, but not as drawish as with only the two bishops.
>            sf = ScaleFactor(50);
>   }
> 
>   // Interpolate between the middle game and the endgame score
>   margin = margins[pos.side_to_move()];
>   Value v = scale_by_game_phase(score, ei.mi->game_phase(), sf);
> 
>   // In case of tracing add all single evaluation contributions for both white and black
>   if (Trace)
>   {
>       trace_add(PST, pos.value());
>       trace_add(IMBALANCE, ei.mi->material_value());
>       trace_add(PAWN, ei.pi->pawns_value());
>       trace_add(MOBILITY, apply_weight(mobilityWhite, Weights[Mobility]), apply_weight(mobilityBlack, Weights[Mobility]));
>       trace_add(THREAT, evaluate_threats<WHITE>(pos, ei), evaluate_threats<BLACK>(pos, ei));
>       trace_add(PASSED, evaluate_passed_pawns<WHITE>(pos, ei), evaluate_passed_pawns<BLACK>(pos, ei));
>       trace_add(UNSTOPPABLE, evaluate_unstoppable_pawns<false>(pos, ei));
>       Score w = make_score(ei.mi->space_weight() * evaluate_space<WHITE, false>(pos, ei), 0);
>       Score b = make_score(ei.mi->space_weight() * evaluate_space<BLACK, false>(pos, ei), 0);
>       trace_add(SPACE, apply_weight(w, Weights[Space]), apply_weight(b, Weights[Space]));
>       trace_add(TOTAL, score);
>       TraceStream << "\nUncertainty margin: White: " << to_cp(margins[WHITE])
>                   << ", Black: " << to_cp(margins[BLACK])
>                   << "\nScaling: " << std::noshowpos
>                   << std::setw(6) << 100.0 * ei.mi->game_phase() / 128.0 << "% MG, "
>                   << std::setw(6) << 100.0 * (1.0 - ei.mi->game_phase() / 128.0) << "% * "
>                   << std::setw(6) << (100.0 * sf) / SCALE_FACTOR_NORMAL << "% EG.\n"
>                   << "Total evaluation: " << to_cp(v);
>   }
> 
>   return pos.side_to_move() == WHITE ? v : -v;
314,630c395,405
< #if !defined(EVAL_MICRO)
< int Position::make_list(int * pscore, int list0[NLIST], int list1[NLIST] ) const
< {
< 	int sq, i, score, sq_bk0, sq_bk1;
< 
< 	score  = 0;
< 	sq_bk0 = SQ_BKING;
< 	sq_bk1 = Inv(SQ_WKING);
< 
< 
< 	int sfu_list0[9];
< 	int sfu_list1[9];
< 	int sfu_nlist = 0;
< 	int gfu_list0[9];
< 	int gfu_list1[9];
< 	int gfu_nlist = 0;
< 	int sky_list0[4];
< 	int sky_list1[4];
< 	int sky_nlist = 0;
< 	int gky_list0[4];
< 	int gky_list1[4];
< 	int gky_nlist = 0;
< 	int ske_list0[4];
< 	int ske_list1[4];
< 	int ske_nlist = 0;
< 	int gke_list0[4];
< 	int gke_list1[4];
< 	int gke_nlist = 0;
< 	int sgi_list0[4];
< 	int sgi_list1[4];
< 	int sgi_nlist = 0;
< 	int ggi_list0[4];
< 	int ggi_list1[4];
< 	int ggi_nlist = 0;
< 	// 金の動きをする駒の数なので最大金＋銀＋桂＋香＋歩の枚数
< 	int ski_list0[34];
< 	int ski_list1[34];
< 	int ski_nlist = 0;
< 	int gki_list0[34];	
< 	int gki_list1[34];
< 	int gki_nlist = 0;
< 	int ska_list0[2];
< 	int ska_list1[2];
< 	int ska_nlist = 0;
< 	int gka_list0[2];
< 	int gka_list1[2];
< 	int gka_nlist = 0;
< 	int shi_list0[2];
< 	int shi_list1[2];
< 	int shi_nlist = 0;
< 	int ghi_list0[2];
< 	int ghi_list1[2];
< 	int ghi_nlist = 0;
< 	int sum_list0[2];
< 	int sum_list1[2];
< 	int sum_nlist = 0;
< 	int gum_list0[2];
< 	int gum_list1[2];
< 	int gum_nlist = 0;
< 	int sry_list0[2];
< 	int sry_list1[2];
< 	int sry_nlist = 0;
< 	int gry_list0[2];
< 	int gry_list1[2];
< 	int gry_nlist = 0;
< 	int x, y;
< 	for (y = RANK_1; y <= RANK_9; y++) {
< 		for (x = FILE_1; x <= FILE_9; x++) {
< 			const int z = (x << 4)+y;
< 			sq = NanohaTbl::z2sq[z];
< 			switch (ban[z]) {
< 			case SFU:
< 				sfu_list0[sfu_nlist] = pp_bpawn + sq;
< 				sfu_list1[sfu_nlist] = pp_wpawn + Inv(sq);
< 				score += PcOnSq(sq_bk0, kp_bpawn + sq);
< 				score -= PcOnSq(sq_bk1, kp_wpawn + Inv(sq));
< 				assert(sfu_list0[sfu_nlist] >= kp_hand_end);
< 				assert(sfu_list1[sfu_nlist] >= kp_hand_end);
< 				sfu_nlist += 1;
< 				break;
< 			case GFU:
< 				gfu_list0[gfu_nlist] = pp_wpawn + sq;
< 				gfu_list1[gfu_nlist] = pp_bpawn + Inv(sq);
< 				score += PcOnSq(sq_bk0, kp_wpawn + sq);
< 				score -= PcOnSq(sq_bk1, kp_bpawn + Inv(sq));
< 				assert(gfu_list0[gfu_nlist] >= kp_hand_end);
< 				assert(gfu_list1[gfu_nlist] >= kp_hand_end);
< 				gfu_nlist += 1;
< 				break;
< 			case SKY:
< 				sky_list0[sky_nlist] = pp_blance + sq;
< 				sky_list1[sky_nlist] = pp_wlance + Inv(sq);
< 				score += PcOnSq(sq_bk0, kp_blance + sq);
< 				score -= PcOnSq(sq_bk1, kp_wlance + Inv(sq));
< 				sky_nlist += 1;
< 				break;
< 			case GKY:
< 				gky_list0[gky_nlist] = pp_wlance + sq;
< 				gky_list1[gky_nlist] = pp_blance + Inv(sq);
< 				score += PcOnSq(sq_bk0, kp_wlance + sq);
< 				score -= PcOnSq(sq_bk1, kp_blance + Inv(sq));
< 				gky_nlist += 1;
< 				break;
< 			case SKE:
< 				ske_list0[ske_nlist] = pp_bknight + sq;
< 				ske_list1[ske_nlist] = pp_wknight + Inv(sq);
< 				score += PcOnSq(sq_bk0, kp_bknight + sq);
< 				score -= PcOnSq(sq_bk1, kp_wknight + Inv(sq));
< 				ske_nlist += 1;
< 				break;
< 			case GKE:
< 				gke_list0[gke_nlist] = pp_wknight + sq;
< 				gke_list1[gke_nlist] = pp_bknight + Inv(sq);
< 				score += PcOnSq(sq_bk0, kp_wknight + sq);
< 				score -= PcOnSq(sq_bk1, kp_bknight + Inv(sq));
< 				gke_nlist += 1;
< 				break;
< 			case SGI:
< 				sgi_list0[sgi_nlist] = pp_bsilver + sq;
< 				sgi_list1[sgi_nlist] = pp_wsilver + Inv(sq);
< 				score += PcOnSq(sq_bk0, kp_bsilver + sq);
< 				score -= PcOnSq(sq_bk1, kp_wsilver + Inv(sq));
< 				sgi_nlist += 1;
< 				break;
< 			case GGI:
< 				ggi_list0[ggi_nlist] = pp_wsilver + sq;
< 				ggi_list1[ggi_nlist] = pp_bsilver + Inv(sq);
< 				score += PcOnSq(sq_bk0, kp_wknight + sq);
< 				score -= PcOnSq(sq_bk1, kp_bknight + Inv(sq));
< 				ggi_nlist += 1;
< 				break;
< 			case SKI:
< 			case STO:
< 			case SNY:
< 			case SNK:
< 			case SNG:
< 				ski_list0[ski_nlist] = pp_bgold + sq;
< 				ski_list1[ski_nlist] = pp_wgold + Inv(sq);
< 				score += PcOnSq(sq_bk0, kp_bgold + sq);
< 				score -= PcOnSq(sq_bk1, kp_wgold + Inv(sq));
< 				ski_nlist += 1;
< 				break;
< 			case GKI:
< 			case GTO:
< 			case GNY:
< 			case GNK:
< 			case GNG:
< 				gki_list0[gki_nlist] = pp_wgold + sq;
< 				gki_list1[gki_nlist] = pp_bgold + Inv(sq);
< 				score += PcOnSq(sq_bk0, kp_wgold + sq);
< 				score -= PcOnSq(sq_bk1, kp_bgold + Inv(sq));
< 				gki_nlist += 1;
< 				break;
< 			case SKA:
< 				ska_list0[ska_nlist] = pp_bbishop + sq;
< 				ska_list1[ska_nlist] = pp_wbishop + Inv(sq);
< 				score += PcOnSq(sq_bk0, kp_bbishop + sq);
< 				score -= PcOnSq(sq_bk1, kp_wbishop + Inv(sq));
< 				ska_nlist += 1;
< 				break;
< 			case GKA:
< 				gka_list0[gka_nlist] = pp_wbishop + sq;
< 				gka_list1[gka_nlist] = pp_bbishop + Inv(sq);
< 				score += PcOnSq(sq_bk0, kp_wbishop + sq);
< 				score -= PcOnSq(sq_bk1, kp_bbishop + Inv(sq));
< 				gka_nlist += 1;
< 				break;
< 			case SHI:
< 				shi_list0[shi_nlist] = pp_brook + sq;
< 				shi_list1[shi_nlist] = pp_wrook + Inv(sq);
< 				score += PcOnSq(sq_bk0, kp_brook + sq);
< 				score -= PcOnSq(sq_bk1, kp_wrook + Inv(sq));
< 				shi_nlist += 1;
< 				break;
< 			case GHI:
< 				ghi_list0[ghi_nlist] = pp_wrook + sq;
< 				ghi_list1[ghi_nlist] = pp_brook + Inv(sq);
< 				score += PcOnSq(sq_bk0, kp_wrook + sq);
< 				score -= PcOnSq(sq_bk1, kp_brook + Inv(sq));
< 				ghi_nlist += 1;
< 				break;
< 			case SUM:
< 				sum_list0[sum_nlist] = pp_bhorse + sq;
< 				sum_list1[sum_nlist] = pp_whorse + Inv(sq);
< 				score += PcOnSq(sq_bk0, kp_bhorse + sq);
< 				score -= PcOnSq(sq_bk1, kp_whorse + Inv(sq));
< 				sum_nlist += 1;
< 				break;
< 			case GUM:
< 				gum_list0[gum_nlist] = pp_whorse + sq;
< 				gum_list1[gum_nlist] = pp_bhorse + Inv(sq);
< 				score += PcOnSq(sq_bk0, kp_wbishop + sq);
< 				score -= PcOnSq(sq_bk1, kp_bbishop + Inv(sq));
< 				gum_nlist += 1;
< 				break;
< 			case SRY:
< 				sry_list0[sry_nlist] = pp_bdragon + sq;
< 				sry_list1[sry_nlist] = pp_wdragon + Inv(sq);
< 				score += PcOnSq(sq_bk0, kp_bdragon + sq);
< 				score -= PcOnSq(sq_bk1, kp_wdragon + Inv(sq));
< 				sry_nlist += 1;
< 				break;
< 			case GRY:
< 				gry_list0[gry_nlist] = pp_wdragon + sq;
< 				gry_list1[gry_nlist] = pp_bdragon + Inv(sq);
< 				score += PcOnSq(sq_bk0, kp_wbishop + sq);
< 				score -= PcOnSq(sq_bk1, kp_bbishop + Inv(sq));
< 				gry_nlist += 1;
< 				break;
< 			case EMP:
< 			case WALL:
< 			case SOU:
< 			case GOU:
< 			case PIECE_NONE:
< 			default:
< 				;
< 			}
< 		}
< 	}
< #if defined(CHK_DETAIL)
< 	if (sfu_nlist > 9 || gfu_nlist > 9) {
< 		Print();
< 		MYABORT();
< 	}
< #endif	//#if defined(CHK_DETAIL)
< 	int nlist  = 0;
< 	// SFU
< 	for (i = 0; i < sfu_nlist; i++, nlist++) {
< 		list0[nlist] = sfu_list0[i];
< 		list1[nlist] = sfu_list1[i];
< 	}
< 	// SKY
< 	for (i = 0; i < sky_nlist; i++, nlist++) {
< 		list0[nlist] = sky_list0[i];
< 		list1[nlist] = sky_list1[i];
< 	}
< 	// SKE
< 	for (i = 0; i < ske_nlist; i++, nlist++) {
< 		list0[nlist] = ske_list0[i];
< 		list1[nlist] = ske_list1[i];
< 	}
< 	// SGI
< 	for (i = 0; i < sgi_nlist; i++, nlist++) {
< 		list0[nlist] = sgi_list0[i];
< 		list1[nlist] = sgi_list1[i];
< 	}
< 	// SKI
< 	for (i = 0; i < ski_nlist; i++, nlist++) {
< 		list0[nlist] = ski_list0[i];
< 		list1[nlist] = ski_list1[i];
< 	}
< 	// SKA
< 	for (i = 0; i < ska_nlist; i++, nlist++) {
< 		list0[nlist] = ska_list0[i];
< 		list1[nlist] = ska_list1[i];
< 	}
< 	// SUM
< 	for (i = 0; i < sum_nlist; i++, nlist++) {
< 		list0[nlist] = sum_list0[i];
< 		list1[nlist] = sum_list1[i];
< 	}
< 	// SHI
< 	for (i = 0; i < shi_nlist; i++, nlist++) {
< 		list0[nlist] = shi_list0[i];
< 		list1[nlist] = shi_list1[i];
< 	}
< 	// SRY
< 	for (i = 0; i < sry_nlist; i++, nlist++) {
< 		list0[nlist] = sry_list0[i];
< 		list1[nlist] = sry_list1[i];
< 	}
< 
< 	// GFU
< 	for (i = 0; i < gfu_nlist; i++, nlist++) {
< 		list0[nlist] = gfu_list0[i];
< 		list1[nlist] = gfu_list1[i];
< 	}
< 	// GKY
< 	for (i = 0; i < gky_nlist; i++, nlist++) {
< 		list0[nlist] = gky_list0[i];
< 		list1[nlist] = gky_list1[i];
< 	}
< 	// GKE
< 	for (i = 0; i < gke_nlist; i++, nlist++) {
< 		list0[nlist] = gke_list0[i];
< 		list1[nlist] = gke_list1[i];
< 	}
< 	// GGI
< 	for (i = 0; i < ggi_nlist; i++, nlist++) {
< 		list0[nlist] = ggi_list0[i];
< 		list1[nlist] = ggi_list1[i];
< 	}
< 	// GKI
< 	for (i = 0; i < gki_nlist; i++, nlist++) {
< 		list0[nlist] = gki_list0[i];
< 		list1[nlist] = gki_list1[i];
< 	}
< 	// GKA
< 	for (i = 0; i < gka_nlist; i++, nlist++) {
< 		list0[nlist] = gka_list0[i];
< 		list1[nlist] = gka_list1[i];
< 	}
< 	// GUM
< 	for (i = 0; i < gum_nlist; i++, nlist++) {
< 		list0[nlist] = gum_list0[i];
< 		list1[nlist] = gum_list1[i];
< 	}
< 	// GHI
< 	for (i = 0; i < ghi_nlist; i++, nlist++) {
< 		list0[nlist] = ghi_list0[i];
< 		list1[nlist] = ghi_list1[i];
< 	}
< 	// GRY
< 	for (i = 0; i < gry_nlist; i++, nlist++) {
< 		list0[nlist] = gry_list0[i];
< 		list1[nlist] = gry_list1[i];
< 	}
---
> } // namespace
> 
> 
> /// read_weights() reads evaluation weights from the corresponding UCI parameters
> 
> void read_evaluation_uci_options(Color us) {
> 
>   // King safety is asymmetrical. Our king danger level is weighted by
>   // "Cowardice" UCI parameter, instead the opponent one by "Aggressiveness".
>   const int kingDangerUs   = (us == WHITE ? KingDangerUs   : KingDangerThem);
>   const int kingDangerThem = (us == WHITE ? KingDangerThem : KingDangerUs);
632c407,411
< 	assert( nlist <= NLIST );
---
>   Weights[Mobility]       = weight_option("Mobility (Middle Game)", "Mobility (Endgame)", WeightsInternal[Mobility]);
>   Weights[PassedPawns]    = weight_option("Passed Pawns (Middle Game)", "Passed Pawns (Endgame)", WeightsInternal[PassedPawns]);
>   Weights[Space]          = weight_option("Space", "Space", WeightsInternal[Space]);
>   Weights[kingDangerUs]   = weight_option("Cowardice", "Cowardice", WeightsInternal[KingDangerUs]);
>   Weights[kingDangerThem] = weight_option("Aggressiveness", "Aggressiveness", WeightsInternal[KingDangerThem]);
634,635c413,418
< 	*pscore += score;
< 	return nlist;
---
>   // If running in analysis mode, make sure we use symmetrical king safety. We do this
>   // by replacing both Weights[kingDangerUs] and Weights[kingDangerThem] by their average.
>   if (Options["UCI_AnalyseMode"].value<bool>())
>       Weights[kingDangerUs] = Weights[kingDangerThem] = (Weights[kingDangerUs] + Weights[kingDangerThem]) / 2;
> 
>   init_safety();
637d419
< #endif
639,722c421,1176
< int Position::evaluate(const Color us) const
< {
< #if !defined(EVAL_MICRO)
< 	int list0[NLIST], list1[NLIST];
< 	int nlist, score, sq_bk, sq_wk, k0, k1, l0, l1, i, j, sum;
< 	static int count=0;
< 	count++;
< 
< 	sum = 0;
< 	sq_bk = SQ_BKING;
< 	sq_wk = Inv( SQ_WKING );
< 
< 	sum += fv_kp[sq_bk][kp_hand_bpawn   + I2HandPawn(HAND_B)];
< 	sum += fv_kp[sq_bk][kp_hand_wpawn   + I2HandPawn(HAND_W)];
< 	sum -= fv_kp[sq_wk][kp_hand_bpawn   + I2HandPawn(HAND_W)];
< 	sum -= fv_kp[sq_wk][kp_hand_wpawn   + I2HandPawn(HAND_B)];
< 
< 	sum += fv_kp[sq_bk][kp_hand_blance  + I2HandLance(HAND_B)];
< 	sum += fv_kp[sq_bk][kp_hand_wlance  + I2HandLance(HAND_W)];
< 	sum -= fv_kp[sq_wk][kp_hand_blance  + I2HandLance(HAND_W)];
< 	sum -= fv_kp[sq_wk][kp_hand_wlance  + I2HandLance(HAND_B)];
< 
< 	sum += fv_kp[sq_bk][kp_hand_bknight + I2HandKnight(HAND_B)];
< 	sum += fv_kp[sq_bk][kp_hand_wknight + I2HandKnight(HAND_W)];
< 	sum -= fv_kp[sq_wk][kp_hand_bknight + I2HandKnight(HAND_W)];
< 	sum -= fv_kp[sq_wk][kp_hand_wknight + I2HandKnight(HAND_B)];
< 
< 	sum += fv_kp[sq_bk][kp_hand_bsilver + I2HandSilver(HAND_B)];
< 	sum += fv_kp[sq_bk][kp_hand_wsilver + I2HandSilver(HAND_W)];
< 	sum -= fv_kp[sq_wk][kp_hand_bsilver + I2HandSilver(HAND_W)];
< 	sum -= fv_kp[sq_wk][kp_hand_wsilver + I2HandSilver(HAND_B)];
< 
< 	sum += fv_kp[sq_bk][kp_hand_bgold   + I2HandGold(HAND_B)];
< 	sum += fv_kp[sq_bk][kp_hand_wgold   + I2HandGold(HAND_W)];
< 	sum -= fv_kp[sq_wk][kp_hand_bgold   + I2HandGold(HAND_W)];
< 	sum -= fv_kp[sq_wk][kp_hand_wgold   + I2HandGold(HAND_B)];
< 
< 	sum += fv_kp[sq_bk][kp_hand_bbishop + I2HandBishop(HAND_B)];
< 	sum += fv_kp[sq_bk][kp_hand_wbishop + I2HandBishop(HAND_W)];
< 	sum -= fv_kp[sq_wk][kp_hand_bbishop + I2HandBishop(HAND_W)];
< 	sum -= fv_kp[sq_wk][kp_hand_wbishop + I2HandBishop(HAND_B)];
< 
< 	sum += fv_kp[sq_bk][kp_hand_brook   + I2HandRook(HAND_B)];
< 	sum += fv_kp[sq_bk][kp_hand_wrook   + I2HandRook(HAND_W)];
< 	sum -= fv_kp[sq_wk][kp_hand_brook   + I2HandRook(HAND_W)];
< 	sum -= fv_kp[sq_wk][kp_hand_wrook   + I2HandRook(HAND_B)];
< 
< 
< 	score = 0;
< 	nlist = make_list( &score, list0, list1 );
< 
< 	for ( i = 0; list0[i] < pp_bend; i++ )
< 	{
< 		assert(i < nlist);
< 		k0 = list0[i];
< 		for ( j = i+1; j < nlist; j++ )
< 		{
< 			l0 = list0[j];
< 			sum += PcPcOn( k0, l0 );
< 		}
< 	}
< 
< 	for ( ; i < nlist; i++ )
< 	{
< 		k1 = list1[i];
< 		assert(k1 < pp_bend);
< 		for ( j = i+1; j < nlist; j++ )
< 		{
< 			l1 = list1[j];
< 			sum -= PcPcOn( k1, l1 );
< 		}
< 	}
< 
< 	score += sum;
< 	score /= FV_SCALE;
< 
< 	score += MATERIAL;
< 
< 	score = (us == BLACK) ? score : -score;
< 
< 	return score;
< #else
< 	return (us == BLACK) ? MATERIAL : -(MATERIAL);
< #endif
---
> 
> namespace {
> 
>   // init_eval_info() initializes king bitboards for given color adding
>   // pawn attacks. To be done at the beginning of the evaluation.
> 
>   template<Color Us, bool HasPopCnt>
>   void init_eval_info(const Position& pos, EvalInfo& ei) {
> 
>     const BitCountType Max15 = HasPopCnt ? CNT_POPCNT : CpuIs64Bit ? CNT64_MAX15 : CNT32_MAX15;
>     const Color Them = (Us == WHITE ? BLACK : WHITE);
> 
>     Bitboard b = ei.attackedBy[Them][KING] = pos.attacks_from<KING>(pos.king_square(Them));
>     ei.attackedBy[Us][PAWN] = ei.pi->pawn_attacks(Us);
> 
>     // Init king safety tables only if we are going to use them
>     if (   pos.piece_count(Us, QUEEN)
>         && pos.non_pawn_material(Us) >= QueenValueMidgame + RookValueMidgame)
>     {
>         ei.kingZone[Us] = (b | (Us == WHITE ? b >> 8 : b << 8));
>         b &= ei.attackedBy[Us][PAWN];
>         ei.kingAttackersCount[Us] = b ? count_1s<Max15>(b) / 2 : 0;
>         ei.kingAdjacentZoneAttacksCount[Us] = ei.kingAttackersWeight[Us] = 0;
>     } else
>         ei.kingZone[Us] = ei.kingAttackersCount[Us] = 0;
>   }
> 
> 
>   // evaluate_outposts() evaluates bishop and knight outposts squares
> 
>   template<PieceType Piece, Color Us>
>   Score evaluate_outposts(const Position& pos, EvalInfo& ei, Square s) {
> 
>     const Color Them = (Us == WHITE ? BLACK : WHITE);
> 
>     assert (Piece == BISHOP || Piece == KNIGHT);
> 
>     // Initial bonus based on square
>     Value bonus = OutpostBonus[Piece == BISHOP][relative_square(Us, s)];
> 
>     // Increase bonus if supported by pawn, especially if the opponent has
>     // no minor piece which can exchange the outpost piece.
>     if (bonus && bit_is_set(ei.attackedBy[Us][PAWN], s))
>     {
>         if (    pos.pieces(KNIGHT, Them) == EmptyBoardBB
>             && (SquaresByColorBB[square_color(s)] & pos.pieces(BISHOP, Them)) == EmptyBoardBB)
>             bonus += bonus + bonus / 2;
>         else
>             bonus += bonus / 2;
>     }
>     return make_score(bonus, bonus);
>   }
> 
> 
>   // evaluate_pieces<>() assigns bonuses and penalties to the pieces of a given color
> 
>   template<PieceType Piece, Color Us, bool HasPopCnt, bool Trace>
>   Score evaluate_pieces(const Position& pos, EvalInfo& ei, Score& mobility, Bitboard mobilityArea) {
> 
>     Bitboard b;
>     Square s, ksq;
>     int mob;
>     File f;
>     Score score = SCORE_ZERO;
> 
>     const BitCountType Full  = HasPopCnt ? CNT_POPCNT : CpuIs64Bit ? CNT64 : CNT32;
>     const BitCountType Max15 = HasPopCnt ? CNT_POPCNT : CpuIs64Bit ? CNT64_MAX15 : CNT32_MAX15;
>     const Color Them = (Us == WHITE ? BLACK : WHITE);
>     const Square* ptr = pos.piece_list_begin(Us, Piece);
> 
>     ei.attackedBy[Us][Piece] = EmptyBoardBB;
> 
>     while ((s = *ptr++) != SQ_NONE)
>     {
>         // Find attacked squares, including x-ray attacks for bishops and rooks
>         if (Piece == KNIGHT || Piece == QUEEN)
>             b = pos.attacks_from<Piece>(s);
>         else if (Piece == BISHOP)
>             b = bishop_attacks_bb(s, pos.occupied_squares() & ~pos.pieces(QUEEN, Us));
>         else if (Piece == ROOK)
>             b = rook_attacks_bb(s, pos.occupied_squares() & ~pos.pieces(ROOK, QUEEN, Us));
>         else
>             assert(false);
> 
>         // Update attack info
>         ei.attackedBy[Us][Piece] |= b;
> 
>         // King attacks
>         if (b & ei.kingZone[Us])
>         {
>             ei.kingAttackersCount[Us]++;
>             ei.kingAttackersWeight[Us] += KingAttackWeights[Piece];
>             Bitboard bb = (b & ei.attackedBy[Them][KING]);
>             if (bb)
>                 ei.kingAdjacentZoneAttacksCount[Us] += count_1s<Max15>(bb);
>         }
> 
>         // Mobility
>         mob = (Piece != QUEEN ? count_1s<Max15>(b & mobilityArea)
>                               : count_1s<Full >(b & mobilityArea));
> 
>         mobility += MobilityBonus[Piece][mob];
> 
>         // Decrease score if we are attacked by an enemy pawn. Remaining part
>         // of threat evaluation must be done later when we have full attack info.
>         if (bit_is_set(ei.attackedBy[Them][PAWN], s))
>             score -= ThreatenedByPawnPenalty[Piece];
> 
>         // Bishop and knight outposts squares
>         if ((Piece == BISHOP || Piece == KNIGHT) && pos.square_is_weak(s, Us))
>             score += evaluate_outposts<Piece, Us>(pos, ei, s);
> 
>         // Queen or rook on 7th rank
>         if (  (Piece == ROOK || Piece == QUEEN)
>             && relative_rank(Us, s) == RANK_7
>             && relative_rank(Us, pos.king_square(Them)) == RANK_8)
>         {
>             score += (Piece == ROOK ? RookOn7thBonus : QueenOn7thBonus);
>         }
> 
>         // Special extra evaluation for bishops
>         if (Piece == BISHOP && pos.is_chess960())
>         {
>             // An important Chess960 pattern: A cornered bishop blocked by
>             // a friendly pawn diagonally in front of it is a very serious
>             // problem, especially when that pawn is also blocked.
>             if (s == relative_square(Us, SQ_A1) || s == relative_square(Us, SQ_H1))
>             {
>                 Square d = pawn_push(Us) + (square_file(s) == FILE_A ? DELTA_E : DELTA_W);
>                 if (pos.piece_on(s + d) == make_piece(Us, PAWN))
>                 {
>                     if (!pos.square_is_empty(s + d + pawn_push(Us)))
>                         score -= 2*TrappedBishopA1H1Penalty;
>                     else if (pos.piece_on(s + 2*d) == make_piece(Us, PAWN))
>                         score -= TrappedBishopA1H1Penalty;
>                     else
>                         score -= TrappedBishopA1H1Penalty / 2;
>                 }
>             }
>         }
> 
>         // Special extra evaluation for rooks
>         if (Piece == ROOK)
>         {
>             // Open and half-open files
>             f = square_file(s);
>             if (ei.pi->file_is_half_open(Us, f))
>             {
>                 if (ei.pi->file_is_half_open(Them, f))
>                     score += RookOpenFileBonus;
>                 else
>                     score += RookHalfOpenFileBonus;
>             }
> 
>             // Penalize rooks which are trapped inside a king. Penalize more if
>             // king has lost right to castle.
>             if (mob > 6 || ei.pi->file_is_half_open(Us, f))
>                 continue;
> 
>             ksq = pos.king_square(Us);
> 
>             if (    square_file(ksq) >= FILE_E
>                 &&  square_file(s) > square_file(ksq)
>                 && (relative_rank(Us, ksq) == RANK_1 || square_rank(ksq) == square_rank(s)))
>             {
>                 // Is there a half-open file between the king and the edge of the board?
>                 if (!ei.pi->has_open_file_to_right(Us, square_file(ksq)))
>                     score -= make_score(pos.can_castle(Us) ? (TrappedRookPenalty - mob * 16) / 2
>                                                            : (TrappedRookPenalty - mob * 16), 0);
>             }
>             else if (    square_file(ksq) <= FILE_D
>                      &&  square_file(s) < square_file(ksq)
>                      && (relative_rank(Us, ksq) == RANK_1 || square_rank(ksq) == square_rank(s)))
>             {
>                 // Is there a half-open file between the king and the edge of the board?
>                 if (!ei.pi->has_open_file_to_left(Us, square_file(ksq)))
>                     score -= make_score(pos.can_castle(Us) ? (TrappedRookPenalty - mob * 16) / 2
>                                                            : (TrappedRookPenalty - mob * 16), 0);
>             }
>         }
>     }
> 
>     if (Trace)
>         TracedScores[Us][Piece] = score;
> 
>     return score;
>   }
> 
> 
>   // evaluate_threats<>() assigns bonuses according to the type of attacking piece
>   // and the type of attacked one.
> 
>   template<Color Us>
>   Score evaluate_threats(const Position& pos, EvalInfo& ei) {
> 
>     const Color Them = (Us == WHITE ? BLACK : WHITE);
> 
>     Bitboard b;
>     Score score = SCORE_ZERO;
> 
>     // Enemy pieces not defended by a pawn and under our attack
>     Bitboard weakEnemies =  pos.pieces_of_color(Them)
>                           & ~ei.attackedBy[Them][PAWN]
>                           & ei.attackedBy[Us][0];
>     if (!weakEnemies)
>         return SCORE_ZERO;
> 
>     // Add bonus according to type of attacked enemy piece and to the
>     // type of attacking piece, from knights to queens. Kings are not
>     // considered because are already handled in king evaluation.
>     for (PieceType pt1 = KNIGHT; pt1 < KING; pt1++)
>     {
>         b = ei.attackedBy[Us][pt1] & weakEnemies;
>         if (b)
>             for (PieceType pt2 = PAWN; pt2 < KING; pt2++)
>                 if (b & pos.pieces(pt2))
>                     score += ThreatBonus[pt1][pt2];
>     }
>     return score;
>   }
> 
> 
>   // evaluate_pieces_of_color<>() assigns bonuses and penalties to all the
>   // pieces of a given color.
> 
>   template<Color Us, bool HasPopCnt, bool Trace>
>   Score evaluate_pieces_of_color(const Position& pos, EvalInfo& ei, Score& mobility) {
> 
>     const Color Them = (Us == WHITE ? BLACK : WHITE);
> 
>     Score score = mobility = SCORE_ZERO;
> 
>     // Do not include in mobility squares protected by enemy pawns or occupied by our pieces
>     const Bitboard mobilityArea = ~(ei.attackedBy[Them][PAWN] | pos.pieces_of_color(Us));
> 
>     score += evaluate_pieces<KNIGHT, Us, HasPopCnt, Trace>(pos, ei, mobility, mobilityArea);
>     score += evaluate_pieces<BISHOP, Us, HasPopCnt, Trace>(pos, ei, mobility, mobilityArea);
>     score += evaluate_pieces<ROOK,   Us, HasPopCnt, Trace>(pos, ei, mobility, mobilityArea);
>     score += evaluate_pieces<QUEEN,  Us, HasPopCnt, Trace>(pos, ei, mobility, mobilityArea);
> 
>     // Sum up all attacked squares
>     ei.attackedBy[Us][0] =   ei.attackedBy[Us][PAWN]   | ei.attackedBy[Us][KNIGHT]
>                            | ei.attackedBy[Us][BISHOP] | ei.attackedBy[Us][ROOK]
>                            | ei.attackedBy[Us][QUEEN]  | ei.attackedBy[Us][KING];
>     return score;
>   }
> 
> 
>   // evaluate_king<>() assigns bonuses and penalties to a king of a given color
> 
>   template<Color Us, bool HasPopCnt, bool Trace>
>   Score evaluate_king(const Position& pos, EvalInfo& ei, Value margins[]) {
> 
>     const BitCountType Max15 = HasPopCnt ? CNT_POPCNT : CpuIs64Bit ? CNT64_MAX15 : CNT32_MAX15;
>     const Color Them = (Us == WHITE ? BLACK : WHITE);
> 
>     Bitboard undefended, b, b1, b2, safe;
>     int attackUnits;
>     const Square ksq = pos.king_square(Us);
> 
>     // King shelter
>     Score score = ei.pi->king_shelter<Us>(pos, ksq);
> 
>     // King safety. This is quite complicated, and is almost certainly far
>     // from optimally tuned.
>     if (   ei.kingAttackersCount[Them] >= 2
>         && ei.kingAdjacentZoneAttacksCount[Them])
>     {
>         // Find the attacked squares around the king which has no defenders
>         // apart from the king itself
>         undefended = ei.attackedBy[Them][0] & ei.attackedBy[Us][KING];
>         undefended &= ~(  ei.attackedBy[Us][PAWN]   | ei.attackedBy[Us][KNIGHT]
>                         | ei.attackedBy[Us][BISHOP] | ei.attackedBy[Us][ROOK]
>                         | ei.attackedBy[Us][QUEEN]);
> 
>         // Initialize the 'attackUnits' variable, which is used later on as an
>         // index to the KingDangerTable[] array. The initial value is based on
>         // the number and types of the enemy's attacking pieces, the number of
>         // attacked and undefended squares around our king, the square of the
>         // king, and the quality of the pawn shelter.
>         attackUnits =  Min(25, (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)
>                      + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + count_1s<Max15>(undefended))
>                      + InitKingDanger[relative_square(Us, ksq)]
>                      - mg_value(ei.pi->king_shelter<Us>(pos, ksq)) / 32;
> 
>         // Analyse enemy's safe queen contact checks. First find undefended
>         // squares around the king attacked by enemy queen...
>         b = undefended & ei.attackedBy[Them][QUEEN] & ~pos.pieces_of_color(Them);
>         if (b)
>         {
>             // ...then remove squares not supported by another enemy piece
>             b &= (  ei.attackedBy[Them][PAWN]   | ei.attackedBy[Them][KNIGHT]
>                   | ei.attackedBy[Them][BISHOP] | ei.attackedBy[Them][ROOK]);
>             if (b)
>                 attackUnits +=  QueenContactCheckBonus
>                               * count_1s<Max15>(b)
>                               * (Them == pos.side_to_move() ? 2 : 1);
>         }
> 
>         // Analyse enemy's safe rook contact checks. First find undefended
>         // squares around the king attacked by enemy rooks...
>         b = undefended & ei.attackedBy[Them][ROOK] & ~pos.pieces_of_color(Them);
> 
>         // Consider only squares where the enemy rook gives check
>         b &= RookPseudoAttacks[ksq];
> 
>         if (b)
>         {
>             // ...then remove squares not supported by another enemy piece
>             b &= (  ei.attackedBy[Them][PAWN]   | ei.attackedBy[Them][KNIGHT]
>                   | ei.attackedBy[Them][BISHOP] | ei.attackedBy[Them][QUEEN]);
>             if (b)
>                 attackUnits +=  RookContactCheckBonus
>                               * count_1s<Max15>(b)
>                               * (Them == pos.side_to_move() ? 2 : 1);
>         }
> 
>         // Analyse enemy's safe distance checks for sliders and knights
>         safe = ~(pos.pieces_of_color(Them) | ei.attackedBy[Us][0]);
> 
>         b1 = pos.attacks_from<ROOK>(ksq) & safe;
>         b2 = pos.attacks_from<BISHOP>(ksq) & safe;
> 
>         // Enemy queen safe checks
>         b = (b1 | b2) & ei.attackedBy[Them][QUEEN];
>         if (b)
>             attackUnits += QueenCheckBonus * count_1s<Max15>(b);
> 
>         // Enemy rooks safe checks
>         b = b1 & ei.attackedBy[Them][ROOK];
>         if (b)
>             attackUnits += RookCheckBonus * count_1s<Max15>(b);
> 
>         // Enemy bishops safe checks
>         b = b2 & ei.attackedBy[Them][BISHOP];
>         if (b)
>             attackUnits += BishopCheckBonus * count_1s<Max15>(b);
> 
>         // Enemy knights safe checks
>         b = pos.attacks_from<KNIGHT>(ksq) & ei.attackedBy[Them][KNIGHT] & safe;
>         if (b)
>             attackUnits += KnightCheckBonus * count_1s<Max15>(b);
> 
>         // To index KingDangerTable[] attackUnits must be in [0, 99] range
>         attackUnits = Min(99, Max(0, attackUnits));
> 
>         // Finally, extract the king danger score from the KingDangerTable[]
>         // array and subtract the score from evaluation. Set also margins[]
>         // value that will be used for pruning because this value can sometimes
>         // be very big, and so capturing a single attacking piece can therefore
>         // result in a score change far bigger than the value of the captured piece.
>         score -= KingDangerTable[Us][attackUnits];
>         margins[Us] += mg_value(KingDangerTable[Us][attackUnits]);
>     }
> 
>     if (Trace)
>         TracedScores[Us][KING] = score;
> 
>     return score;
>   }
> 
> 
>   // evaluate_passed_pawns<>() evaluates the passed pawns of the given color
> 
>   template<Color Us>
>   Score evaluate_passed_pawns(const Position& pos, EvalInfo& ei) {
> 
>     const Color Them = (Us == WHITE ? BLACK : WHITE);
> 
>     Bitboard b, squaresToQueen, defendedSquares, unsafeSquares, supportingPawns;
>     Score score = SCORE_ZERO;
> 
>     b = ei.pi->passed_pawns(Us);
> 
>     if (!b)
>         return SCORE_ZERO;
> 
>     do {
>         Square s = pop_1st_bit(&b);
> 
>         assert(pos.pawn_is_passed(Us, s));
> 
>         int r = int(relative_rank(Us, s) - RANK_2);
>         int rr = r * (r - 1);
> 
>         // Base bonus based on rank
>         Value mbonus = Value(20 * rr);
>         Value ebonus = Value(10 * (rr + r + 1));
> 
>         if (rr)
>         {
>             Square blockSq = s + pawn_push(Us);
> 
>             // Adjust bonus based on kings proximity
>             ebonus += Value(square_distance(pos.king_square(Them), blockSq) * 6 * rr);
>             ebonus -= Value(square_distance(pos.king_square(Us), blockSq) * 3 * rr);
> 
>             // If blockSq is not the queening square then consider also a second push
>             if (square_rank(blockSq) != (Us == WHITE ? RANK_8 : RANK_1))
>                 ebonus -= Value(square_distance(pos.king_square(Us), blockSq + pawn_push(Us)) * rr);
> 
>             // If the pawn is free to advance, increase bonus
>             if (pos.square_is_empty(blockSq))
>             {
>                 squaresToQueen = squares_in_front_of(Us, s);
>                 defendedSquares = squaresToQueen & ei.attackedBy[Us][0];
> 
>                 // If there is an enemy rook or queen attacking the pawn from behind,
>                 // add all X-ray attacks by the rook or queen. Otherwise consider only
>                 // the squares in the pawn's path attacked or occupied by the enemy.
>                 if (   (squares_in_front_of(Them, s) & pos.pieces(ROOK, QUEEN, Them))
>                     && (squares_in_front_of(Them, s) & pos.pieces(ROOK, QUEEN, Them) & pos.attacks_from<ROOK>(s)))
>                     unsafeSquares = squaresToQueen;
>                 else
>                     unsafeSquares = squaresToQueen & (ei.attackedBy[Them][0] | pos.pieces_of_color(Them));
> 
>                 // If there aren't enemy attacks or pieces along the path to queen give
>                 // huge bonus. Even bigger if we protect the pawn's path.
>                 if (!unsafeSquares)
>                     ebonus += Value(rr * (squaresToQueen == defendedSquares ? 17 : 15));
>                 else
>                     // OK, there are enemy attacks or pieces (but not pawns). Are those
>                     // squares which are attacked by the enemy also attacked by us ?
>                     // If yes, big bonus (but smaller than when there are no enemy attacks),
>                     // if no, somewhat smaller bonus.
>                     ebonus += Value(rr * ((unsafeSquares & defendedSquares) == unsafeSquares ? 13 : 8));
> 
>                 // At last, add a small bonus when there are no *friendly* pieces
>                 // in the pawn's path.
>                 if (!(squaresToQueen & pos.pieces_of_color(Us)))
>                     ebonus += Value(rr);
>             }
>         } // rr != 0
> 
>         // Increase the bonus if the passed pawn is supported by a friendly pawn
>         // on the same rank and a bit smaller if it's on the previous rank.
>         supportingPawns = pos.pieces(PAWN, Us) & neighboring_files_bb(s);
>         if (supportingPawns & rank_bb(s))
>             ebonus += Value(r * 20);
>         else if (supportingPawns & rank_bb(s - pawn_push(Us)))
>             ebonus += Value(r * 12);
> 
>         // Rook pawns are a special case: They are sometimes worse, and
>         // sometimes better than other passed pawns. It is difficult to find
>         // good rules for determining whether they are good or bad. For now,
>         // we try the following: Increase the value for rook pawns if the
>         // other side has no pieces apart from a knight, and decrease the
>         // value if the other side has a rook or queen.
>         if (square_file(s) == FILE_A || square_file(s) == FILE_H)
>         {
>             if (pos.non_pawn_material(Them) <= KnightValueMidgame)
>                 ebonus += ebonus / 4;
>             else if (pos.pieces(ROOK, QUEEN, Them))
>                 ebonus -= ebonus / 4;
>         }
>         score += make_score(mbonus, ebonus);
> 
>     } while (b);
> 
>     // Add the scores to the middle game and endgame eval
>     return apply_weight(score, Weights[PassedPawns]);
>   }
> 
> 
>   // evaluate_unstoppable_pawns() evaluates the unstoppable passed pawns for both sides, this is quite
>   // conservative and returns a winning score only when we are very sure that the pawn is winning.
> 
>   template<bool HasPopCnt>
>   Score evaluate_unstoppable_pawns(const Position& pos, EvalInfo& ei) {
> 
>     const BitCountType Max15 = HasPopCnt ? CNT_POPCNT : CpuIs64Bit ? CNT64_MAX15 : CNT32_MAX15;
> 
>     Bitboard b, b2, blockers, supporters, queeningPath, candidates;
>     Square s, blockSq, queeningSquare;
>     Color c, winnerSide, loserSide;
>     bool pathDefended, opposed;
>     int pliesToGo, movesToGo, oppMovesToGo, sacptg, blockersCount, minKingDist, kingptg, d;
>     int pliesToQueen[] = { 256, 256 };
> 
>     // Step 1. Hunt for unstoppable passed pawns. If we find at least one,
>     // record how many plies are required for promotion.
>     for (c = WHITE; c <= BLACK; c++)
>     {
>         // Skip if other side has non-pawn pieces
>         if (pos.non_pawn_material(opposite_color(c)))
>             continue;
> 
>         b = ei.pi->passed_pawns(c);
> 
>         while (b)
>         {
>             s = pop_1st_bit(&b);
>             queeningSquare = relative_square(c, make_square(square_file(s), RANK_8));
>             queeningPath = squares_in_front_of(c, s);
> 
>             // Compute plies to queening and check direct advancement
>             movesToGo = rank_distance(s, queeningSquare) - int(relative_rank(c, s) == RANK_2);
>             oppMovesToGo = square_distance(pos.king_square(opposite_color(c)), queeningSquare) - int(c != pos.side_to_move());
>             pathDefended = ((ei.attackedBy[c][0] & queeningPath) == queeningPath);
> 
>             if (movesToGo >= oppMovesToGo && !pathDefended)
>                 continue;
> 
>             // Opponent king cannot block because path is defended and position
>             // is not in check. So only friendly pieces can be blockers.
>             assert(!pos.in_check());
>             assert((queeningPath & pos.occupied_squares()) == (queeningPath & pos.pieces_of_color(c)));
> 
>             // Add moves needed to free the path from friendly pieces and retest condition
>             movesToGo += count_1s<Max15>(queeningPath & pos.pieces_of_color(c));
> 
>             if (movesToGo >= oppMovesToGo && !pathDefended)
>                 continue;
> 
>             pliesToGo = 2 * movesToGo - int(c == pos.side_to_move());
>             pliesToQueen[c] = Min(pliesToQueen[c], pliesToGo);
>         }
>     }
> 
>     // Step 2. If either side cannot promote at least three plies before the other side then situation
>     // becomes too complex and we give up. Otherwise we determine the possibly "winning side"
>     if (abs(pliesToQueen[WHITE] - pliesToQueen[BLACK]) < 3)
>         return SCORE_ZERO;
> 
>     winnerSide = (pliesToQueen[WHITE] < pliesToQueen[BLACK] ? WHITE : BLACK);
>     loserSide = opposite_color(winnerSide);
> 
>     // Step 3. Can the losing side possibly create a new passed pawn and thus prevent the loss?
>     b = candidates = pos.pieces(PAWN, loserSide);
> 
>     while (b)
>     {
>         s = pop_1st_bit(&b);
> 
>         // Compute plies from queening
>         queeningSquare = relative_square(loserSide, make_square(square_file(s), RANK_8));
>         movesToGo = rank_distance(s, queeningSquare) - int(relative_rank(loserSide, s) == RANK_2);
>         pliesToGo = 2 * movesToGo - int(loserSide == pos.side_to_move());
> 
>         // Check if (without even considering any obstacles) we're too far away or doubled
>         if (   pliesToQueen[winnerSide] + 3 <= pliesToGo
>             || (squares_in_front_of(loserSide, s) & pos.pieces(PAWN, loserSide)))
>             clear_bit(&candidates, s);
>     }
> 
>     // If any candidate is already a passed pawn it _may_ promote in time. We give up.
>     if (candidates & ei.pi->passed_pawns(loserSide))
>         return SCORE_ZERO;
> 
>     // Step 4. Check new passed pawn creation through king capturing and pawn sacrifices
>     b = candidates;
> 
>     while (b)
>     {
>         s = pop_1st_bit(&b);
>         sacptg = blockersCount = 0;
>         minKingDist = kingptg = 256;
> 
>         // Compute plies from queening
>         queeningSquare = relative_square(loserSide, make_square(square_file(s), RANK_8));
>         movesToGo = rank_distance(s, queeningSquare) - int(relative_rank(loserSide, s) == RANK_2);
>         pliesToGo = 2 * movesToGo - int(loserSide == pos.side_to_move());
> 
>         // Generate list of blocking pawns and supporters
>         supporters = neighboring_files_bb(s) & candidates;
>         opposed = squares_in_front_of(loserSide, s) & pos.pieces(PAWN, winnerSide);
>         blockers = passed_pawn_mask(loserSide, s) & pos.pieces(PAWN, winnerSide);
> 
>         assert(blockers);
> 
>         // How many plies does it take to remove all the blocking pawns?
>         while (blockers)
>         {
>             blockSq = pop_1st_bit(&blockers);
>             movesToGo = 256;
> 
>             // Check pawns that can give support to overcome obstacle, for instance
>             // black pawns: a4, b4 white: b2 then pawn in b4 is giving support.
>             if (!opposed)
>             {
>                 b2 = supporters & in_front_bb(winnerSide, blockSq + pawn_push(winnerSide));
> 
>                 while (b2) // This while-loop could be replaced with LSB/MSB (depending on color)
>                 {
>                     d = square_distance(blockSq, pop_1st_bit(&b2)) - 2;
>                     movesToGo = Min(movesToGo, d);
>                 }
>             }
> 
>             // Check pawns that can be sacrificed against the blocking pawn
>             b2 = attack_span_mask(winnerSide, blockSq) & candidates & ~(1ULL << s);
> 
>             while (b2) // This while-loop could be replaced with LSB/MSB (depending on color)
>             {
>                 d = square_distance(blockSq, pop_1st_bit(&b2)) - 2;
>                 movesToGo = Min(movesToGo, d);
>             }
> 
>             // If obstacle can be destroyed with an immediate pawn exchange / sacrifice,
>             // it's not a real obstacle and we have nothing to add to pliesToGo.
>             if (movesToGo <= 0)
>                 continue;
> 
>             // Plies needed to sacrifice against all the blocking pawns
>             sacptg += movesToGo * 2;
>             blockersCount++;
> 
>             // Plies needed for the king to capture all the blocking pawns
>             d = square_distance(pos.king_square(loserSide), blockSq);
>             minKingDist = Min(minKingDist, d);
>             kingptg = (minKingDist + blockersCount) * 2;
>         }
> 
>         // Check if pawn sacrifice plan _may_ save the day
>         if (pliesToQueen[winnerSide] + 3 > pliesToGo + sacptg)
>             return SCORE_ZERO;
> 
>         // Check if king capture plan _may_ save the day (contains some false positives)
>         if (pliesToQueen[winnerSide] + 3 > pliesToGo + kingptg)
>             return SCORE_ZERO;
>     }
> 
>     // Winning pawn is unstoppable and will promote as first, return big score
>     Score score = make_score(0, (Value) 0x500 - 0x20 * pliesToQueen[winnerSide]);
>     return winnerSide == WHITE ? score : -score;
>   }
> 
> 
>   // evaluate_space() computes the space evaluation for a given side. The
>   // space evaluation is a simple bonus based on the number of safe squares
>   // available for minor pieces on the central four files on ranks 2--4. Safe
>   // squares one, two or three squares behind a friendly pawn are counted
>   // twice. Finally, the space bonus is scaled by a weight taken from the
>   // material hash table. The aim is to improve play on game opening.
>   template<Color Us, bool HasPopCnt>
>   int evaluate_space(const Position& pos, EvalInfo& ei) {
> 
>     const BitCountType Max15 = HasPopCnt ? CNT_POPCNT : CpuIs64Bit ? CNT64_MAX15 : CNT32_MAX15;
>     const Color Them = (Us == WHITE ? BLACK : WHITE);
> 
>     // Find the safe squares for our pieces inside the area defined by
>     // SpaceMask[]. A square is unsafe if it is attacked by an enemy
>     // pawn, or if it is undefended and attacked by an enemy piece.
>     Bitboard safe =   SpaceMask[Us]
>                    & ~pos.pieces(PAWN, Us)
>                    & ~ei.attackedBy[Them][PAWN]
>                    & (ei.attackedBy[Us][0] | ~ei.attackedBy[Them][0]);
> 
>     // Find all squares which are at most three squares behind some friendly pawn
>     Bitboard behind = pos.pieces(PAWN, Us);
>     behind |= (Us == WHITE ? behind >>  8 : behind <<  8);
>     behind |= (Us == WHITE ? behind >> 16 : behind << 16);
> 
>     return count_1s<Max15>(safe) + count_1s<Max15>(behind & safe);
>   }
> 
> 
>   // apply_weight() applies an evaluation weight to a value trying to prevent overflow
> 
>   inline Score apply_weight(Score v, Score w) {
>     return make_score((int(mg_value(v)) * mg_value(w)) / 0x100,
>                       (int(eg_value(v)) * eg_value(w)) / 0x100);
>   }
> 
> 
>   // scale_by_game_phase() interpolates between a middle game and an endgame score,
>   // based on game phase. It also scales the return value by a ScaleFactor array.
> 
>   Value scale_by_game_phase(const Score& v, Phase ph, ScaleFactor sf) {
> 
>     assert(mg_value(v) > -VALUE_INFINITE && mg_value(v) < VALUE_INFINITE);
>     assert(eg_value(v) > -VALUE_INFINITE && eg_value(v) < VALUE_INFINITE);
>     assert(ph >= PHASE_ENDGAME && ph <= PHASE_MIDGAME);
> 
>     int ev = (eg_value(v) * int(sf)) / SCALE_FACTOR_NORMAL;
>     int result = (mg_value(v) * int(ph) + ev * int(128 - ph)) / 128;
>     return Value((result + GrainSize / 2) & ~(GrainSize - 1));
>   }
> 
> 
>   // weight_option() computes the value of an evaluation weight, by combining
>   // two UCI-configurable weights (midgame and endgame) with an internal weight.
> 
>   Score weight_option(const std::string& mgOpt, const std::string& egOpt, Score internalWeight) {
> 
>     // Scale option value from 100 to 256
>     int mg = Options[mgOpt].value<int>() * 256 / 100;
>     int eg = Options[egOpt].value<int>() * 256 / 100;
> 
>     return apply_weight(make_score(mg, eg), internalWeight);
>   }
> 
> 
>   // init_safety() initizes the king safety evaluation, based on UCI
>   // parameters. It is called from read_weights().
> 
>   void init_safety() {
> 
>     const Value MaxSlope = Value(30);
>     const Value Peak = Value(1280);
>     Value t[100];
> 
>     // First setup the base table
>     for (int i = 0; i < 100; i++)
>     {
>         t[i] = Value(int(0.4 * i * i));
> 
>         if (i > 0)
>             t[i] = Min(t[i], t[i - 1] + MaxSlope);
> 
>         t[i] = Min(t[i], Peak);
>     }
> 
>     // Then apply the weights and get the final KingDangerTable[] array
>     for (Color c = WHITE; c <= BLACK; c++)
>         for (int i = 0; i < 100; i++)
>             KingDangerTable[c][i] = apply_weight(make_score(t[i], 0), Weights[KingDangerUs + c]);
>   }
> 
> 
>   // A couple of little helpers used by tracing code, to_cp() converts a value to
>   // a double in centipawns scale, trace_add() stores white and black scores.
> 
>   double to_cp(Value v) { return double(v) / double(PawnValueMidgame); }
> 
>   void trace_add(int idx, Score wScore, Score bScore) {
> 
>       TracedScores[WHITE][idx] = wScore;
>       TracedScores[BLACK][idx] = bScore;
>   }
> 
>   // trace_row() is an helper function used by tracing code to register the
>   // values of a single evaluation term.
> 
>   void trace_row(const char *name, int idx) {
> 
>     Score wScore = TracedScores[WHITE][idx];
>     Score bScore = TracedScores[BLACK][idx];
> 
>     switch (idx) {
>     case PST: case IMBALANCE: case PAWN: case UNSTOPPABLE: case TOTAL:
>         TraceStream << std::setw(20) << name << " |   ---   --- |   ---   --- | "
>                     << std::setw(6)  << to_cp(mg_value(wScore)) << " "
>                     << std::setw(6)  << to_cp(eg_value(wScore)) << " \n";
>         break;
>     default:
>         TraceStream << std::setw(20) << name << " | " << std::noshowpos
>                     << std::setw(5)  << to_cp(mg_value(wScore)) << " "
>                     << std::setw(5)  << to_cp(eg_value(wScore)) << " | "
>                     << std::setw(5)  << to_cp(mg_value(bScore)) << " "
>                     << std::setw(5)  << to_cp(eg_value(bScore)) << " | "
>                     << std::showpos
>                     << std::setw(6)  << to_cp(mg_value(wScore - bScore)) << " "
>                     << std::setw(6)  << to_cp(eg_value(wScore - bScore)) << " \n";
>     }
>   }
725,729c1179,1220
< Value evaluate(const Position& pos, Value& margin)
< {
< 	margin = VALUE_ZERO;
< 	const Color us = pos.side_to_move();
< 	return Value(pos.evaluate(us));
---
> 
> /// trace_evaluate() is like evaluate() but instead of a value returns a string
> /// suitable to be print on stdout with the detailed descriptions and values of
> /// each evaluation term. Used mainly for debugging.
> 
> std::string trace_evaluate(const Position& pos) {
> 
>     Value margin;
>     std::string totals;
> 
>     TraceStream.str("");
>     TraceStream << std::showpoint << std::showpos << std::fixed << std::setprecision(2);
>     memset(TracedScores, 0, 2 * 16 * sizeof(Score));
> 
>     do_evaluate<false, true>(pos, margin);
> 
>     totals = TraceStream.str();
>     TraceStream.str("");
> 
>     TraceStream << std::setw(21) << "Eval term " << "|    White    |    Black    |     Total     \n"
>                 <<             "                     |   MG    EG  |   MG    EG  |   MG     EG   \n"
>                 <<             "---------------------+-------------+-------------+---------------\n";
> 
>     trace_row("Material, PST, Tempo", PST);
>     trace_row("Material imbalance", IMBALANCE);
>     trace_row("Pawns", PAWN);
>     trace_row("Knights", KNIGHT);
>     trace_row("Bishops", BISHOP);
>     trace_row("Rooks", ROOK);
>     trace_row("Queens", QUEEN);
>     trace_row("Mobility", MOBILITY);
>     trace_row("King safety", KING);
>     trace_row("Threats", THREAT);
>     trace_row("Passed pawns", PASSED);
>     trace_row("Unstoppable pawns", UNSTOPPABLE);
>     trace_row("Space", SPACE);
> 
>     TraceStream <<             "---------------------+-------------+-------------+---------------\n";
>     trace_row("Total", TOTAL);
>     TraceStream << totals;
> 
>     return TraceStream.str();
########################## main.cpp
2c2
<   NanohaMini, a USI shogi(japanese-chess) playing engine derived from Stockfish 2.1
---
>   Stockfish, a UCI chess playing engine derived from Glaurung 2.1
4,5c4
<   Copyright (C) 2008-2010 Marco Costalba, Joona Kiiski, Tord Romstad (Stockfish author)
<   Copyright (C) 2014 Kazuyuki Kawabata
---
>   Copyright (C) 2008-2010 Marco Costalba, Joona Kiiski, Tord Romstad
7c6
<   NanohaMini is free software: you can redistribute it and/or modify
---
>   Stockfish is free software: you can redistribute it and/or modify
12c11
<   NanohaMini is distributed in the hope that it will be useful,
---
>   Stockfish is distributed in the hope that it will be useful,
20a20,22
> // To profile with callgrind uncomment following line
> //#define USE_CALLGRIND
> 
22d23
< #include <cassert>
26d26
< #if !defined(NANOHA)
29d28
< #endif
34a34,37
> #ifdef USE_CALLGRIND
> #include <valgrind/callgrind.h>
> #endif
> 
37c40
< extern void uci_loop();
---
> extern bool execute_uci_command(const string& cmd);
39,48c42
< #if defined(NANOHA)
< extern void bench_mate(int argc, char* argv[]);
< extern void bench_genmove(int argc, char* argv[]);
< extern void bench_eval(int argc, char* argv[]);
< extern void solve_problem(int argc, char* argv[]);
< extern void test_qsearch(int argc, char* argv[]);
< extern void test_see(int argc, char* argv[]);
< #else
< extern void kpk_bitbase_init();
< #endif
---
> extern void init_kpk_bitbase();
52,133c46,83
< 	// 標準入出力のバッファリングを無効にする
< 	// Disable IO buffering for C and C++ standard libraries
< 	setvbuf(stdin, NULL, _IONBF, 0);
< 	setvbuf(stdout, NULL, _IONBF, 0);
< 	cout.rdbuf()->pubsetbuf(NULL, 0);
< 	cin.rdbuf()->pubsetbuf(NULL, 0);
< #if defined(NANOHA)
< 	init_application_once();
< #endif
< 
< 	// Startup initializations
< #ifndef NANOHA
< 	init_bitboards();
< #endif
< 	Position::init();
< #ifndef NANOHA
< 	kpk_bitbase_init();
< #endif
< 	init_search();
< 	Threads.init();
< 
< 	if (argc < 2)
< 	{
< 		// 引数1個
< #if !defined(NANOHA)
< 		// Print copyright notice
< 		cout << engine_name() << " by " << engine_authors() << endl;
< 
< 		if (CpuHasPOPCNT)
< 			cout << "Good! CPU has hardware POPCNT." << endl;
< #endif
< 
< 		// USIのコマンド処理
< 		// Enter the UCI loop waiting for input
< 		uci_loop();
< 	}
< #if defined(NANOHA)
< 	else if (string(argv[1]) == "bench" && argc > 2 
< 	         && (string(argv[2]) == "mate1" || string(argv[2]) == "mate3")) {
< 		bench_mate(--argc, ++argv);
< 	}
< 	else if (string(argv[1]) == "bench" && argc > 2 && string(argv[2]) == "genmove") {
< 		bench_genmove(--argc, ++argv);
< 	}
< 	else if (string(argv[1]) == "bench" && argc > 2 && string(argv[2]) == "eval") {
< 		bench_eval(--argc, ++argv);
< 	}
< 	else if (string(argv[1]) == "qsearch") {
< 		test_qsearch(--argc, ++argv);
< 	}
< 	else if (string(argv[1]) == "see") {
< 		test_see(--argc, ++argv);
< 	}
< 	else if (string(argv[1]) == "problem") {
< 		solve_problem(--argc, ++argv);
< 	}
< #endif
< 	else if (string(argv[1]) == "bench" && argc < 8)
< 		benchmark(argc, argv);
< 	else
< #if defined(NANOHA)
< 	{
< 		cout << "Usage: nanohamini [Options]" << endl;
< 		cout << "Options:\n"
< 		        "   bench [hash size = 128] [threads = 1] "
< 		                 "[limit = 12] [fen positions file = default] "
< 		                 "[limited by depth, time, nodes or perft = depth]\n";
< 		cout << "   bench genmove "
< 		                 "[fen positions file = default] "
< 		                 "[display moves = no]\n";
< 		cout << "   bench mate1 "
< 		                 "[fen positions file = default] "
< 		                 "[loop = yes] [display = no]\n";
< 		cout << "   bench mate3 "
< 		                 "[fen positions file = default] "
< 		                 "[loop = yes] [display moves = no]" << endl;
< 	}
< #else
< 	cout << "Usage: stockfish bench [hash size = 128] [threads = 1] "
< 	     << "[limit = 12] [fen positions file = default] "
< 	     << "[limited by depth, time, nodes or perft = depth]" << endl;
< #endif
---
>   // Disable IO buffering for C and C++ standard libraries
>   setvbuf(stdin, NULL, _IONBF, 0);
>   setvbuf(stdout, NULL, _IONBF, 0);
>   cout.rdbuf()->pubsetbuf(NULL, 0);
>   cin.rdbuf()->pubsetbuf(NULL, 0);
> 
>   // Startup initializations
>   init_bitboards();
>   Position::init_zobrist();
>   Position::init_piece_square_tables();
>   init_kpk_bitbase();
>   init_search();
>   Threads.init();
> 
> #ifdef USE_CALLGRIND
>   CALLGRIND_START_INSTRUMENTATION;
> #endif
> 
>   if (argc < 2)
>   {
>       // Print copyright notice
>       cout << engine_name() << " by " << engine_authors() << endl;
> 
>       if (CpuHasPOPCNT)
>           cout << "Good! CPU has hardware POPCNT." << endl;
> 
>       // Wait for a command from the user, and passes this command to
>       // execute_uci_command() and also intercepts EOF from stdin to
>       // ensure that we exit gracefully if the GUI dies unexpectedly.
>       string cmd;
>       while (getline(cin, cmd) && execute_uci_command(cmd)) {}
>   }
>   else if (string(argv[1]) == "bench" && argc < 8)
>       benchmark(argc, argv);
>   else
>       cout << "Usage: stockfish bench [hash size = 128] [threads = 1] "
>            << "[limit = 12] [fen positions file = default] "
>            << "[limited by depth, time, nodes or perft = depth]" << endl;
135,136c85,86
< 	Threads.exit();
< 	return 0;
---
>   Threads.exit();
>   return 0;
########################## mate.cpp
########################## mate1ply.cpp
########################## misc.cpp
2c2
<   NanohaMini, a USI shogi(japanese-chess) playing engine derived from Stockfish 2.1
---
>   Stockfish, a UCI chess playing engine derived from Glaurung 2.1
4,5c4
<   Copyright (C) 2008-2010 Marco Costalba, Joona Kiiski, Tord Romstad (Stockfish author)
<   Copyright (C) 2014 Kazuyuki Kawabata
---
>   Copyright (C) 2008-2010 Marco Costalba, Joona Kiiski, Tord Romstad
7c6
<   NanohaMini is free software: you can redistribute it and/or modify
---
>   Stockfish is free software: you can redistribute it and/or modify
12c11
<   NanohaMini is distributed in the hope that it will be useful,
---
>   Stockfish is distributed in the hope that it will be useful,
21c20
< #if !defined(_MSC_VER) && !defined(_WIN32)
---
> #if !defined(_MSC_VER)
48d46
< #if !defined(NANOHA)
50d47
< #endif
59,70d55
< #if defined(NANOHA)
< #if defined(EVAL_MICRO)
< static const string AppName = "NanohaMicro";
< static const string EngineVersion = "0.2.1.1";
< #elif defined(EVAL_OLD)
< static const string AppName = "NanohaMini";
< static const string EngineVersion = "0.2.1.1";
< #else
< static const string AppName = "NanohaMini";
< static const string EngineVersion = "0.2.1.1b";
< #endif
< #else
72,73c57
< static const string EngineVersion = "2.1";
< #endif
---
> static const string EngineVersion = "2.1.1";
84,85c68,69
< 	const string months("Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec");
< 	const string cpu64(CpuIs64Bit ? " 64bit" : "");
---
>   const string months("Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec");
>   const string cpu64(CpuIs64Bit ? " 64bit" : "");
87,88c71,72
< 	if (!EngineVersion.empty())
< 		return AppName + " " + EngineVersion + cpu64;
---
>   if (!EngineVersion.empty())
>       return AppName + " " + EngineVersion + cpu64;
90,91c74,75
< 	stringstream s, date(__DATE__); // From compiler, format is "Sep 21 2008"
< 	string month, day, year;
---
>   stringstream s, date(__DATE__); // From compiler, format is "Sep 21 2008"
>   string month, day, year;
93c77
< 	date >> month >> day >> year;
---
>   date >> month >> day >> year;
95,98c79,82
< 	s << setfill('0') << AppName + " " + AppTag + " "
< 	  << year.substr(2, 2) << setw(2)
< 	  << (1 + months.find(month) / 4) << setw(2)
< 	  << day << cpu64;
---
>   s << setfill('0') << AppName + " " + AppTag + " "
>     << year.substr(2, 2) << setw(2)
>     << (1 + months.find(month) / 4) << setw(2)
>     << day << cpu64;
100c84
< 	return s.str();
---
>   return s.str();
108,112c92
< #if defined(NANOHA)
< 	return "Kawabata, Kazuyuki";
< #else
< 	return "Tord Romstad, Marco Costalba and Joona Kiiski";
< #endif
---
>   return "Tord Romstad, Marco Costalba and Joona Kiiski";
125,127c105,107
< 	if (dbg_hit_cnt0)
< 		cout << "Total " << dbg_hit_cnt0 << " Hit " << dbg_hit_cnt1
< 		     << " hit rate (%) " << 100 * dbg_hit_cnt1 / dbg_hit_cnt0 << endl;
---
>   if (dbg_hit_cnt0)
>       cout << "Total " << dbg_hit_cnt0 << " Hit " << dbg_hit_cnt1
>            << " hit rate (%) " << 100 * dbg_hit_cnt1 / dbg_hit_cnt0 << endl;
132,134c112,114
< 	if (dbg_mean_cnt0)
< 		cout << "Total " << dbg_mean_cnt0 << " Mean "
< 		     << (float)dbg_mean_cnt1 / dbg_mean_cnt0 << endl;
---
>   if (dbg_mean_cnt0)
>       cout << "Total " << dbg_mean_cnt0 << " Mean "
>            << (float)dbg_mean_cnt1 / dbg_mean_cnt0 << endl;
139,140c119,120
< 	dbg_mean_cnt0++;
< 	dbg_mean_cnt1 += v;
---
>   dbg_mean_cnt0++;
>   dbg_mean_cnt1 += v;
145,147c125,127
< 	dbg_hit_cnt0++;
< 	if (b)
< 		dbg_hit_cnt1++;
---
>   dbg_hit_cnt0++;
>   if (b)
>       dbg_hit_cnt1++;
159,162c139,142
< #if defined(_MSC_VER) || defined(_WIN32)
< 	struct _timeb t;
< 	_ftime(&t);
< 	return int(t.time * 1000 + t.millitm);
---
> #if defined(_MSC_VER)
>   struct _timeb t;
>   _ftime(&t);
>   return int(t.time * 1000 + t.millitm);
164,166c144,146
< 	struct timeval t;
< 	gettimeofday(&t, NULL);
< 	return t.tv_sec * 1000 + t.tv_usec / 1000;
---
>   struct timeval t;
>   gettimeofday(&t, NULL);
>   return t.tv_sec * 1000 + t.tv_usec / 1000;
175,178c155,158
< #if defined(_MSC_VER) || defined(_WIN32)
< 	SYSTEM_INFO s;
< 	GetSystemInfo(&s);
< 	return Min(s.dwNumberOfProcessors, (DWORD)MAX_THREADS);
---
> #if defined(_MSC_VER)
>   SYSTEM_INFO s;
>   GetSystemInfo(&s);
>   return Min(s.dwNumberOfProcessors, MAX_THREADS);
182c162
< 	return Min(sysconf(_SC_NPROCESSORS_ONLN), (long)MAX_THREADS);
---
>   return Min(sysconf(_SC_NPROCESSORS_ONLN), MAX_THREADS);
184,187c164,167
< 	struct pst_dynamic psd;
< 	if (pstat_getdynamic(&psd, sizeof(psd), (size_t)1, 0) == -1)
< 		return 1;
< 	return Min(psd.psd_proc_cnt, (long)MAX_THREADS);
---
>   struct pst_dynamic psd;
>   if (pstat_getdynamic(&psd, sizeof(psd), (size_t)1, 0) == -1)
>       return 1;
>   return Min(psd.psd_proc_cnt, MAX_THREADS);
189c169
< 	return 1;
---
>   return 1;
202,203c182,183
< 	fd_set readfds;
< 	struct timeval  timeout;
---
>   fd_set readfds;
>   struct timeval  timeout;
205,209c185,189
< 	FD_ZERO(&readfds);
< 	FD_SET(fileno(stdin), &readfds);
< 	timeout.tv_sec = 0; // Set to timeout immediately
< 	timeout.tv_usec = 0;
< 	select(16, &readfds, 0, 0, &timeout);
---
>   FD_ZERO(&readfds);
>   FD_SET(fileno(stdin), &readfds);
>   timeout.tv_sec = 0; // Set to timeout immediately
>   timeout.tv_usec = 0;
>   select(16, &readfds, 0, 0, &timeout);
211c191
< 	return (FD_ISSET(fileno(stdin), &readfds));
---
>   return (FD_ISSET(fileno(stdin), &readfds));
218,261c198,241
< 	static HANDLE inh = NULL;
< 	static bool usePipe = false;
< 	INPUT_RECORD rec[256];
< 	DWORD nchars, recCnt;
< 
< 	if (!inh)
< 	{
< 		inh = GetStdHandle(STD_INPUT_HANDLE);
< 		if (GetConsoleMode(inh, &nchars))
< 		{
< 			SetConsoleMode(inh, nchars & ~(ENABLE_MOUSE_INPUT | ENABLE_WINDOW_INPUT));
< 			FlushConsoleInputBuffer(inh);
< 		} else
< 			usePipe = true;
< 	}
< 
< 	// When using Standard C input functions, also check if there
< 	// is anything in the buffer. After a call to such functions,
< 	// the input waiting in the pipe will be copied to the buffer,
< 	// and the call to PeekNamedPipe can indicate no input available.
< 	// Setting stdin to unbuffered was not enough. [from Greko]
< 	if (stdin->_cnt > 0)
< 		return 1;
< 
< 	// When running under a GUI the input commands are sent to us
< 	// directly over the internal pipe. If PeekNamedPipe() returns 0
< 	// then something went wrong. Probably the parent program exited.
< 	// Returning 1 will make the next call to the input function
< 	// return EOF, where this should be catched then.
< 	if (usePipe)
< 		return PeekNamedPipe(inh, NULL, 0, NULL, &nchars, NULL) ? nchars : 1;
< 
< 	// Count the number of unread input records, including keyboard,
< 	// mouse, and window-resizing input records.
< 	GetNumberOfConsoleInputEvents(inh, &nchars);
< 
< 	// Read data from console without removing it from the buffer
< 	if (nchars <= 0 || !PeekConsoleInput(inh, rec, Min(nchars, (DWORD)256), &recCnt))
< 		return 0;
< 
< 	// Search for at least one keyboard event
< 	for (DWORD i = 0; i < recCnt; i++)
< 		if (rec[i].EventType == KEY_EVENT)
< 			return 1;
---
>   static HANDLE inh = NULL;
>   static bool usePipe = false;
>   INPUT_RECORD rec[256];
>   DWORD nchars, recCnt;
> 
>   if (!inh)
>   {
>       inh = GetStdHandle(STD_INPUT_HANDLE);
>       if (GetConsoleMode(inh, &nchars))
>       {
>           SetConsoleMode(inh, nchars & ~(ENABLE_MOUSE_INPUT | ENABLE_WINDOW_INPUT));
>           FlushConsoleInputBuffer(inh);
>       } else
>           usePipe = true;
>   }
> 
>   // When using Standard C input functions, also check if there
>   // is anything in the buffer. After a call to such functions,
>   // the input waiting in the pipe will be copied to the buffer,
>   // and the call to PeekNamedPipe can indicate no input available.
>   // Setting stdin to unbuffered was not enough. [from Greko]
>   if (stdin->_cnt > 0)
>       return 1;
> 
>   // When running under a GUI the input commands are sent to us
>   // directly over the internal pipe. If PeekNamedPipe() returns 0
>   // then something went wrong. Probably the parent program exited.
>   // Returning 1 will make the next call to the input function
>   // return EOF, where this should be catched then.
>   if (usePipe)
>       return PeekNamedPipe(inh, NULL, 0, NULL, &nchars, NULL) ? nchars : 1;
> 
>   // Count the number of unread input records, including keyboard,
>   // mouse, and window-resizing input records.
>   GetNumberOfConsoleInputEvents(inh, &nchars);
> 
>   // Read data from console without removing it from the buffer
>   if (nchars <= 0 || !PeekConsoleInput(inh, rec, Min(nchars, 256), &recCnt))
>       return 0;
> 
>   // Search for at least one keyboard event
>   for (DWORD i = 0; i < recCnt; i++)
>       if (rec[i].EventType == KEY_EVENT)
>           return 1;
263c243
< 	return 0;
---
>   return 0;
281,283c261,263
< 	 // This hack prevents prefetches to be optimized away by
< 	 // Intel compiler. Both MSVC and gcc seems not affected.
< 	 __asm__ ("");
---
>    // This hack prevents prefetches to be optimized away by
>    // Intel compiler. Both MSVC and gcc seems not affected.
>    __asm__ ("");
286,287c266,267
< 	_mm_prefetch(addr, _MM_HINT_T2);
< 	_mm_prefetch(addr+64, _MM_HINT_T2); // 64 bytes ahead
---
>   _mm_prefetch(addr, _MM_HINT_T2);
>   _mm_prefetch(addr+64, _MM_HINT_T2); // 64 bytes ahead
########################## move.cpp
2c2
<   NanohaMini, a USI shogi(japanese-chess) playing engine derived from Stockfish 2.1
---
>   Stockfish, a UCI chess playing engine derived from Glaurung 2.1
4,5c4
<   Copyright (C) 2008-2010 Marco Costalba, Joona Kiiski, Tord Romstad (Stockfish author)
<   Copyright (C) 2014 Kazuyuki Kawabata
---
>   Copyright (C) 2008-2010 Marco Costalba, Joona Kiiski, Tord Romstad
7c6
<   NanohaMini is free software: you can redistribute it and/or modify
---
>   Stockfish is free software: you can redistribute it and/or modify
12c11
<   NanohaMini is distributed in the hope that it will be useful,
---
>   Stockfish is distributed in the hope that it will be useful,
22a22
> #include <iomanip>
23a24
> #include <sstream>
27c28
< #include "position.h"
---
> #include "search.h"
31,52d31
< /// move_to_uci() converts a move to a string in coordinate notation
< /// (g1f3, a7a8q, etc.). The only special case is castling moves, where we
< /// print in the e1g1 notation in normal chess mode, and in e1h1 notation in
< /// Chess960 mode. Instead internally Move is coded as "king captures rook".
< 
< #if defined(NANOHA)
< //
< // 将棋所のドキュメントからSFEN形式に関する記載抜粋
< //
< // 指し手の表記について解説します。
< // 筋に関しては１から９までの数字で表記され、段に関してはaからiまでのアルファベット
< // （１段目がa、２段目がb、・・・、９段目がi）というように表記されます。位置の表記は、
< // この２つを組み合わせます。５一なら5a、１九なら1iとなります。
< // そして、指し手に関しては、駒の移動元の位置と移動先の位置を並べて書きます。
< // ７七の駒が７六に移動したのであれば、7g7fと表記します。（駒の種類を表記する
< // 必要はありません。）
< // 駒が成るときは、最後に+を追加します。８八の駒が２二に移動して成るなら8h2b+
< // と表記します。
< // 持ち駒を打つときは、最初に駒の種類を大文字で書き、それに*を追加し、さらに
< // 打った場所を追加します。金を５二に打つ場合はG*5bとなります
< 
< // SFEN形式における指し手の表示で、段の数字をアルファベットに変換する配列
54,110c33,34
< 	char danSFENNameArray[] = {
< 		'\0', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i',
< 	};
< 
< 	char mochiGomaSFENNameArray[]={
< 	' ', 'P','L','N','S','G','B','R',' ',' ',' ',' ',' ',' ',' ',' ',
< 	' ', 'P','L','N','S','G','B','R',' ',' ',' ',' ',' ',' ',' ',' ',
< 	' ', ' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
< 	};
< #if defined(__GNUC__)
< 	// 8C5C はCodePage932(シフトJIS)での文字コードなので、文字コードを変更する場合は要変更.
< 	static const char *piece_ja_str[] = {
< 		"　", "歩", "香", "桂",       "銀", "金", "角", "飛", 
< 		"玉", "と", "杏", "\x8C\x5C", "全", "〓", "馬", "龍",
< 	};
< #else
< 	static const char *piece_ja_str[] = {
< 		"　", "歩", "香", "桂", "銀", "金", "角", "飛", 
< 		"玉", "と", "杏", "圭", "全", "〓", "馬", "龍", 
< 	};
< #endif
< };
< 
< const std::string move_to_uci(Move m)
< {
< 	if (m == MOVE_NONE)
< 		return "(none)";
< 
< 	if (m == MOVE_NULL)
< 		return "0000";
< 
< 	char buf[8];
< 	const int from = move_from(m);
< 	const int to = move_to(m);
< 	const bool promote = is_promotion(m);
< 	const Piece piece = move_piece(m);
< 	if (move_is_drop(m) == false) {
< 		int fromSuji = from / 0x10;
< 		int fromDan = from % 0x10;
< 		buf[0] = '0' + fromSuji;
< 		buf[1] = danSFENNameArray[fromDan];
< 	} else {
< 		buf[0] = mochiGomaSFENNameArray[piece];
< 		buf[1] = '*';
< 	}
< 	int toSuji = to / 0x10;
< 	int toDan = to % 0x10;
< 	buf[2] = '0' + toSuji;
< 	buf[3] = danSFENNameArray[toDan];
< 	if (promote) {
< 		buf[4] = '+';
< 		buf[5] = '\0';
< 	} else {
< 		buf[4] = '\0';
< 	}
< 	std::string s(buf);
< 	return s;
---
>   const string time_string(int milliseconds);
>   const string score_string(Value v);
113,171d36
< const std::string move_to_csa(Move m)
< {
< 	const Piece p = move_piece(m);
< 	const int from = move_from(m);
< 	const int to = move_to(m);
< 	const Color c = color_of(p);
< 	char buf[128];
< 	static const char *pieceStr[] = {
< 		"..", "FU", "KY", "KE", "GI", "KI", "KA", "HI",
< 		"OU", "TO", "NY", "NK", "NG", "--", "UM", "RY",
< 	};
< 
< 	string str = (c == BLACK) ? "+" : "-";
< 	if (m == MOVE_NONE) {
< 		str += "(xxxx)";
< 	} else if (m == MOVE_NULL) {
< 		str += "(NULL)";
< 	} else if (move_is_drop(m)) {
< 		snprintf(buf, sizeof(buf), "00%02X%s", to, pieceStr[type_of(p)]);
< 		str += buf;
< 	} else {
< 		if (is_promotion(m)) {
< 			snprintf(buf, sizeof(buf), "%02X%02X%s", from, to, pieceStr[type_of(p) | PROMOTED]);
< 		} else {
< 			snprintf(buf, sizeof(buf), "%02X%02X%s", from, to, pieceStr[type_of(p)]);
< 		}
< 		str += buf;
< 	}
< 	return str;
< }
< 
< const std::string move_to_kif(Move m)
< {
< 	const PieceType p = move_ptype(m);
< 	const int from = move_from(m);
< 	const int to = move_to(m);
< 	char buf[16];
< 
< 	// "76歩(77)　"	；移動
< 	// "22角(88)成"	；移動＋成
< 	// "24歩打　　"	；駒打ち
< 	// "(null)　　"	；MOVE_NULL
< 	if (m == MOVE_NULL) {
< 		// 駒打ち
< 		strcpy(buf, "(null)　　");
< 	}else if (move_is_drop(m)) {
< 		// 駒打ち
< 		sprintf(buf, "%02x%s打　　", to, piece_ja_str[p]);
< 	} else {
< 		// 移動
< 		if (is_promotion(m)) {
< 			sprintf(buf, "%02x%s成(%02x)", to, piece_ja_str[p], from);
< 		} else {
< 			sprintf(buf, "%02x%s(%02x)　", to, piece_ja_str[p], from);
< 		}
< 	}
< 	string str = buf;
< 	return str;
< }
173,227c38,41
< void move_fprint(FILE *fp, Move m, int rotate)
< {
< 	if (fp == NULL) return;
< 	if (m == MOVE_NONE) {
< 		foutput_log(fp, "パス　　　");
< 	}
< 	int to = move_to(m);
< 	int from = move_from(m);
< 	int rto = to;
< 	int rfrom = from;
< 	int x, y;
< 	switch (rotate) {
< 	case 0:	// 入換えなし
< 		break;
< 	case 2:	// 左右入換え
< 		x = to & 0xF0;
< 		y = to & 0x0F;
< 		rto = (0xA0 - x) + y;
< 		x = from & 0xF0;
< 		y = from & 0x0F;
< 		rfrom = (0xA0 - x) + y;
< 		break;
< 	case 1:	// 左右入換え＋上下入換え
< 		x = to & 0xF0;
< 		y = to & 0x0F;
< 		rto = (0xA0 - x) + (10 - y);
< 		x = from & 0xF0;
< 		y = from & 0x0F;
< 		rfrom = (0xA0 - x) + (10 - y);
< 		break;
< 	case 3:	// 上下入換え
< 		x = to & 0xF0;
< 		y = to & 0x0F;
< 		rto = x + (10 - y);
< 		x = from & 0xF0;
< 		y = from & 0x0F;
< 		rfrom = x + (10 - y);
< 		break;
< 	default:
< 		break;
< 	}
< 	foutput_log(fp, "%02x", rto);
< 	foutput_log(fp, "%2s", piece_ja_str[move_ptype(m)]);
< 	if (is_promotion(m)) {
< 		foutput_log(fp, "成");
< 	}
< 	if (from<OU) {
< 		foutput_log(fp, "打　");
< 	} else {
< 		foutput_log(fp, "(%02x)", rfrom);
< 	}
< 	if (!is_promotion(m)) {
< 		foutput_log(fp, "　");
< 	}
< }
---
> /// move_to_uci() converts a move to a string in coordinate notation
> /// (g1f3, a7a8q, etc.). The only special case is castling moves, where we
> /// print in the e1g1 notation in normal chess mode, and in e1h1 notation in
> /// Chess960 mode.
229d42
< #else
232,234c45,50
< 	Square from = move_from(m);
< 	Square to = move_to(m);
< 	string promotion;
---
>   Square from = move_from(m);
>   Square to = move_to(m);
>   string promotion;
> 
>   if (m == MOVE_NONE)
>       return "(none)";
236,237c52,53
< 	if (m == MOVE_NONE)
< 		return "(none)";
---
>   if (m == MOVE_NULL)
>       return "0000";
239,240c55,56
< 	if (m == MOVE_NULL)
< 		return "0000";
---
>   if (move_is_short_castle(m) && !chess960)
>       return from == SQ_E1 ? "e1g1" : "e8g8";
242,243c58,59
< 	if (is_castle(m) && !chess960)
< 		to = from + (file_of(to) == FILE_H ? Square(2) : -Square(2));
---
>   if (move_is_long_castle(m) && !chess960)
>       return from == SQ_E1 ? "e1c1" : "e8c8";
245,246c61,62
< 	if (is_promotion(m))
< 		promotion = char(tolower(piece_type_to_char(promotion_piece_type(m))));
---
>   if (move_is_promotion(m))
>       promotion = char(tolower(piece_type_to_char(move_promotion_piece(m))));
248c64
< 	return square_to_string(from) + square_to_string(to) + promotion;
---
>   return square_to_string(from) + square_to_string(to) + promotion;
250d65
< #endif
259,268c74,75
< #if defined(NANOHA)
< 	for (MoveList<MV_LEGAL> ml(pos); !ml.end(); ++ml)
< 		if (str == move_to_uci(ml.move()))
< 			return ml.move();
< 
< 	return MOVE_NONE;
< #else
< 	for (MoveList<MV_LEGAL> ml(pos); !ml.end(); ++ml)
< 		if (str == move_to_uci(ml.move(), pos.is_chess960()))
< 			return ml.move();
---
>   MoveStack mlist[MAX_MOVES];
>   MoveStack* last = generate<MV_LEGAL>(pos, mlist);
270,271c77,81
< 	return MOVE_NONE;
< #endif
---
>   for (MoveStack* cur = mlist; cur != last; cur++)
>       if (str == move_to_uci(cur->move, pos.is_chess960()))
>           return cur->move;
> 
>   return MOVE_NONE;
273a84
> 
275c86
< /// that the move is a legal move for the position. The return value is
---
> /// that the move is a legal move from the position. The return value is
278,279d88
< #if defined(NANOHA)
< // TODO:とりあえず、USI形式で返す
281c90,167
< 	return move_to_uci(m);
---
> 
>   assert(pos.is_ok());
>   assert(move_is_ok(m));
> 
>   MoveStack mlist[MAX_MOVES];
>   Square from = move_from(m);
>   Square to = move_to(m);
>   PieceType pt = pos.type_of_piece_on(from);
>   string san;
> 
>   if (m == MOVE_NONE)
>       return "(none)";
> 
>   if (m == MOVE_NULL)
>       return "(null)";
> 
>   if (move_is_long_castle(m))
>       san = "O-O-O";
>   else if (move_is_short_castle(m))
>       san = "O-O";
>   else
>   {
>       if (pt != PAWN)
>       {
>           san = piece_type_to_char(pt);
> 
>           // Collect all legal moves of piece type 'pt' with destination 'to'
>           MoveStack* last = generate<MV_LEGAL>(pos, mlist);
>           int f = 0, r = 0;
> 
>           for (MoveStack* cur = mlist; cur != last; cur++)
>               if (   move_to(cur->move) == to
>                   && pos.type_of_piece_on(move_from(cur->move)) == pt)
>               {
>                   if (square_file(move_from(cur->move)) == square_file(from))
>                       f++;
> 
>                   if (square_rank(move_from(cur->move)) == square_rank(from))
>                       r++;
>               }
> 
>           assert(f > 0 && r > 0);
> 
>           // Disambiguation if we have more then one piece with destination 'to'
>           if (f == 1 && r > 1)
>               san += file_to_char(square_file(from));
>           else if (f > 1 && r == 1)
>               san += rank_to_char(square_rank(from));
>           else if (f > 1 && r > 1)
>               san += square_to_string(from);
>       }
> 
>       if (pos.move_is_capture(m))
>       {
>           if (pt == PAWN)
>               san += file_to_char(square_file(from));
> 
>           san += 'x';
>       }
> 
>       san += square_to_string(to);
> 
>       if (move_is_promotion(m))
>       {
>           san += '=';
>           san += piece_type_to_char(move_promotion_piece(m));
>       }
>   }
> 
>   // The move gives check? We don't use pos.move_gives_check() here
>   // because we need to test for a mate after the move is done.
>   StateInfo st;
>   pos.do_move(m, st);
>   if (pos.in_check())
>       san += pos.is_mate() ? "#" : "+";
>   pos.undo_move(m);
> 
>   return san;
283,284d168
< #else
< const string move_to_san(Position& pos, Move m) {
286,287d169
< 	if (m == MOVE_NONE)
< 		return "(none)";
289,290c171,245
< 	if (m == MOVE_NULL)
< 		return "(null)";
---
> /// pretty_pv() creates a human-readable string from a position and a PV.
> /// It is used to write search information to the log file (which is created
> /// when the UCI parameter "Use Search Log" is "true").
> 
> const string pretty_pv(Position& pos, int depth, Value score, int time, Move pv[]) {
> 
>   const int64_t K = 1000;
>   const int64_t M = 1000000;
>   const int startColumn = 28;
>   const size_t maxLength = 80 - startColumn;
>   const string lf = string("\n") + string(startColumn, ' ');
> 
>   StateInfo state[PLY_MAX_PLUS_2], *st = state;
>   Move* m = pv;
>   string san;
>   std::stringstream s;
>   size_t length = 0;
> 
>   // First print depth, score, time and searched nodes...
>   s << std::setw(2) << depth
>     << std::setw(8) << score_string(score)
>     << std::setw(8) << time_string(time);
> 
>   if (pos.nodes_searched() < M)
>       s << std::setw(8) << pos.nodes_searched() / 1 << "  ";
>   else if (pos.nodes_searched() < K * M)
>       s << std::setw(7) << pos.nodes_searched() / K << "K  ";
>   else
>       s << std::setw(7) << pos.nodes_searched() / M << "M  ";
> 
>   // ...then print the full PV line in short algebraic notation
>   while (*m != MOVE_NONE)
>   {
>       san = move_to_san(pos, *m);
>       length += san.length() + 1;
> 
>       if (length > maxLength)
>       {
>           length = san.length() + 1;
>           s << lf;
>       }
>       s << san << ' ';
> 
>       pos.do_move(*m++, *st++);
>   }
> 
>   // Restore original position before to leave
>   while (m != pv) pos.undo_move(*--m);
> 
>   return s.str();
> }
> 
> 
> namespace {
> 
>   const string time_string(int millisecs) {
> 
>     const int MSecMinute = 1000 * 60;
>     const int MSecHour   = 1000 * 60 * 60;
> 
>     int hours = millisecs / MSecHour;
>     int minutes =  (millisecs % MSecHour) / MSecMinute;
>     int seconds = ((millisecs % MSecHour) % MSecMinute) / 1000;
> 
>     std::stringstream s;
> 
>     if (hours)
>         s << hours << ':';
> 
>     s << std::setfill('0') << std::setw(2) << minutes << ':' << std::setw(2) << seconds;
>     return s.str();
>   }
> 
> 
>   const string score_string(Value v) {
292c247
< 	assert(is_ok(m));
---
>     std::stringstream s;
294,362c249,254
< 	Bitboard attackers;
< 	bool ambiguousMove, ambiguousFile, ambiguousRank;
< 	Square sq, from = move_from(m);
< 	Square to = move_to(m);
< 	PieceType pt = type_of(pos.piece_on(from));
< 	string san;
< 
< 	if (is_castle(m))
< 		san = (move_to(m) < move_from(m) ? "O-O-O" : "O-O");
< 	else
< 	{
< 		if (pt != PAWN)
< 		{
< 			san = piece_type_to_char(pt);
< 
< 			// Disambiguation if we have more then one piece with destination 'to'
< 			// note that for pawns is not needed because starting file is explicit.
< 			attackers = pos.attackers_to(to) & pos.pieces(pt, pos.side_to_move());
< 			clear_bit(&attackers, from);
< 			ambiguousMove = ambiguousFile = ambiguousRank = false;
< 
< 			while (attackers)
< 			{
< 				sq = pop_1st_bit(&attackers);
< 
< 				if (file_of(sq) == file_of(from))
< 					ambiguousFile = true;
< 
< 				if (rank_of(sq) == rank_of(from))
< 					ambiguousRank = true;
< 
< 				ambiguousMove = true;
< 			}
< 
< 			if (ambiguousMove)
< 			{
< 				if (!ambiguousFile)
< 					san += file_to_char(file_of(from));
< 				else if (!ambiguousRank)
< 					san += rank_to_char(rank_of(from));
< 				else
< 					san += square_to_string(from);
< 			}
< 		}
< 
< 		if (pos.is_capture(m))
< 		{
< 			if (pt == PAWN)
< 				san += file_to_char(file_of(from));
< 
< 			san += 'x';
< 		}
< 
< 		san += square_to_string(to);
< 
< 		if (is_promotion(m))
< 		{
< 			san += '=';
< 			san += piece_type_to_char(promotion_piece_type(m));
< 		}
< 	}
< 
< 	// The move gives check? We don't use pos.move_gives_check() here
< 	// because we need to test for a mate after the move is done.
< 	StateInfo st;
< 	pos.do_move(m, st);
< 	if (pos.in_check())
< 		san += pos.is_mate() ? "#" : "+";
< 	pos.undo_move(m);
---
>     if (v >= VALUE_MATE - 200)
>         s << "#" << (VALUE_MATE - v + 1) / 2;
>     else if (v <= -VALUE_MATE + 200)
>         s << "-#" << (VALUE_MATE + v) / 2;
>     else
>         s << std::setprecision(2) << std::fixed << std::showpos << float(v) / PawnValueMidgame;
364c256,257
< 	return san;
---
>     return s.str();
>   }
366d258
< #endif
########################## movegen.cpp
2c2
<   NanohaMini, a USI shogi(japanese-chess) playing engine derived from Stockfish 2.1
---
>   Stockfish, a UCI chess playing engine derived from Glaurung 2.1
4,5c4
<   Copyright (C) 2008-2010 Marco Costalba, Joona Kiiski, Tord Romstad (Stockfish author)
<   Copyright (C) 2014 Kazuyuki Kawabata
---
>   Copyright (C) 2008-2010 Marco Costalba, Joona Kiiski, Tord Romstad
7c6
<   NanohaMini is free software: you can redistribute it and/or modify
---
>   Stockfish is free software: you can redistribute it and/or modify
12c11
<   NanohaMini is distributed in the hope that it will be useful,
---
>   Stockfish is distributed in the hope that it will be useful,
23,25d21
< #if defined(NANOHA)
< #include <stdio.h>
< #else
27d22
< #endif
29d23
< #include "position.h"
31d24
< #if !defined(NANOHA)
38d30
< #endif
42,46c34,136
< #if !defined(NANOHA)
< 	enum CastlingSide {
< 		KING_SIDE,
< 		QUEEN_SIDE
< 	};
---
>   enum CastlingSide {
>     KING_SIDE,
>     QUEEN_SIDE
>   };
> 
>   template<CastlingSide>
>   MoveStack* generate_castle_moves(const Position&, MoveStack*, Color us);
> 
>   template<Color, MoveType>
>   MoveStack* generate_pawn_moves(const Position&, MoveStack*, Bitboard, Square);
> 
>   template<PieceType Pt>
>   inline MoveStack* generate_discovered_checks(const Position& pos, MoveStack* mlist, Square from) {
> 
>     assert(Pt != QUEEN);
> 
>     Bitboard b = pos.attacks_from<Pt>(from) & pos.empty_squares();
>     if (Pt == KING)
>     {
>         Square ksq = pos.king_square(opposite_color(pos.side_to_move()));
>         b &= ~QueenPseudoAttacks[ksq];
>     }
>     SERIALIZE_MOVES(b);
>     return mlist;
>   }
> 
>   template<PieceType Pt>
>   inline MoveStack* generate_direct_checks(const Position& pos, MoveStack* mlist, Color us,
>                                            Bitboard dc, Square ksq) {
>     assert(Pt != KING);
> 
>     Bitboard checkSqs, b;
>     Square from;
>     const Square* ptr = pos.piece_list_begin(us, Pt);
> 
>     if ((from = *ptr++) == SQ_NONE)
>         return mlist;
> 
>     checkSqs = pos.attacks_from<Pt>(ksq) & pos.empty_squares();
> 
>     do
>     {
>         if (   (Pt == QUEEN  && !(QueenPseudoAttacks[from]  & checkSqs))
>             || (Pt == ROOK   && !(RookPseudoAttacks[from]   & checkSqs))
>             || (Pt == BISHOP && !(BishopPseudoAttacks[from] & checkSqs)))
>             continue;
> 
>         if (dc && bit_is_set(dc, from))
>             continue;
> 
>         b = pos.attacks_from<Pt>(from) & checkSqs;
>         SERIALIZE_MOVES(b);
> 
>     } while ((from = *ptr++) != SQ_NONE);
> 
>     return mlist;
>   }
> 
>   template<>
>   FORCE_INLINE MoveStack* generate_direct_checks<PAWN>(const Position& p, MoveStack* m, Color us, Bitboard dc, Square ksq) {
> 
>     return (us == WHITE ? generate_pawn_moves<WHITE, MV_CHECK>(p, m, dc, ksq)
>                         : generate_pawn_moves<BLACK, MV_CHECK>(p, m, dc, ksq));
>   }
> 
>   template<PieceType Pt, MoveType Type>
>   FORCE_INLINE MoveStack* generate_piece_moves(const Position& p, MoveStack* m, Color us, Bitboard t) {
> 
>     assert(Pt == PAWN);
>     assert(Type == MV_CAPTURE || Type == MV_NON_CAPTURE || Type == MV_EVASION);
> 
>     return (us == WHITE ? generate_pawn_moves<WHITE, Type>(p, m, t, SQ_NONE)
>                         : generate_pawn_moves<BLACK, Type>(p, m, t, SQ_NONE));
>   }
> 
>   template<PieceType Pt>
>   FORCE_INLINE MoveStack* generate_piece_moves(const Position& pos, MoveStack* mlist, Color us, Bitboard target) {
> 
>     Bitboard b;
>     Square from;
>     const Square* ptr = pos.piece_list_begin(us, Pt);
> 
>     if (*ptr != SQ_NONE)
>     {
>         do {
>             from = *ptr;
>             b = pos.attacks_from<Pt>(from) & target;
>             SERIALIZE_MOVES(b);
>         } while (*++ptr != SQ_NONE);
>     }
>     return mlist;
>   }
> 
>   template<>
>   FORCE_INLINE MoveStack* generate_piece_moves<KING>(const Position& pos, MoveStack* mlist, Color us, Bitboard target) {
> 
>     Bitboard b;
>     Square from = pos.king_square(us);
> 
>     b = pos.attacks_from<KING>(from) & target;
>     SERIALIZE_MOVES(b);
>     return mlist;
>   }
48,147d137
< 	template<CastlingSide>
< 	MoveStack* generate_castle_moves(const Position&, MoveStack*, Color us);
< 
< 	template<Color, MoveType>
< 	MoveStack* generate_pawn_moves(const Position&, MoveStack*, Bitboard, Square);
< 
< 	template<PieceType Pt>
< 	inline MoveStack* generate_discovered_checks(const Position& pos, MoveStack* mlist, Square from) {
< 
< 		assert(Pt != QUEEN);
< 		assert(Pt != PAWN);
< 
< 		Bitboard b = pos.attacks_from<Pt>(from) & pos.empty_squares();
< 
< 		if (Pt == KING)
< 		    b &= ~QueenPseudoAttacks[pos.king_square(flip(pos.side_to_move()))];
< 
< 		SERIALIZE_MOVES(b);
< 		return mlist;
< 	}
< 
< 	template<PieceType Pt>
< 	inline MoveStack* generate_direct_checks(const Position& pos, MoveStack* mlist, Color us,
< 	                                         Bitboard dc, Square ksq) {
< 		assert(Pt != KING);
< 		assert(Pt != PAWN);
< 
< 		Bitboard checkSqs, b;
< 		Square from;
< 		const Square* pl = pos.piece_list(us, Pt);
< 
< 		if ((from = *pl++) == SQ_NONE)
< 			return mlist;
< 
< 		checkSqs = pos.attacks_from<Pt>(ksq) & pos.empty_squares();
< 
< 		do
< 		{
< 			if (   (Pt == QUEEN  && !(QueenPseudoAttacks[from]  & checkSqs))
< 			    || (Pt == ROOK   && !(RookPseudoAttacks[from]   & checkSqs))
< 			    || (Pt == BISHOP && !(BishopPseudoAttacks[from] & checkSqs)))
< 				continue;
< 
< 			if (dc && bit_is_set(dc, from))
< 				continue;
< 
< 			b = pos.attacks_from<Pt>(from) & checkSqs;
< 			SERIALIZE_MOVES(b);
< 
< 		} while ((from = *pl++) != SQ_NONE);
< 
< 		return mlist;
< 	}
< 
< 	template<>
< 	FORCE_INLINE MoveStack* generate_direct_checks<PAWN>(const Position& p, MoveStack* m, Color us, Bitboard dc, Square ksq) {
< 
< 		return (us == WHITE ? generate_pawn_moves<WHITE, MV_CHECK>(p, m, dc, ksq)
< 		                    : generate_pawn_moves<BLACK, MV_CHECK>(p, m, dc, ksq));
< 	}
< 
< 	template<PieceType Pt, MoveType Type>
< 	FORCE_INLINE MoveStack* generate_piece_moves(const Position& p, MoveStack* m, Color us, Bitboard t) {
< 
< 		assert(Pt == PAWN);
< 		assert(Type == MV_CAPTURE || Type == MV_NON_CAPTURE || Type == MV_EVASION);
< 
< 		return (us == WHITE ? generate_pawn_moves<WHITE, Type>(p, m, t, SQ_NONE)
< 		                    : generate_pawn_moves<BLACK, Type>(p, m, t, SQ_NONE));
< 	}
< 
< 	template<PieceType Pt>
< 	FORCE_INLINE MoveStack* generate_piece_moves(const Position& pos, MoveStack* mlist, Color us, Bitboard target) {
< 
< 		Bitboard b;
< 		Square from;
< 		const Square* pl = pos.piece_list(us, Pt);
< 
< 		if (*pl != SQ_NONE)
< 		{
< 			do {
< 				from = *pl;
< 				b = pos.attacks_from<Pt>(from) & target;
< 				SERIALIZE_MOVES(b);
< 			} while (*++pl != SQ_NONE);
< 		}
< 		return mlist;
< 	}
< 
< 	template<>
< 	FORCE_INLINE MoveStack* generate_piece_moves<KING>(const Position& pos, MoveStack* mlist, Color us, Bitboard target) {
< 
< 		Bitboard b;
< 		Square from = pos.king_square(us);
< 
< 		b = pos.attacks_from<KING>(from) & target;
< 		SERIALIZE_MOVES(b);
< 		return mlist;
< 	}
< #endif
160,192d149
< #if defined(NANOHA)
< //
< // 汎用バージョン(MV_CAPTURE, MV_NON_EVASION, MV_NON_CAPTURE を想定)
< //
< template<MoveType Type>
< MoveStack* generate(const Position& pos, MoveStack* mlist)
< {
< 	assert(pos.is_ok());
< 	assert(!pos.in_check());
< 
< 	Color us = pos.side_to_move();
< 
< 	assert(Type == MV_CAPTURE || Type == MV_NON_CAPTURE || Type == MV_NON_EVASION);
< 
< 	if (Type == MV_NON_EVASION) {
< 		mlist = (us == BLACK)
< 			? pos.generate_non_evasion<BLACK>(mlist)
< 			: pos.generate_non_evasion<WHITE>(mlist);
< 	} else if (Type == MV_CAPTURE) {
< 		mlist = (us == BLACK)
< 			? pos.generate_capture<BLACK>(mlist)
< 			: pos.generate_capture<WHITE>(mlist);
< 	} else if (Type == MV_NON_CAPTURE) {
< 		mlist = (us == BLACK)
< 			? pos.generate_non_capture<BLACK>(mlist)
< 			: pos.generate_non_capture<WHITE>(mlist);
< 	} else {
< 		assert(false);
< 	}
< 
< 	return mlist;
< }
< #else
196,197c153,154
< 	assert(pos.is_ok());
< 	assert(!pos.in_check());
---
>   assert(pos.is_ok());
>   assert(!pos.in_check());
199,200c156,157
< 	Color us = pos.side_to_move();
< 	Bitboard target;
---
>   Color us = pos.side_to_move();
>   Bitboard target;
202,233c159,188
< 	if (Type == MV_CAPTURE || Type == MV_NON_EVASION)
< 		target = pos.pieces(flip(us));
< 	else if (Type == MV_NON_CAPTURE)
< 		target = pos.empty_squares();
< 	else
< 		assert(false);
< 
< 	if (Type == MV_NON_EVASION)
< 	{
< 		// PAWNは取る手と取らない手は非対称なので、個別に生成する。
< 		mlist = generate_piece_moves<PAWN, MV_CAPTURE>(pos, mlist, us, target);
< 		mlist = generate_piece_moves<PAWN, MV_NON_CAPTURE>(pos, mlist, us, pos.empty_squares());
< 		// その後、移動先を自分以外(取る手と取らない手)にする
< 		target |= pos.empty_squares();
< 	}
< 	else
< 		mlist = generate_piece_moves<PAWN, Type>(pos, mlist, us, target);
< 
< 	mlist = generate_piece_moves<KNIGHT>(pos, mlist, us, target);
< 	mlist = generate_piece_moves<BISHOP>(pos, mlist, us, target);
< 	mlist = generate_piece_moves<ROOK>(pos, mlist, us, target);
< 	mlist = generate_piece_moves<QUEEN>(pos, mlist, us, target);
< 	mlist = generate_piece_moves<KING>(pos, mlist, us, target);
< 
< 	if (Type != MV_CAPTURE && pos.can_castle(us))
< 	{
< 		if (pos.can_castle(us == WHITE ? WHITE_OO : BLACK_OO))
< 			mlist = generate_castle_moves<KING_SIDE>(pos, mlist, us);
< 
< 		if (pos.can_castle(us == WHITE ? WHITE_OOO : BLACK_OOO))
< 			mlist = generate_castle_moves<QUEEN_SIDE>(pos, mlist, us);
< 	}
---
>   if (Type == MV_CAPTURE || Type == MV_NON_EVASION)
>       target = pos.pieces_of_color(opposite_color(us));
>   else if (Type == MV_NON_CAPTURE)
>       target = pos.empty_squares();
>   else
>       assert(false);
> 
>   if (Type == MV_NON_EVASION)
>   {
>       mlist = generate_piece_moves<PAWN, MV_CAPTURE>(pos, mlist, us, target);
>       mlist = generate_piece_moves<PAWN, MV_NON_CAPTURE>(pos, mlist, us, pos.empty_squares());
>       target |= pos.empty_squares();
>   }
>   else
>       mlist = generate_piece_moves<PAWN, Type>(pos, mlist, us, target);
> 
>   mlist = generate_piece_moves<KNIGHT>(pos, mlist, us, target);
>   mlist = generate_piece_moves<BISHOP>(pos, mlist, us, target);
>   mlist = generate_piece_moves<ROOK>(pos, mlist, us, target);
>   mlist = generate_piece_moves<QUEEN>(pos, mlist, us, target);
>   mlist = generate_piece_moves<KING>(pos, mlist, us, target);
> 
>   if (Type != MV_CAPTURE)
>   {
>       if (pos.can_castle_kingside(us))
>           mlist = generate_castle_moves<KING_SIDE>(pos, mlist, us);
> 
>       if (pos.can_castle_queenside(us))
>           mlist = generate_castle_moves<QUEEN_SIDE>(pos, mlist, us);
>   }
235c190
< 	return mlist;
---
>   return mlist;
237d191
< #endif
240d193
< #if defined(NANOHA)
244c197
< #endif
---
> 
248d200
< #if defined(NANOHA)
250,255c202
< MoveStack* generate<MV_CHECK>(const Position& pos, MoveStack* mlist)
< {
< 	assert(pos.is_ok());
< 	assert(!pos.in_check());
< 
< 	Color us = pos.side_to_move();
---
> MoveStack* generate<MV_NON_CAPTURE_CHECK>(const Position& pos, MoveStack* mlist) {
257,258c204,205
< 	bool bUchifudume = false;
< 	mlist = pos.generate_check(us, mlist, bUchifudume);
---
>   assert(pos.is_ok());
>   assert(!pos.in_check());
260c207,236
< 	return mlist;
---
>   Bitboard b, dc;
>   Square from;
>   Color us = pos.side_to_move();
>   Square ksq = pos.king_square(opposite_color(us));
> 
>   assert(pos.piece_on(ksq) == make_piece(opposite_color(us), KING));
> 
>   // Discovered non-capture checks
>   b = dc = pos.discovered_check_candidates(us);
> 
>   while (b)
>   {
>      from = pop_1st_bit(&b);
>      switch (pos.type_of_piece_on(from))
>      {
>       case PAWN:   /* Will be generated togheter with pawns direct checks */     break;
>       case KNIGHT: mlist = generate_discovered_checks<KNIGHT>(pos, mlist, from); break;
>       case BISHOP: mlist = generate_discovered_checks<BISHOP>(pos, mlist, from); break;
>       case ROOK:   mlist = generate_discovered_checks<ROOK>(pos, mlist, from);   break;
>       case KING:   mlist = generate_discovered_checks<KING>(pos, mlist, from);   break;
>       default: assert(false); break;
>      }
>   }
> 
>   // Direct non-capture checks
>   mlist = generate_direct_checks<PAWN>(pos, mlist, us, dc, ksq);
>   mlist = generate_direct_checks<KNIGHT>(pos, mlist, us, dc, ksq);
>   mlist = generate_direct_checks<BISHOP>(pos, mlist, us, dc, ksq);
>   mlist = generate_direct_checks<ROOK>(pos, mlist, us, dc, ksq);
>   return  generate_direct_checks<QUEEN>(pos, mlist, us, dc, ksq);
262,274d237
< template<>
< MoveStack* generate<MV_NON_CAPTURE_CHECK>(const Position& pos, MoveStack* mlist)
< {
< 	MoveStack *last, *cur = mlist;
< 	last = generate<MV_CHECK>(pos, mlist);
< 
< 	// Remove capture moves from the list
< 	while (cur != last) {
< 		if (move_captured(cur->move) == EMP) {
< 			(mlist++)->move = cur->move;
< 		}
< 		cur++;
< 	}
276,277c239
< 	return mlist;
< }
---
> 
281,296c243
< MoveStack* generate<MV_EVASION>(const Position& pos, MoveStack* mlist)
< {
< 	assert(pos.is_ok());
< 	assert(pos.in_check());
< 
< 	Color us = pos.side_to_move();
< #if !defined(NDEBUG)
< 	Square ksq = pos.king_square(us);
< 	assert(pos.piece_on(ksq) == make_piece(us, OU));
< #endif
< 
< 	return (us == BLACK) ? pos.generate_evasion<BLACK>(mlist) : pos.generate_evasion<WHITE>(mlist);
< }
< #else
< template<>
< MoveStack* generate<MV_NON_CAPTURE_CHECK>(const Position& pos, MoveStack* mlist) {
---
> MoveStack* generate<MV_EVASION>(const Position& pos, MoveStack* mlist) {
298c245,246
< 	assert(!pos.in_check());
---
>   assert(pos.is_ok());
>   assert(pos.in_check());
300,329c248,303
< 	Bitboard b, dc;
< 	Square from;
< 	Color us = pos.side_to_move();
< 	Square ksq = pos.king_square(flip(us));
< 
< 	assert(pos.piece_on(ksq) == make_piece(flip(us), KING));
< 
< 	// Discovered non-capture checks
< 	b = dc = pos.discovered_check_candidates();
< 
< 	while (b)
< 	{
< 		from = pop_1st_bit(&b);
< 		switch (type_of(pos.piece_on(from)))
< 		{
< 		 case PAWN:   /* Will be generated togheter with pawns direct checks */     break;
< 		 case KNIGHT: mlist = generate_discovered_checks<KNIGHT>(pos, mlist, from); break;
< 		 case BISHOP: mlist = generate_discovered_checks<BISHOP>(pos, mlist, from); break;
< 		 case ROOK:   mlist = generate_discovered_checks<ROOK>(pos, mlist, from);   break;
< 		 case KING:   mlist = generate_discovered_checks<KING>(pos, mlist, from);   break;
< 		 default: assert(false); break;
< 		}
< 	}
< 
< 	// Direct non-capture checks
< 	mlist = generate_direct_checks<PAWN>(pos, mlist, us, dc, ksq);
< 	mlist = generate_direct_checks<KNIGHT>(pos, mlist, us, dc, ksq);
< 	mlist = generate_direct_checks<BISHOP>(pos, mlist, us, dc, ksq);
< 	mlist = generate_direct_checks<ROOK>(pos, mlist, us, dc, ksq);
< 	return  generate_direct_checks<QUEEN>(pos, mlist, us, dc, ksq);
---
>   Bitboard b, target;
>   Square from, checksq;
>   int checkersCnt = 0;
>   Color us = pos.side_to_move();
>   Square ksq = pos.king_square(us);
>   Bitboard checkers = pos.checkers();
>   Bitboard sliderAttacks = EmptyBoardBB;
> 
>   assert(pos.piece_on(ksq) == make_piece(us, KING));
>   assert(checkers);
> 
>   // Find squares attacked by slider checkers, we will remove
>   // them from the king evasions set so to early skip known
>   // illegal moves and avoid an useless legality check later.
>   b = checkers;
>   do
>   {
>       checkersCnt++;
>       checksq = pop_1st_bit(&b);
> 
>       assert(pos.color_of_piece_on(checksq) == opposite_color(us));
> 
>       switch (pos.type_of_piece_on(checksq))
>       {
>       case BISHOP: sliderAttacks |= BishopPseudoAttacks[checksq]; break;
>       case ROOK:   sliderAttacks |= RookPseudoAttacks[checksq];   break;
>       case QUEEN:
>           // In case of a queen remove also squares attacked in the other direction to
>           // avoid possible illegal moves when queen and king are on adjacent squares.
>           if (RookPseudoAttacks[checksq] & (1ULL << ksq))
>               sliderAttacks |= RookPseudoAttacks[checksq] | pos.attacks_from<BISHOP>(checksq);
>           else
>               sliderAttacks |= BishopPseudoAttacks[checksq] | pos.attacks_from<ROOK>(checksq);
>       default:
>           break;
>       }
>   } while (b);
> 
>   // Generate evasions for king, capture and non capture moves
>   b = pos.attacks_from<KING>(ksq) & ~pos.pieces_of_color(us) & ~sliderAttacks;
>   from = ksq;
>   SERIALIZE_MOVES(b);
> 
>   // Generate evasions for other pieces only if not double check
>   if (checkersCnt > 1)
>       return mlist;
> 
>   // Find squares where a blocking evasion or a capture of the
>   // checker piece is possible.
>   target = squares_between(checksq, ksq) | checkers;
> 
>   mlist = generate_piece_moves<PAWN, MV_EVASION>(pos, mlist, us, target);
>   mlist = generate_piece_moves<KNIGHT>(pos, mlist, us, target);
>   mlist = generate_piece_moves<BISHOP>(pos, mlist, us, target);
>   mlist = generate_piece_moves<ROOK>(pos, mlist, us, target);
>   return  generate_piece_moves<QUEEN>(pos, mlist, us, target);
333,334c307,308
< /// generate_evasions() generates all pseudo-legal check evasions when
< /// the side to move is in check. Returns a pointer to the end of the move list.
---
> /// generate<MV_LEGAL / MV_PSEUDO_LEGAL> computes a complete list of legal
> /// or pseudo-legal moves in the current position.
336c310
< MoveStack* generate<MV_EVASION>(const Position& pos, MoveStack* mlist) {
---
> MoveStack* generate<MV_PSEUDO_LEGAL>(const Position& pos, MoveStack* mlist) {
338c312
< 	assert(pos.in_check());
---
>   assert(pos.is_ok());
340,400c314,315
< 	Bitboard b, target;
< 	Square from, checksq;
< 	int checkersCnt = 0;
< 	Color us = pos.side_to_move();
< 	Square ksq = pos.king_square(us);
< 	Bitboard checkers = pos.checkers();
< 	Bitboard sliderAttacks = EmptyBoardBB;
< 
< 	assert(pos.piece_on(ksq) == make_piece(us, KING));
< 	assert(checkers);
< 
< 	// Find squares attacked by slider checkers, we will remove
< 	// them from the king evasions set so to early skip known
< 	// illegal moves and avoid an useless legality check later.
< 	b = checkers;
< 	do
< 	{
< 		checkersCnt++;
< 		checksq = pop_1st_bit(&b);
< 
< 		assert(color_of(pos.piece_on(checksq)) == flip(us));
< 
< 		switch (type_of(pos.piece_on(checksq)))
< 		{
< 		case BISHOP: sliderAttacks |= BishopPseudoAttacks[checksq]; break;
< 		case ROOK:   sliderAttacks |= RookPseudoAttacks[checksq];   break;
< 		case QUEEN:
< 			// If queen and king are far we can safely remove all the squares attacked
< 			// in the other direction becuase are not reachable by the king anyway.
< 			if (squares_between(ksq, checksq) || (RookPseudoAttacks[checksq] & (1ULL << ksq)))
< 				sliderAttacks |= QueenPseudoAttacks[checksq];
< 
< 			// Otherwise, if king and queen are adjacent and on a diagonal line, we need to
< 			// use real rook attacks to check if king is safe to move in the other direction.
< 			// For example: king in B2, queen in A1 a knight in B1, and we can safely move to C1.
< 			else
< 				sliderAttacks |= BishopPseudoAttacks[checksq] | pos.attacks_from<ROOK>(checksq);
< 
< 		default:
< 			break;
< 		}
< 	} while (b);
< 
< 	// Generate evasions for king, capture and non capture moves
< 	b = pos.attacks_from<KING>(ksq) & ~pos.pieces(us) & ~sliderAttacks;
< 	from = ksq;
< 	SERIALIZE_MOVES(b);
< 
< 	// Generate evasions for other pieces only if not double check
< 	if (checkersCnt > 1)
< 		return mlist;
< 
< 	// Find squares where a blocking evasion or a capture of the
< 	// checker piece is possible.
< 	target = squares_between(checksq, ksq) | checkers;
< 
< 	mlist = generate_piece_moves<PAWN, MV_EVASION>(pos, mlist, us, target);
< 	mlist = generate_piece_moves<KNIGHT>(pos, mlist, us, target);
< 	mlist = generate_piece_moves<BISHOP>(pos, mlist, us, target);
< 	mlist = generate_piece_moves<ROOK>(pos, mlist, us, target);
< 	return  generate_piece_moves<QUEEN>(pos, mlist, us, target);
---
>   return pos.in_check() ? generate<MV_EVASION>(pos, mlist)
>                         : generate<MV_NON_EVASION>(pos, mlist);
402,405d316
< #endif
< 
< 
< /// generate<MV_LEGAL> computes a complete list of legal moves in the current position
410,425c321,326
< #if defined(NANOHA)
< 	return pos.in_check() ? generate<MV_EVASION>(pos, mlist)
< 	                      : generate<MV_NON_EVASION>(pos, mlist);
< #else
< 	MoveStack *last, *cur = mlist;
< 	Bitboard pinned = pos.pinned_pieces();
< 
< 	last = pos.in_check() ? generate<MV_EVASION>(pos, mlist)
< 	                      : generate<MV_NON_EVASION>(pos, mlist);
< 
< 	// Remove illegal moves from the list
< 	while (cur != last)
< 		if (!pos.pl_move_is_legal(cur->move, pinned))
< 			cur->move = (--last)->move;
< 		else
< 			cur++;
---
>   assert(pos.is_ok());
> 
>   MoveStack *last, *cur = mlist;
>   Bitboard pinned = pos.pinned_pieces(pos.side_to_move());
> 
>   last = generate<MV_PSEUDO_LEGAL>(pos, mlist);
427,428c328,335
< 	return last;
< #endif
---
>   // Remove illegal moves from the list
>   while (cur != last)
>       if (!pos.pl_move_is_legal(cur->move, pinned))
>           cur->move = (--last)->move;
>       else
>           cur++;
> 
>   return last;
432d338
< #if !defined(NANOHA)
434,435d339
< 	template<Square Delta>
< 	inline Bitboard move_pawns(Bitboard p) {
437,636c341,537
< 		return Delta == DELTA_N  ? p << 8 : Delta == DELTA_S  ? p >> 8 :
< 		       Delta == DELTA_NE ? p << 9 : Delta == DELTA_SE ? p >> 7 :
< 		       Delta == DELTA_NW ? p << 7 : Delta == DELTA_SW ? p >> 9 : p;
< 	}
< 
< 	template<MoveType Type, Square Delta>
< 	inline MoveStack* generate_pawn_captures(MoveStack* mlist, Bitboard pawns, Bitboard target) {
< 
< 		const Bitboard TFileABB = (Delta == DELTA_NE || Delta == DELTA_SE ? FileABB : FileHBB);
< 
< 		Bitboard b;
< 		Square to;
< 
< 		// Captures in the a1-h8 (a8-h1 for black) diagonal or in the h1-a8 (h8-a1 for black)
< 		b = move_pawns<Delta>(pawns) & target & ~TFileABB;
< 		SERIALIZE_MOVES_D(b, -Delta);
< 		return mlist;
< 	}
< 
< 	template<MoveType Type, Square Delta>
< 	inline MoveStack* generate_promotions(const Position& pos, MoveStack* mlist, Bitboard pawnsOn7, Bitboard target) {
< 
< 		const Bitboard TFileABB = (Delta == DELTA_NE || Delta == DELTA_SE ? FileABB : FileHBB);
< 
< 		Bitboard b;
< 		Square to;
< 
< 		// Promotions and under-promotions, both captures and non-captures
< 		b = move_pawns<Delta>(pawnsOn7) & target;
< 
< 		if (Delta != DELTA_N && Delta != DELTA_S)
< 			b &= ~TFileABB;
< 
< 		while (b)
< 		{
< 			to = pop_1st_bit(&b);
< 
< 			if (Type == MV_CAPTURE || Type == MV_EVASION)
< 				(*mlist++).move = make_promotion_move(to - Delta, to, QUEEN);
< 
< 			if (Type == MV_NON_CAPTURE || Type == MV_EVASION)
< 			{
< 				(*mlist++).move = make_promotion_move(to - Delta, to, ROOK);
< 				(*mlist++).move = make_promotion_move(to - Delta, to, BISHOP);
< 				(*mlist++).move = make_promotion_move(to - Delta, to, KNIGHT);
< 			}
< 
< 			// This is the only possible under promotion that can give a check
< 			// not already included in the queen-promotion.
< 			if (   Type == MV_CHECK
< 			    && bit_is_set(pos.attacks_from<KNIGHT>(to), pos.king_square(Delta > 0 ? BLACK : WHITE)))
< 				(*mlist++).move = make_promotion_move(to - Delta, to, KNIGHT);
< 			else (void)pos; // Silence a warning under MSVC
< 		}
< 		return mlist;
< 	}
< 
< 	template<Color Us, MoveType Type>
< 	MoveStack* generate_pawn_moves(const Position& pos, MoveStack* mlist, Bitboard target, Square ksq) {
< 
< 		// Calculate our parametrized parameters at compile time, named
< 		// according to the point of view of white side.
< 		const Color    Them      = (Us == WHITE ? BLACK    : WHITE);
< 		const Bitboard TRank7BB  = (Us == WHITE ? Rank7BB  : Rank2BB);
< 		const Bitboard TRank3BB  = (Us == WHITE ? Rank3BB  : Rank6BB);
< 		const Square   UP        = (Us == WHITE ? DELTA_N  : DELTA_S);
< 		const Square   RIGHT_UP  = (Us == WHITE ? DELTA_NE : DELTA_SW);
< 		const Square   LEFT_UP   = (Us == WHITE ? DELTA_NW : DELTA_SE);
< 
< 		Square to;
< 		Bitboard b1, b2, dc1, dc2, pawnPushes, emptySquares;
< 		Bitboard pawns = pos.pieces(PAWN, Us);
< 		Bitboard pawnsOn7 = pawns & TRank7BB;
< 		Bitboard enemyPieces = (Type == MV_CAPTURE ? target : pos.pieces(Them));
< 
< 		// Pre-calculate pawn pushes before changing emptySquares definition
< 		if (Type != MV_CAPTURE)
< 		{
< 			emptySquares = (Type == MV_NON_CAPTURE ? target : pos.empty_squares());
< 			pawnPushes = move_pawns<UP>(pawns & ~TRank7BB) & emptySquares;
< 		}
< 
< 		if (Type == MV_EVASION)
< 		{
< 			emptySquares &= target; // Only blocking squares
< 			enemyPieces  &= target; // Capture only the checker piece
< 		}
< 
< 		// Promotions and underpromotions
< 		if (pawnsOn7)
< 		{
< 			if (Type == MV_CAPTURE)
< 				emptySquares = pos.empty_squares();
< 
< 			pawns &= ~TRank7BB;
< 			mlist = generate_promotions<Type, RIGHT_UP>(pos, mlist, pawnsOn7, enemyPieces);
< 			mlist = generate_promotions<Type, LEFT_UP>(pos, mlist, pawnsOn7, enemyPieces);
< 			mlist = generate_promotions<Type, UP>(pos, mlist, pawnsOn7, emptySquares);
< 		}
< 
< 		// Standard captures
< 		if (Type == MV_CAPTURE || Type == MV_EVASION)
< 		{
< 			mlist = generate_pawn_captures<Type, RIGHT_UP>(mlist, pawns, enemyPieces);
< 			mlist = generate_pawn_captures<Type, LEFT_UP>(mlist, pawns, enemyPieces);
< 		}
< 
< 		// Single and double pawn pushes
< 		if (Type != MV_CAPTURE)
< 		{
< 			b1 = (Type != MV_EVASION ? pawnPushes : pawnPushes & emptySquares);
< 			b2 = move_pawns<UP>(pawnPushes & TRank3BB) & emptySquares;
< 
< 			if (Type == MV_CHECK)
< 			{
< 				// Consider only pawn moves which give direct checks
< 				b1 &= pos.attacks_from<PAWN>(ksq, Them);
< 				b2 &= pos.attacks_from<PAWN>(ksq, Them);
< 
< 				// Add pawn moves which gives discovered check. This is possible only
< 				// if the pawn is not on the same file as the enemy king, because we
< 				// don't generate captures.
< 				if (pawns & target) // For CHECK type target is dc bitboard
< 				{
< 					dc1 = move_pawns<UP>(pawns & target & ~file_bb(ksq)) & emptySquares;
< 					dc2 = move_pawns<UP>(dc1 & TRank3BB) & emptySquares;
< 
< 					b1 |= dc1;
< 					b2 |= dc2;
< 				}
< 			}
< 			SERIALIZE_MOVES_D(b1, -UP);
< 			SERIALIZE_MOVES_D(b2, -UP -UP);
< 		}
< 
< 		// En passant captures
< 		if ((Type == MV_CAPTURE || Type == MV_EVASION) && pos.ep_square() != SQ_NONE)
< 		{
< 			assert(Us != WHITE || rank_of(pos.ep_square()) == RANK_6);
< 			assert(Us != BLACK || rank_of(pos.ep_square()) == RANK_3);
< 
< 			// An en passant capture can be an evasion only if the checking piece
< 			// is the double pushed pawn and so is in the target. Otherwise this
< 			// is a discovery check and we are forced to do otherwise.
< 			if (Type == MV_EVASION && !bit_is_set(target, pos.ep_square() - UP))
< 				return mlist;
< 
< 			b1 = pawns & pos.attacks_from<PAWN>(pos.ep_square(), Them);
< 
< 			assert(b1 != EmptyBoardBB);
< 
< 			while (b1)
< 			{
< 				to = pop_1st_bit(&b1);
< 				(*mlist++).move = make_enpassant_move(to, pos.ep_square());
< 			}
< 		}
< 		return mlist;
< 	}
< 
< 	template<CastlingSide Side>
< 	MoveStack* generate_castle_moves(const Position& pos, MoveStack* mlist, Color us) {
< 
< 		CastleRight f = CastleRight((Side == KING_SIDE ? WHITE_OO : WHITE_OOO) << us);
< 		Color them = flip(us);
< 
< 		// After castling, the rook and king's final positions are exactly the same
< 		// in Chess960 as they would be in standard chess.
< 		Square kfrom = pos.king_square(us);
< 		Square rfrom = pos.castle_rook_square(f);
< 		Square kto = relative_square(us, Side == KING_SIDE ? SQ_G1 : SQ_C1);
< 		Square rto = relative_square(us, Side == KING_SIDE ? SQ_F1 : SQ_D1);
< 
< 		assert(!pos.in_check());
< 		assert(pos.piece_on(kfrom) == make_piece(us, KING));
< 		assert(pos.piece_on(rfrom) == make_piece(us, ROOK));
< 
< 		// Unimpeded rule: All the squares between the king's initial and final squares
< 		// (including the final square), and all the squares between the rook's initial
< 		// and final squares (including the final square), must be vacant except for
< 		// the king and castling rook.
< 		for (Square s = Min(kfrom, kto); s <= Max(kfrom, kto); s++)
< 			if (  (s != kfrom && s != rfrom && !pos.square_is_empty(s))
< 			    ||(pos.attackers_to(s) & pos.pieces(them)))
< 				return mlist;
< 
< 		for (Square s = Min(rfrom, rto); s <= Max(rfrom, rto); s++)
< 			if (s != kfrom && s != rfrom && !pos.square_is_empty(s))
< 				return mlist;
< 
< 		// Because we generate only legal castling moves we need to verify that
< 		// when moving the castling rook we do not discover some hidden checker.
< 		// For instance an enemy queen in SQ_A1 when castling rook is in SQ_B1.
< 		if (pos.is_chess960())
< 		{
< 			Bitboard occ = pos.occupied_squares();
< 			clear_bit(&occ, rfrom);
< 			if (pos.attackers_to(kto, occ) & pos.pieces(them))
< 				return mlist;
< 		}
---
>   template<Square Delta>
>   inline Bitboard move_pawns(Bitboard p) {
> 
>     return Delta == DELTA_N  ? p << 8 : Delta == DELTA_S  ? p >> 8 :
>            Delta == DELTA_NE ? p << 9 : Delta == DELTA_SE ? p >> 7 :
>            Delta == DELTA_NW ? p << 7 : Delta == DELTA_SW ? p >> 9 : p;
>   }
> 
>   template<MoveType Type, Square Delta>
>   inline MoveStack* generate_pawn_captures(MoveStack* mlist, Bitboard pawns, Bitboard target) {
> 
>     const Bitboard TFileABB = (Delta == DELTA_NE || Delta == DELTA_SE ? FileABB : FileHBB);
> 
>     Bitboard b;
>     Square to;
> 
>     // Captures in the a1-h8 (a8-h1 for black) diagonal or in the h1-a8 (h8-a1 for black)
>     b = move_pawns<Delta>(pawns) & target & ~TFileABB;
>     SERIALIZE_MOVES_D(b, -Delta);
>     return mlist;
>   }
> 
>   template<Color Us, MoveType Type, Square Delta>
>   inline MoveStack* generate_promotions(const Position& pos, MoveStack* mlist, Bitboard pawnsOn7, Bitboard target) {
> 
>     const Bitboard TFileABB = (Delta == DELTA_NE || Delta == DELTA_SE ? FileABB : FileHBB);
> 
>     Bitboard b;
>     Square to;
> 
>     // Promotions and under-promotions, both captures and non-captures
>     b = move_pawns<Delta>(pawnsOn7) & target;
> 
>     if (Delta != DELTA_N && Delta != DELTA_S)
>         b &= ~TFileABB;
> 
>     while (b)
>     {
>         to = pop_1st_bit(&b);
> 
>         if (Type == MV_CAPTURE || Type == MV_EVASION)
>             (*mlist++).move = make_promotion_move(to - Delta, to, QUEEN);
> 
>         if (Type == MV_NON_CAPTURE || Type == MV_EVASION)
>         {
>             (*mlist++).move = make_promotion_move(to - Delta, to, ROOK);
>             (*mlist++).move = make_promotion_move(to - Delta, to, BISHOP);
>             (*mlist++).move = make_promotion_move(to - Delta, to, KNIGHT);
>         }
> 
>         // This is the only possible under promotion that can give a check
>         // not already included in the queen-promotion.
>         if (   Type == MV_CHECK
>             && bit_is_set(pos.attacks_from<KNIGHT>(to), pos.king_square(opposite_color(Us))))
>             (*mlist++).move = make_promotion_move(to - Delta, to, KNIGHT);
>         else (void)pos; // Silence a warning under MSVC
>     }
>     return mlist;
>   }
> 
>   template<Color Us, MoveType Type>
>   MoveStack* generate_pawn_moves(const Position& pos, MoveStack* mlist, Bitboard target, Square ksq) {
> 
>     // Calculate our parametrized parameters at compile time, named
>     // according to the point of view of white side.
>     const Color    Them      = (Us == WHITE ? BLACK    : WHITE);
>     const Bitboard TRank7BB  = (Us == WHITE ? Rank7BB  : Rank2BB);
>     const Bitboard TRank3BB  = (Us == WHITE ? Rank3BB  : Rank6BB);
>     const Square   TDELTA_N  = (Us == WHITE ? DELTA_N  : DELTA_S);
>     const Square   TDELTA_NE = (Us == WHITE ? DELTA_NE : DELTA_SE);
>     const Square   TDELTA_NW = (Us == WHITE ? DELTA_NW : DELTA_SW);
> 
>     Square to;
>     Bitboard b1, b2, dc1, dc2, pawnPushes, emptySquares;
>     Bitboard pawns = pos.pieces(PAWN, Us);
>     Bitboard pawnsOn7 = pawns & TRank7BB;
>     Bitboard enemyPieces = (Type == MV_CAPTURE ? target : pos.pieces_of_color(Them));
> 
>     // Pre-calculate pawn pushes before changing emptySquares definition
>     if (Type != MV_CAPTURE)
>     {
>         emptySquares = (Type == MV_NON_CAPTURE ? target : pos.empty_squares());
>         pawnPushes = move_pawns<TDELTA_N>(pawns & ~TRank7BB) & emptySquares;
>     }
> 
>     if (Type == MV_EVASION)
>     {
>         emptySquares &= target; // Only blocking squares
>         enemyPieces  &= target; // Capture only the checker piece
>     }
> 
>     // Promotions and underpromotions
>     if (pawnsOn7)
>     {
>         if (Type == MV_CAPTURE)
>             emptySquares = pos.empty_squares();
> 
>         pawns &= ~TRank7BB;
>         mlist = generate_promotions<Us, Type, TDELTA_NE>(pos, mlist, pawnsOn7, enemyPieces);
>         mlist = generate_promotions<Us, Type, TDELTA_NW>(pos, mlist, pawnsOn7, enemyPieces);
>         mlist = generate_promotions<Us, Type, TDELTA_N >(pos, mlist, pawnsOn7, emptySquares);
>     }
> 
>     // Standard captures
>     if (Type == MV_CAPTURE || Type == MV_EVASION)
>     {
>         mlist = generate_pawn_captures<Type, TDELTA_NE>(mlist, pawns, enemyPieces);
>         mlist = generate_pawn_captures<Type, TDELTA_NW>(mlist, pawns, enemyPieces);
>     }
> 
>     // Single and double pawn pushes
>     if (Type != MV_CAPTURE)
>     {
>         b1 = pawnPushes & emptySquares;
>         b2 = move_pawns<TDELTA_N>(pawnPushes & TRank3BB) & emptySquares;
> 
>         if (Type == MV_CHECK)
>         {
>             // Consider only pawn moves which give direct checks
>             b1 &= pos.attacks_from<PAWN>(ksq, Them);
>             b2 &= pos.attacks_from<PAWN>(ksq, Them);
> 
>             // Add pawn moves which gives discovered check. This is possible only
>             // if the pawn is not on the same file as the enemy king, because we
>             // don't generate captures.
>             if (pawns & target) // For CHECK type target is dc bitboard
>             {
>                 dc1 = move_pawns<TDELTA_N>(pawns & target & ~file_bb(ksq)) & emptySquares;
>                 dc2 = move_pawns<TDELTA_N>(dc1 & TRank3BB) & emptySquares;
> 
>                 b1 |= dc1;
>                 b2 |= dc2;
>             }
>         }
>         SERIALIZE_MOVES_D(b1, -TDELTA_N);
>         SERIALIZE_MOVES_D(b2, -TDELTA_N -TDELTA_N);
>     }
> 
>     // En passant captures
>     if ((Type == MV_CAPTURE || Type == MV_EVASION) && pos.ep_square() != SQ_NONE)
>     {
>         assert(Us != WHITE || square_rank(pos.ep_square()) == RANK_6);
>         assert(Us != BLACK || square_rank(pos.ep_square()) == RANK_3);
> 
>         // An en passant capture can be an evasion only if the checking piece
>         // is the double pushed pawn and so is in the target. Otherwise this
>         // is a discovery check and we are forced to do otherwise.
>         if (Type == MV_EVASION && !bit_is_set(target, pos.ep_square() - TDELTA_N))
>             return mlist;
> 
>         b1 = pawns & pos.attacks_from<PAWN>(pos.ep_square(), Them);
> 
>         assert(b1 != EmptyBoardBB);
> 
>         while (b1)
>         {
>             to = pop_1st_bit(&b1);
>             (*mlist++).move = make_ep_move(to, pos.ep_square());
>         }
>     }
>     return mlist;
>   }
> 
>   template<CastlingSide Side>
>   MoveStack* generate_castle_moves(const Position& pos, MoveStack* mlist, Color us) {
> 
>     Color them = opposite_color(us);
>     Square ksq = pos.king_square(us);
> 
>     assert(pos.piece_on(ksq) == make_piece(us, KING));
> 
>     Square rsq = (Side == KING_SIDE ? pos.initial_kr_square(us) : pos.initial_qr_square(us));
>     Square s1 = relative_square(us, Side == KING_SIDE ? SQ_G1 : SQ_C1);
>     Square s2 = relative_square(us, Side == KING_SIDE ? SQ_F1 : SQ_D1);
>     Square s;
>     bool illegal = false;
> 
>     assert(pos.piece_on(rsq) == make_piece(us, ROOK));
> 
>     // It is a bit complicated to correctly handle Chess960
>     for (s = Min(ksq, s1); s <= Max(ksq, s1); s++)
>         if (  (s != ksq && s != rsq && pos.square_is_occupied(s))
>             ||(pos.attackers_to(s) & pos.pieces_of_color(them)))
>             illegal = true;
> 
>     for (s = Min(rsq, s2); s <= Max(rsq, s2); s++)
>         if (s != ksq && s != rsq && pos.square_is_occupied(s))
>             illegal = true;
> 
>     if (   Side == QUEEN_SIDE
>         && square_file(rsq) == FILE_B
>         && (   pos.piece_on(relative_square(us, SQ_A1)) == make_piece(them, ROOK)
>             || pos.piece_on(relative_square(us, SQ_A1)) == make_piece(them, QUEEN)))
>         illegal = true;
> 
>     if (!illegal)
>         (*mlist++).move = make_castle_move(ksq, rsq);
638c539,540
< 		(*mlist++).move = make_castle_move(kfrom, rfrom);
---
>     return mlist;
>   }
640,641d541
< 		return mlist;
< 	}
643d542
< #endif
########################## movepick.cpp
2c2
<   NanohaMini, a USI shogi(japanese-chess) playing engine derived from Stockfish 2.1
---
>   Stockfish, a UCI chess playing engine derived from Glaurung 2.1
4,5c4
<   Copyright (C) 2008-2010 Marco Costalba, Joona Kiiski, Tord Romstad (Stockfish author)
<   Copyright (C) 2014 Kazuyuki Kawabata
---
>   Copyright (C) 2008-2010 Marco Costalba, Joona Kiiski, Tord Romstad
7c6
<   NanohaMini is free software: you can redistribute it and/or modify
---
>   Stockfish is free software: you can redistribute it and/or modify
13c12
<   NanohaMini is distributed in the hope that it will be useful,
---
>   Stockfish is distributed in the hope that it will be useful,
22d20
< #include <algorithm>
32,71c30,46
< 	enum MovegenPhase {
< 		PH_TT_MOVE,       // Transposition table move
< 		PH_GOOD_CAPTURES, // Queen promotions and captures with SEE values >= captureThreshold (captureThreshold <= 0)
< 		PH_GOOD_PROBCUT,  // Queen promotions and captures with SEE values > captureThreshold (captureThreshold >= 0)
< 		PH_KILLERS,       // Killer moves from the current ply
< 		PH_NONCAPTURES_1, // Non-captures and underpromotions with positive score
< 		PH_NONCAPTURES_2, // Non-captures and underpromotions with non-positive score
< 		PH_BAD_CAPTURES,  // Queen promotions and captures with SEE values < captureThreshold (captureThreshold <= 0)
< 		PH_EVASIONS,      // Check evasions
< 		PH_QCAPTURES,     // Captures in quiescence search
< 		PH_QRECAPTURES,   // Recaptures in quiescence search
< 		PH_QCHECKS,       // Non-capture checks in quiescence search
< 		PH_STOP
< 	};
< 
< 	CACHE_LINE_ALIGNMENT
< 	const uint8_t MainSearchTable[] = { PH_TT_MOVE, PH_GOOD_CAPTURES, PH_KILLERS, PH_NONCAPTURES_1, PH_NONCAPTURES_2, PH_BAD_CAPTURES, PH_STOP };
< 	const uint8_t EvasionTable[] = { PH_TT_MOVE, PH_EVASIONS, PH_STOP };
< #if defined(NANOHA)
< 	// 静止探索で王手生成を止めてみる.
< 	const uint8_t QsearchWithChecksTable[] = { PH_TT_MOVE, PH_QCAPTURES, PH_STOP };
< #else
< 	const uint8_t QsearchWithChecksTable[] = { PH_TT_MOVE, PH_QCAPTURES, PH_QCHECKS, PH_STOP };
< #endif
< 	const uint8_t QsearchWithoutChecksTable[] = { PH_TT_MOVE, PH_QCAPTURES, PH_STOP };
< 	const uint8_t QsearchRecapturesTable[] = { PH_TT_MOVE, PH_QRECAPTURES, PH_STOP };
< 	const uint8_t ProbCutTable[] = { PH_TT_MOVE, PH_GOOD_PROBCUT, PH_STOP };
< 
< 	// Unary predicate used by std::partition to split positive scores from remaining
< 	// ones so to sort separately the two sets, and with the second sort delayed.
< 	inline bool has_positive_score(const MoveStack& move) { return move.score > 0; }
< 
< 	// Picks and pushes to the front the best move in range [firstMove, lastMove),
< 	// it is faster than sorting all the moves in advance when moves are few, as
< 	// normally are the possible captures.
< 	inline MoveStack* pick_best(MoveStack* firstMove, MoveStack* lastMove)
< 	{
< 		std::swap(*firstMove, *std::max_element(firstMove, lastMove));
< 		return firstMove;
< 	}
---
>   enum MovegenPhase {
>     PH_TT_MOVES,      // Transposition table move and mate killer
>     PH_GOOD_CAPTURES, // Queen promotions and captures with SEE values >= 0
>     PH_KILLERS,       // Killer moves from the current ply
>     PH_NONCAPTURES,   // Non-captures and underpromotions
>     PH_BAD_CAPTURES,  // Queen promotions and captures with SEE values < 0
>     PH_EVASIONS,      // Check evasions
>     PH_QCAPTURES,     // Captures in quiescence search
>     PH_QCHECKS,       // Non-capture checks in quiescence search
>     PH_STOP
>   };
> 
>   CACHE_LINE_ALIGNMENT
>   const uint8_t MainSearchTable[] = { PH_TT_MOVES, PH_GOOD_CAPTURES, PH_KILLERS, PH_NONCAPTURES, PH_BAD_CAPTURES, PH_STOP };
>   const uint8_t EvasionTable[] = { PH_TT_MOVES, PH_EVASIONS, PH_STOP };
>   const uint8_t QsearchWithChecksTable[] = { PH_TT_MOVES, PH_QCAPTURES, PH_QCHECKS, PH_STOP };
>   const uint8_t QsearchWithoutChecksTable[] = { PH_TT_MOVES, PH_QCAPTURES, PH_STOP };
74c49,51
< /// Constructors for the MovePicker class. As arguments we pass information
---
> 
> /// Constructor for the MovePicker class. Apart from the position for which
> /// it is asked to pick legal moves, MovePicker also wants some information
81,111c58,83
<                        SearchStack* ss, Value beta) : pos(p), H(h), depth(d) {
< 	captureThreshold = 0;
< 	badCaptures = moves + MAX_MOVES;
< 
< 	assert(d > DEPTH_ZERO);
< 
< 	if (p.in_check())
< 	{
< 		killers[0].move = killers[1].move = MOVE_NONE;
< 		phasePtr = EvasionTable;
< 	}
< 	else
< 	{
< 		killers[0].move = ss->killers[0];
< 		killers[1].move = ss->killers[1];
< 
< 		// Consider sligtly negative captures as good if at low
< 		// depth and far from beta.
< 		if (ss && ss->eval < beta - PawnValueMidgame && d < 3 * ONE_PLY)
< 			captureThreshold = -PawnValueMidgame;
< 
< 		phasePtr = MainSearchTable;
< 	}
< 
< 	ttMove = (ttm && pos.is_pseudo_legal(ttm) ? ttm : MOVE_NONE);
< 	phasePtr += int(ttMove == MOVE_NONE) - 1;
< 	go_next_phase();
< }
< 
< MovePicker::MovePicker(const Position& p, Move ttm, Depth d, const History& h, Square recaptureSq)
<                       : pos(p), H(h) {
---
>                        SearchStack* ss, Value beta) : pos(p), H(h) {
>   int searchTT = ttm;
>   ttMoves[0].move = ttm;
>   badCaptureThreshold = 0;
>   badCaptures = moves + MAX_MOVES;
> 
>   assert(d > DEPTH_ZERO);
> 
>   pinned = p.pinned_pieces(pos.side_to_move());
> 
>   if (p.in_check())
>   {
>       ttMoves[1].move = killers[0].move = killers[1].move = MOVE_NONE;
>       phasePtr = EvasionTable;
>   }
>   else
>   {
>       ttMoves[1].move = (ss->mateKiller == ttm) ? MOVE_NONE : ss->mateKiller;
>       searchTT |= ttMoves[1].move;
>       killers[0].move = ss->killers[0];
>       killers[1].move = ss->killers[1];
> 
>       // Consider sligtly negative captures as good if at low
>       // depth and far from beta.
>       if (ss && ss->eval < beta - PawnValueMidgame && d < 3 * ONE_PLY)
>           badCaptureThreshold = -PawnValueMidgame;
113c85,86
< 	assert(d <= DEPTH_ZERO);
---
>       phasePtr = MainSearchTable;
>   }
115,138c88,89
< 	if (p.in_check())
< 		phasePtr = EvasionTable;
< 	else if (d >= DEPTH_QS_CHECKS)
< 		phasePtr = QsearchWithChecksTable;
< 	else if (d >= DEPTH_QS_RECAPTURES)
< 	{
< 		phasePtr = QsearchWithoutChecksTable;
< 
< 		// Skip TT move if is not a capture or a promotion, this avoids
< 		// qsearch tree explosion due to a possible perpetual check or
< 		// similar rare cases when TT table is full.
< 		if (ttm != MOVE_NONE && !pos.is_capture_or_promotion(ttm))
< 			ttm = MOVE_NONE;
< 	}
< 	else
< 	{
< 		phasePtr = QsearchRecapturesTable;
< 		recaptureSquare = recaptureSq;
< 		ttm = MOVE_NONE;
< 	}
< 
< 	ttMove = (ttm && pos.is_pseudo_legal(ttm) ? ttm : MOVE_NONE);
< 	phasePtr += int(ttMove == MOVE_NONE) - 1;
< 	go_next_phase();
---
>   phasePtr += int(!searchTT) - 1;
>   go_next_phase();
141,144c92,115
< MovePicker::MovePicker(const Position& p, Move ttm, const History& h, PieceType parentCapture)
<                        : pos(p), H(h) {
< 
< 	assert (!pos.in_check());
---
> MovePicker::MovePicker(const Position& p, Move ttm, Depth d, const History& h)
>                       : pos(p), H(h) {
>   int searchTT = ttm;
>   ttMoves[0].move = ttm;
>   ttMoves[1].move = MOVE_NONE;
> 
>   assert(d <= DEPTH_ZERO);
> 
>   pinned = p.pinned_pieces(pos.side_to_move());
> 
>   if (p.in_check())
>       phasePtr = EvasionTable;
>   else if (d >= DEPTH_QS_CHECKS)
>       phasePtr = QsearchWithChecksTable;
>   else
>   {
>       phasePtr = QsearchWithoutChecksTable;
> 
>       // Skip TT move if is not a capture or a promotion, this avoids
>       // qsearch tree explosion due to a possible perpetual check or
>       // similar rare cases when TT table is full.
>       if (ttm != MOVE_NONE && !pos.move_is_capture_or_promotion(ttm))
>           searchTT = ttMoves[0].move = MOVE_NONE;
>   }
146,156c117,118
< 	// In ProbCut we consider only captures better than parent's move
< 	captureThreshold = piece_value_midgame(Piece(parentCapture));
< 	phasePtr = ProbCutTable;
< 
< 	if (   ttm != MOVE_NONE
< 	    && (!pos.is_capture(ttm) ||  pos.see(ttm) <= captureThreshold))
< 		ttm = MOVE_NONE;
< 
< 	ttMove = (ttm && pos.is_pseudo_legal(ttm) ? ttm : MOVE_NONE);
< 	phasePtr += int(ttMove == MOVE_NONE) - 1;
< 	go_next_phase();
---
>   phasePtr += int(!searchTT) - 1;
>   go_next_phase();
165,231c127,181
< 	curMove = moves;
< 	phase = *(++phasePtr);
< 	switch (phase) {
< 
< 	case PH_TT_MOVE:
< 		lastMove = curMove + 1;
< 		return;
< 
< 	case PH_GOOD_CAPTURES:
< 	case PH_GOOD_PROBCUT:
< 		lastMove = generate<MV_CAPTURE>(pos, moves);
< 		score_captures();
< 		return;
< 
< 	case PH_KILLERS:
< 		curMove = killers;
< 		lastMove = curMove + 2;
< 		return;
< 
< 	case PH_NONCAPTURES_1:
< 		lastNonCapture = lastMove = generate<MV_NON_CAPTURE>(pos, moves);
< 		score_noncaptures();
< 		lastMove = std::partition(curMove, lastMove, has_positive_score);
< 		sort<MoveStack>(curMove, lastMove);
< 		return;
< 
< 	case PH_NONCAPTURES_2:
< 		curMove = lastMove;
< 		lastMove = lastNonCapture;
< 		if (depth >= 3 * ONE_PLY)
< 			sort<MoveStack>(curMove, lastMove);
< 		return;
< 
< 	case PH_BAD_CAPTURES:
< 		// Bad captures SEE value is already calculated so just pick
< 		// them in order to get SEE move ordering.
< 		curMove = badCaptures;
< 		lastMove = moves + MAX_MOVES;
< 		return;
< 
< 	case PH_EVASIONS:
< 		assert(pos.in_check());
< 		lastMove = generate<MV_EVASION>(pos, moves);
< 		score_evasions();
< 		return;
< 
< 	case PH_QCAPTURES:
< 		lastMove = generate<MV_CAPTURE>(pos, moves);
< 		score_captures();
< 		return;
< 
< 	case PH_QRECAPTURES:
< 		lastMove = generate<MV_CAPTURE>(pos, moves);
< 		return;
< 
< 	case PH_QCHECKS:
< 		lastMove = generate<MV_NON_CAPTURE_CHECK>(pos, moves);
< 		return;
< 
< 	case PH_STOP:
< 		lastMove = curMove + 1; // Avoid another go_next_phase() call
< 		return;
< 
< 	default:
< 		assert(false);
< 		return;
< 	}
---
>   curMove = moves;
>   phase = *(++phasePtr);
>   switch (phase) {
> 
>   case PH_TT_MOVES:
>       curMove = ttMoves;
>       lastMove = curMove + 2;
>       return;
> 
>   case PH_GOOD_CAPTURES:
>       lastMove = generate<MV_CAPTURE>(pos, moves);
>       score_captures();
>       return;
> 
>   case PH_KILLERS:
>       curMove = killers;
>       lastMove = curMove + 2;
>       return;
> 
>   case PH_NONCAPTURES:
>       lastMove = generate<MV_NON_CAPTURE>(pos, moves);
>       score_noncaptures();
>       sort_moves(moves, lastMove, &lastGoodNonCapture);
>       return;
> 
>   case PH_BAD_CAPTURES:
>       // Bad captures SEE value is already calculated so just pick
>       // them in order to get SEE move ordering.
>       curMove = badCaptures;
>       lastMove = moves + MAX_MOVES;
>       return;
> 
>   case PH_EVASIONS:
>       assert(pos.in_check());
>       lastMove = generate<MV_EVASION>(pos, moves);
>       score_evasions();
>       return;
> 
>   case PH_QCAPTURES:
>       lastMove = generate<MV_CAPTURE>(pos, moves);
>       score_captures();
>       return;
> 
>   case PH_QCHECKS:
>       lastMove = generate<MV_NON_CAPTURE_CHECK>(pos, moves);
>       return;
> 
>   case PH_STOP:
>       lastMove = curMove + 1; // Avoid another go_next_phase() call
>       return;
> 
>   default:
>       assert(false);
>       return;
>   }
241,269c191,215
< 	// Winning and equal captures in the main search are ordered by MVV/LVA.
< 	// Suprisingly, this appears to perform slightly better than SEE based
< 	// move ordering. The reason is probably that in a position with a winning
< 	// capture, capturing a more valuable (but sufficiently defended) piece
< 	// first usually doesn't hurt. The opponent will have to recapture, and
< 	// the hanging piece will still be hanging (except in the unusual cases
< 	// where it is possible to recapture with the hanging piece). Exchanging
< 	// big pieces before capturing a hanging piece probably helps to reduce
< 	// the subtree size.
< 	// In main search we want to push captures with negative SEE values to
< 	// badCaptures[] array, but instead of doing it now we delay till when
< 	// the move has been picked up in pick_move_from_list(), this way we save
< 	// some SEE calls in case we get a cutoff (idea from Pablo Vazquez).
< 	Move m;
< 
< 	// Use MVV/LVA ordering
< 	for (MoveStack* cur = moves; cur != lastMove; cur++)
< 	{
< 		m = cur->move;
< 		cur->score =  piece_value_midgame(pos.piece_on(move_to(m)))
< 		            - type_of(pos.piece_on(move_from(m)));
< 
< 		if (is_promotion(m))
< #if defined(NANOHA)
< 			cur->score += piece_value_midgame(Piece(move_piece(m) | PROMOTED));
< #else
< 			cur->score += piece_value_midgame(Piece(promotion_piece_type(m)));
< #endif
< 	}
---
>   // Winning and equal captures in the main search are ordered by MVV/LVA.
>   // Suprisingly, this appears to perform slightly better than SEE based
>   // move ordering. The reason is probably that in a position with a winning
>   // capture, capturing a more valuable (but sufficiently defended) piece
>   // first usually doesn't hurt. The opponent will have to recapture, and
>   // the hanging piece will still be hanging (except in the unusual cases
>   // where it is possible to recapture with the hanging piece). Exchanging
>   // big pieces before capturing a hanging piece probably helps to reduce
>   // the subtree size.
>   // In main search we want to push captures with negative SEE values to
>   // badCaptures[] array, but instead of doing it now we delay till when
>   // the move has been picked up in pick_move_from_list(), this way we save
>   // some SEE calls in case we get a cutoff (idea from Pablo Vazquez).
>   Move m;
> 
>   // Use MVV/LVA ordering
>   for (MoveStack* cur = moves; cur != lastMove; cur++)
>   {
>       m = cur->move;
>       if (move_is_promotion(m))
>           cur->score = QueenValueMidgame;
>       else
>           cur->score =  pos.midgame_value_of_piece_on(move_to(m))
>                       - pos.type_of_piece_on(move_from(m));
>   }
274c220,221
< 	Move m;
---
>   Move m;
>   Square from;
276,287c223,228
< 	for (MoveStack* cur = moves; cur != lastMove; cur++)
< 	{
< 		m = cur->move;
< #if defined(NANOHA)
< 		assert(m != MOVE_NULL);
< 		Piece piece = is_promotion(m) ? Piece(move_piece(m) | PROMOTED) : move_piece(m);
< 		cur->score = H.value(piece, move_to(m));
< #else
< 		Square from = move_from(m);
< 		cur->score = H.value(pos.piece_on(from), move_to(m));
< #endif
< 	}
---
>   for (MoveStack* cur = moves; cur != lastMove; cur++)
>   {
>       m = cur->move;
>       from = move_from(m);
>       cur->score = H.value(pos.piece_on(from), move_to(m));
>   }
291,324c232,253
< 	// Try good captures ordered by MVV/LVA, then non-captures if
< 	// destination square is not under attack, ordered by history
< 	// value, and at the end bad-captures and non-captures with a
< 	// negative SEE. This last group is ordered by the SEE score.
< 	Move m;
< 	int seeScore;
< 
< 	// Skip if we don't have at least two moves to order
< 	if (lastMove < moves + 2)
< 		return;
< 
< 	for (MoveStack* cur = moves; cur != lastMove; cur++)
< 	{
< 		m = cur->move;
< 		if ((seeScore = pos.see_sign(m)) < 0)
< 			cur->score = seeScore - History::MaxValue; // Be sure we are at the bottom
< 		else if (pos.is_capture(m))
< #if defined(NANOHA)
< 			cur->score =  piece_value_midgame(pos.piece_on(move_to(m)))
< 			            - type_of(move_piece(m)) + History::MaxValue;
< #else
< 			cur->score =  piece_value_midgame(pos.piece_on(move_to(m)))
< 			            - type_of(pos.piece_on(move_from(m))) + History::MaxValue;
< #endif
< 		else
< #if defined(NANOHA)
< 		{
< 			Piece piece = is_promotion(m) ? Piece(move_piece(m) | PROMOTED) : move_piece(m);
< 			cur->score = H.value(piece, move_to(m));
< 		}
< #else
< 		cur->score = H.value(pos.piece_on(move_from(m)), move_to(m));
< #endif
< 	}
---
>   // Try good captures ordered by MVV/LVA, then non-captures if
>   // destination square is not under attack, ordered by history
>   // value, and at the end bad-captures and non-captures with a
>   // negative SEE. This last group is ordered by the SEE score.
>   Move m;
>   int seeScore;
> 
>   // Skip if we don't have at least two moves to order
>   if (lastMove < moves + 2)
>       return;
> 
>   for (MoveStack* cur = moves; cur != lastMove; cur++)
>   {
>       m = cur->move;
>       if ((seeScore = pos.see_sign(m)) < 0)
>           cur->score = seeScore - History::MaxValue; // Be sure we are at the bottom
>       else if (pos.move_is_capture(m))
>           cur->score =  pos.midgame_value_of_piece_on(move_to(m))
>                       - pos.type_of_piece_on(move_from(m)) + History::MaxValue;
>       else
>           cur->score = H.value(pos.piece_on(move_from(m)), move_to(m));
>   }
328c257
< /// class. It returns a new pseudo legal move every time it is called, until there
---
> /// class. It returns a new legal move every time it is called, until there
336c265
< 	Move move;
---
>   Move move;
338,422c267,349
< 	while (true)
< 	{
< 		while (curMove == lastMove)
< 			go_next_phase();
< 
< 		switch (phase) {
< 
< 		case PH_TT_MOVE:
< 			curMove++;
< 			return ttMove;
< 			break;
< 
< 		case PH_GOOD_CAPTURES:
< 			move = pick_best(curMove++, lastMove)->move;
< 			if (   move != ttMove)
< 			{
< 				assert(captureThreshold <= 0); // Otherwise we must use see instead of see_sign
< 
< 				// Check for a non negative SEE now
< 				int seeValue = pos.see_sign(move);
< 				if (seeValue >= captureThreshold)
< 					return move;
< 
< 				// Losing capture, move it to the tail of the array
< 				(--badCaptures)->move = move;
< 				badCaptures->score = seeValue;
< 			}
< 			break;
< 
< 		case PH_GOOD_PROBCUT:
< 			move = pick_best(curMove++, lastMove)->move;
< 			if (   move != ttMove
< 			    && pos.see(move) > captureThreshold)
< 				return move;
< 			break;
< 
< 		case PH_KILLERS:
< 			move = (curMove++)->move;
< 			if (   move != MOVE_NONE
< 			    && pos.is_pseudo_legal(move)
< 			    && move != ttMove
< 			    && !pos.is_capture(move))
< 				return move;
< 			break;
< 
< 		case PH_NONCAPTURES_1:
< 		case PH_NONCAPTURES_2:
< 			move = (curMove++)->move;
< 			if (   move != ttMove
< 			    && move != killers[0].move
< 			    && move != killers[1].move)
< 				return move;
< 			break;
< 
< 		case PH_BAD_CAPTURES:
< 			move = pick_best(curMove++, lastMove)->move;
< 			return move;
< 
< 		case PH_EVASIONS:
< 		case PH_QCAPTURES:
< 			move = pick_best(curMove++, lastMove)->move;
< 			if (move != ttMove)
< 				return move;
< 			break;
< 
< 		case PH_QRECAPTURES:
< 			move = (curMove++)->move;
< 			if (move_to(move) == recaptureSquare)
< 				return move;
< 			break;
< 
< 		case PH_QCHECKS:
< 			move = (curMove++)->move;
< 			if (move != ttMove)
< 				return move;
< 			break;
< 
< 		case PH_STOP:
< 			return MOVE_NONE;
< 
< 		default:
< 			assert(false);
< 			break;
< 		}
< 	}
---
>   while (true)
>   {
>       while (curMove == lastMove)
>           go_next_phase();
> 
>       switch (phase) {
> 
>       case PH_TT_MOVES:
>           move = (curMove++)->move;
>           if (   move != MOVE_NONE
>               && pos.move_is_legal(move, pinned))
>               return move;
>           break;
> 
>       case PH_GOOD_CAPTURES:
>           move = pick_best(curMove++, lastMove).move;
>           if (   move != ttMoves[0].move
>               && move != ttMoves[1].move
>               && pos.pl_move_is_legal(move, pinned))
>           {
>               // Check for a non negative SEE now
>               int seeValue = pos.see_sign(move);
>               if (seeValue >= badCaptureThreshold)
>                   return move;
> 
>               // Losing capture, move it to the tail of the array, note
>               // that move has now been already checked for legality.
>               (--badCaptures)->move = move;
>               badCaptures->score = seeValue;
>           }
>           break;
> 
>       case PH_KILLERS:
>           move = (curMove++)->move;
>           if (   move != MOVE_NONE
>               && pos.move_is_legal(move, pinned)
>               && move != ttMoves[0].move
>               && move != ttMoves[1].move
>               && !pos.move_is_capture(move))
>               return move;
>           break;
> 
>       case PH_NONCAPTURES:
>           // Sort negative scored moves only when we get there
>           if (curMove == lastGoodNonCapture)
>               insertion_sort<MoveStack>(lastGoodNonCapture, lastMove);
> 
>           move = (curMove++)->move;
>           if (   move != ttMoves[0].move
>               && move != ttMoves[1].move
>               && move != killers[0].move
>               && move != killers[1].move
>               && pos.pl_move_is_legal(move, pinned))
>               return move;
>           break;
> 
>       case PH_BAD_CAPTURES:
>           move = pick_best(curMove++, lastMove).move;
>           return move;
> 
>       case PH_EVASIONS:
>       case PH_QCAPTURES:
>           move = pick_best(curMove++, lastMove).move;
>           if (   move != ttMoves[0].move
>               && pos.pl_move_is_legal(move, pinned))
>               return move;
>           break;
> 
>       case PH_QCHECKS:
>           move = (curMove++)->move;
>           if (   move != ttMoves[0].move
>               && pos.pl_move_is_legal(move, pinned))
>               return move;
>           break;
> 
>       case PH_STOP:
>           return MOVE_NONE;
> 
>       default:
>           assert(false);
>           break;
>       }
>   }
########################## position.cpp
2c2
<   NanohaMini, a USI shogi(japanese-chess) playing engine derived from Stockfish 2.1
---
>   Stockfish, a UCI chess playing engine derived from Glaurung 2.1
4,5c4
<   Copyright (C) 2008-2010 Marco Costalba, Joona Kiiski, Tord Romstad (Stockfish author)
<   Copyright (C) 2014 Kazuyuki Kawabata
---
>   Copyright (C) 2008-2010 Marco Costalba, Joona Kiiski, Tord Romstad
7c6
<   NanohaMini is free software: you can redistribute it and/or modify
---
>   Stockfish is free software: you can redistribute it and/or modify
12c11
<   NanohaMini is distributed in the hope that it will be useful,
---
>   Stockfish is distributed in the hope that it will be useful,
23a23
> #include <map>
27,30d26
< #if defined(NANOHA)
< #include <map>
< #endif
< #if !defined(NANOHA)
32d27
< #endif
35d29
< #if !defined(NANOHA)
37d30
< #endif
41,50c34,35
< ///#include "ucioption.h"
< #if defined(NANOHA)
< #if defined(EVAL_MICRO)
< #include "param_micro.h"
< #elif defined(EVAL_OLD)
< #include "param_old.h"
< #else
< #include "param_new.h"
< #endif
< #endif
---
> #include "ucioption.h"
> 
55,57d39
< #if defined(NANOHA)
< Key Position::zobrist[GRY+1][0x100];
< #else
61,67c43,46
< #endif
< Key Position::zobSideToMove;	// 手番を区別する
< Key Position::zobExclusion;		// NULL MOVEかどうか区別する
< 
< #if !defined(NANOHA)
< Score Position::pieceSquareTable[16][64];
< #endif
---
> Key Position::zobSideToMove;
> Key Position::zobExclusion;
> 
> Score Position::PieceSquareTable[16][64];
70,103c49,55
< #if defined(NANOHA)
< const Value PieceValueMidgame[32] = {
< 	VALUE_ZERO,
< 	Value(DPawn   *2),
< 	Value(DLance  *2),
< 	Value(DKnight *2),
< 	Value(DSilver *2),
< 	Value(DGold   *2),
< 	Value(DBishop *2),
< 	Value(DRook   *2),
< 	Value(DKing   *2), 
< 	Value(DPawn   +DProPawn),
< 	Value(DLance  +DProLance),
< 	Value(DKnight +DProKnight),
< 	Value(DSilver +DProSilver),
< 	Value(DGold   *2),
< 	Value(DBishop +DHorse),
< 	Value(DRook   +DDragon),
< 	Value(DKing   *2), 
< 	Value(DPawn   *2),
< 	Value(DLance  *2),
< 	Value(DKnight *2),
< 	Value(DSilver *2),
< 	Value(DGold   *2),
< 	Value(DBishop *2),
< 	Value(DRook   *2),
< 	Value(DKing   *2), 
< 	Value(DPawn   +DProPawn),
< 	Value(DLance  +DProLance),
< 	Value(DKnight +DProKnight),
< 	Value(DSilver +DProSilver),
< 	Value(DGold   *2),
< 	Value(DBishop +DHorse),
< 	Value(DRook   +DDragon),
---
> const Value Position::PieceValueMidgame[17] = {
>   VALUE_ZERO,
>   PawnValueMidgame, KnightValueMidgame, BishopValueMidgame,
>   RookValueMidgame, QueenValueMidgame, VALUE_ZERO,
>   VALUE_ZERO, VALUE_ZERO,
>   PawnValueMidgame, KnightValueMidgame, BishopValueMidgame,
>   RookValueMidgame, QueenValueMidgame
105,139d56
< const Value PieceValueEndgame[32] = {
< 	VALUE_ZERO,
< 	Value(DPawn   *2),
< 	Value(DLance  *2),
< 	Value(DKnight *2),
< 	Value(DSilver *2),
< 	Value(DGold   *2),
< 	Value(DBishop *2),
< 	Value(DRook   *2),
< 	Value(DKing   *2), 
< 	Value(DPawn   +DProPawn),
< 	Value(DLance  +DProLance),
< 	Value(DKnight +DProKnight),
< 	Value(DSilver +DProSilver),
< 	Value(DGold   *2),
< 	Value(DBishop +DHorse),
< 	Value(DRook   +DDragon),
< 	Value(DKing   *2), 
< 	Value(DPawn   *2),
< 	Value(DLance  *2),
< 	Value(DKnight *2),
< 	Value(DSilver *2),
< 	Value(DGold   *2),
< 	Value(DBishop *2),
< 	Value(DRook   *2),
< 	Value(DKing   *2), 
< 	Value(DPawn   +DProPawn),
< 	Value(DLance  +DProLance),
< 	Value(DKnight +DProKnight),
< 	Value(DSilver +DProSilver),
< 	Value(DGold   *2),
< 	Value(DBishop +DHorse),
< 	Value(DRook   +DDragon),
< };
< unsigned char Position::DirTbl[0xA0][0x100];	// 方向用[from][to]
141,148c58,64
< #else
< const Value PieceValueMidgame[17] = {
< 	VALUE_ZERO,
< 	PawnValueMidgame, KnightValueMidgame, BishopValueMidgame,
< 	RookValueMidgame, QueenValueMidgame,
< 	VALUE_ZERO, VALUE_ZERO, VALUE_ZERO,
< 	PawnValueMidgame, KnightValueMidgame, BishopValueMidgame,
< 	RookValueMidgame, QueenValueMidgame
---
> const Value Position::PieceValueEndgame[17] = {
>   VALUE_ZERO,
>   PawnValueEndgame, KnightValueEndgame, BishopValueEndgame,
>   RookValueEndgame, QueenValueEndgame, VALUE_ZERO,
>   VALUE_ZERO, VALUE_ZERO,
>   PawnValueEndgame, KnightValueEndgame, BishopValueEndgame,
>   RookValueEndgame, QueenValueEndgame
151,157c67,71
< const Value PieceValueEndgame[17] = {
< 	VALUE_ZERO,
< 	PawnValueEndgame, KnightValueEndgame, BishopValueEndgame,
< 	RookValueEndgame, QueenValueEndgame,
< 	VALUE_ZERO, VALUE_ZERO, VALUE_ZERO,
< 	PawnValueEndgame, KnightValueEndgame, BishopValueEndgame,
< 	RookValueEndgame, QueenValueEndgame
---
> // Material values array used by SEE, indexed by PieceType
> const Value Position::seeValues[] = {
>     VALUE_ZERO,
>     PawnValueMidgame, KnightValueMidgame, BishopValueMidgame,
>     RookValueMidgame, QueenValueMidgame, QueenValueMidgame*10
159d72
< #endif
161c74
< // Material values array used by SEE, indexed by PieceType
---
> 
164,241c77,106
< #if !defined(NANOHA)
< 	// Bonus for having the side to move (modified by Joona Kiiski)
< 	const Score TempoValue = make_score(48, 22);
< 
< 	// To convert a Piece to and from a FEN char
< 	const string PieceToChar(".PNBRQK  pnbrqk  ");
< #endif
< 
< #if defined(NANOHA)
< 	// To convert a Piece to and from a FEN char
< 	const string PieceToChar(".PLNSGBRKPLNS.BRplnsgbrkplns.br");
< 
< 	struct PieceType2Str : public std::map<PieceType, std::string> {
< 	PieceType2Str() {
< 		operator[](PIECE_TYPE_NONE) = "* ";
< 		operator[](FU) = "FU";
< 		operator[](KY) = "KY";
< 		operator[](KE) = "KE";
< 		operator[](GI) = "GI";
< 		operator[](KI) = "KI";
< 		operator[](KA) = "KA";
< 		operator[](HI) = "HI";
< 		operator[](OU) = "OU";
< 		operator[](TO) = "TO";
< 		operator[](NY) = "NY";
< 		operator[](NK) = "NK";
< 		operator[](NG) = "NG";
< 		operator[](UM) = "UM";
< 		operator[](RY) = "RY";
< 	}
< 	string from_piece(Piece p, bool bc=true) const {
< 		if (p == EMP) return string(" * ");
< 
< 		Color c = color_of(p);
< 		string str = bc ? ((c == BLACK) ? "+" : "-") : "";
< 		std::map<PieceType, std::string>::const_iterator it;
< 		it = find(type_of(p));
< 		if (it == end()) {
< 			std::cerr << "Error!" << endl;
< 			abort();
< 		}
< 		str += it->second;
< 		return str;
< 	}
< 	};
< 
< 	struct PieceLetters : public std::map<char, Piece> {
< 
< 		PieceLetters() {
< 			operator[]('K') = SOU;	operator[]('k') = GOU;
< 			operator[]('R') = SHI;	operator[]('r') = GHI;
< 			operator[]('B') = SKA;	operator[]('b') = GKA;
< 			operator[]('G') = SKI;	operator[]('g') = GKI;
< 			operator[]('S') = SGI;	operator[]('s') = GGI;
< 			operator[]('N') = SKE;	operator[]('n') = GKE;
< 			operator[]('L') = SKY;	operator[]('l') = GKY;
< 			operator[]('P') = SFU;	operator[]('p') = GFU;
< 			operator[]('.') = EMP;
< 		}
< 
< 		string from_piece(Piece p) const {
< 			if (p == SOU) return string("K");
< 			if (p == GOU) return string("k");
< 
< 			std::map<char, Piece>::const_iterator it;
< 			for (it = begin(); it != end(); ++it)
< 			if (it->second == (int(p) & ~PROMOTED)) {
< 				return ((int(p) & PROMOTED) ? string("+") : string(""))+string(1,it->first);
< 			}
< 
< 			assert(false);
< 			return 0;
< 		}
< 	};
< 
< 	PieceLetters pieceLetters;
< 	PieceType2Str pieceCSA;
< #endif
---
>   // Bonus for having the side to move (modified by Joona Kiiski)
>   const Score TempoValue = make_score(48, 22);
> 
>   struct PieceLetters : public std::map<char, Piece> {
> 
>     PieceLetters() {
> 
>       operator[]('K') = WK; operator[]('k') = BK;
>       operator[]('Q') = WQ; operator[]('q') = BQ;
>       operator[]('R') = WR; operator[]('r') = BR;
>       operator[]('B') = WB; operator[]('b') = BB;
>       operator[]('N') = WN; operator[]('n') = BN;
>       operator[]('P') = WP; operator[]('p') = BP;
>       operator[](' ') = PIECE_NONE;
>       operator[]('.') = PIECE_NONE_DARK_SQ;
>     }
> 
>     char from_piece(Piece p) const {
> 
>       std::map<char, Piece>::const_iterator it;
>       for (it = begin(); it != end(); ++it)
>           if (it->second == p)
>               return it->first;
> 
>       assert(false);
>       return 0;
>     }
>   };
> 
>   PieceLetters pieceLetters;
245d109
< #if !defined(NANOHA)
250,251c114,115
< 	Color them = flip(pos.side_to_move());
< 	Square ksq = pos.king_square(them);
---
>   Color us = pos.side_to_move();
>   Color them = opposite_color(us);
253,254c117,118
< 	pinned = pos.pinned_pieces();
< 	dcCandidates = pos.discovered_check_candidates();
---
>   ksq = pos.king_square(them);
>   dcCandidates = pos.discovered_check_candidates(us);
256,261c120,125
< 	checkSq[PAWN]   = pos.attacks_from<PAWN>(ksq, them);
< 	checkSq[KNIGHT] = pos.attacks_from<KNIGHT>(ksq);
< 	checkSq[BISHOP] = pos.attacks_from<BISHOP>(ksq);
< 	checkSq[ROOK]   = pos.attacks_from<ROOK>(ksq);
< 	checkSq[QUEEN]  = checkSq[BISHOP] | checkSq[ROOK];
< 	checkSq[KING]   = EmptyBoardBB;
---
>   checkSq[PAWN] = pos.attacks_from<PAWN>(ksq, them);
>   checkSq[KNIGHT] = pos.attacks_from<KNIGHT>(ksq);
>   checkSq[BISHOP] = pos.attacks_from<BISHOP>(ksq);
>   checkSq[ROOK] = pos.attacks_from<ROOK>(ksq);
>   checkSq[QUEEN] = checkSq[BISHOP] | checkSq[ROOK];
>   checkSq[KING] = EmptyBoardBB;
263c127
< #endif
---
> 
271,288c135,140
< 	memcpy(this, &pos, sizeof(Position));
< 	threadID = th;
< 	nodes = 0;
< #if defined(NANOHA)
< 	tnodes = 0;
< #if defined(CHK_PERFORM)
< 	count_Mate1plyDrop = 0;		// 駒打ちで詰んだ回数
< 	count_Mate1plyMove = 0;		// 駒移動で詰んだ回数
< 	count_Mate3ply = 0;			// Mate3()で詰んだ回数
< #endif // defined(CHK_PERFORM)
< #endif
< 
< 	assert(is_ok());
< }
< 
< #if defined(NANOHA)
< Position::Position(const string& fen, int th) {
< #else
---
>   memcpy(this, &pos, sizeof(Position));
>   detach(); // Always detach() in copy c'tor to avoid surprises
>   threadID = th;
>   nodes = 0;
> }
> 
290d141
< #endif
292,297c143,156
< #if defined(NANOHA)
< 	from_fen(fen);
< #else
< 	from_fen(fen, isChess960);
< #endif
< 	threadID = th;
---
>   from_fen(fen, isChess960);
>   threadID = th;
> }
> 
> 
> /// Position::detach() copies the content of the current state and castling
> /// masks inside the position itself. This is needed when the st pointee could
> /// become stale, as example because the caller is about to going out of scope.
> 
> void Position::detach() {
> 
>   startState = *st;
>   st = &startState;
>   st->previous = NULL; // as a safe guard
305,309c164
< #if defined(NANOHA)
< void Position::from_fen(const string& fenStr) {
< #else
< void Position::from_fen(const string& fenStr, bool isChess960) {
< #endif
---
> void Position::from_fen(const string& fen, bool isChess960) {
338,481c193,268
< #if defined(NANOHA)
< 	char token;
< 	std::istringstream fen(fenStr);
< 
< 	unsigned char tmp_ban[9][9] = {{'\0'}};
< 	int tmp_hand[GRY+1] = {0};
< 
< 	clear();
< 	fen >> std::noskipws;
< 
< 	// 1. Piece placement
< 	int dan = 0;
< 	int suji = 0; // この「筋」というのは、普通とは反転したものになる。
< 	while ((fen >> token) && !isspace(token))
< 	{
< 		if (token == '+') {
< 			// 成り駒
< 			fen >> token;
< 			if (pieceLetters.find(token) == pieceLetters.end()) goto incorrect_fen;
< 			tmp_ban[dan][suji++] = static_cast<unsigned char>(pieceLetters[token] | PROMOTED);
< 		} else if (pieceLetters.find(token) != pieceLetters.end())
< 		{
< 			tmp_ban[dan][suji++] = static_cast<unsigned char>(pieceLetters[token]);
< 		}
< 		else if (isdigit(token)) {
< 			suji += (token - '0');	// 数字の分空白
< 		} else if (token == '/') {
< 			if (suji != 9) goto incorrect_fen;
< 			suji = 0;
< 			dan++;
< 		} else {
< 			goto incorrect_fen;
< 		}
< 		if (dan > 9 || suji > 9) goto incorrect_fen;
< 	}
< 	if (dan != 9 && suji != 9) goto incorrect_fen;
< 
< 	// 手番取得
< 	if (!fen.get(token) || (token != 'w' && token != 'b')) goto incorrect_fen;
< 	sideToMove = (token == 'b') ? BLACK : WHITE;
< 	// スペース飛ばす
< 	if (!fen.get(token) || token != ' ') goto incorrect_fen;
< 
< 	// 持ち駒
< 	while ((fen >> token) && token != ' ') {
< 		int num = 1;
< 		if (token == '-') {
< 			break;
< 		} else if (isdigit(token)) {
< 			num = token - '0';
< 			fen >> token;
< 			if (isdigit(token)) {
< 				num = 10*num + token - '0';
< 				fen >> token;
< 			}
< 		}
< 		if (pieceLetters.find(token) == pieceLetters.end()) goto incorrect_fen;
< 		tmp_hand[pieceLetters[token]] = num;
< 	}
< 	init_position(tmp_ban, tmp_hand);
< 
< #else
< 	char col, row, token;
< 	size_t p;
< 	Square sq = SQ_A8;
< 	std::istringstream fen(fenStr);
< 
< 	clear();
< 	fen >> std::noskipws;
< 
< 	// 1. Piece placement
< 	while ((fen >> token) && !isspace(token))
< 	{
< 		if (token == '/')
< 			sq -= Square(16); // Jump back of 2 rows
< 
< 		else if (isdigit(token))
< 			sq += Square(token - '0'); // Skip the given number of files
< 
< 		else if ((p = PieceToChar.find(token)) != string::npos)
< 		{
< 			put_piece(Piece(p), sq);
< 			sq++;
< 		}
< 	}
< 
< 	// 2. Active color
< 	fen >> token;
< 	sideToMove = (token == 'w' ? WHITE : BLACK);
< 	fen >> token;
< 
< 	// 3. Castling availability
< 	while ((fen >> token) && !isspace(token))
< 		set_castling_rights(token);
< 
< 	// 4. En passant square. Ignore if no pawn capture is possible
< 	if (   ((fen >> col) && (col >= 'a' && col <= 'h'))
< 	    && ((fen >> row) && (row == '3' || row == '6')))
< 	{
< 		st->epSquare = make_square(File(col - 'a'), Rank(row - '1'));
< 		Color them = flip(sideToMove);
< 
< 		if (!(attacks_from<PAWN>(st->epSquare, them) & pieces(PAWN, sideToMove)))
< 			st->epSquare = SQ_NONE;
< 	}
< #endif
< 
< 	// 5-6. Halfmove clock and fullmove number
< #if defined(NANOHA)
< 	fen >> std::skipws >> startPosPly;
< #else
< 	fen >> std::skipws >> st->rule50 >> startPosPly;
< #endif
< 
< 	// Convert from fullmove starting from 1 to ply starting from 0,
< 	// handle also common incorrect FEN with fullmove = 0.
< #if defined(NANOHA)
< // チェスと将棋で先手のBLACK/WHITEが違うが、そのままでいいか？
< // ⇒将棋は駒落ちで手番が変わるので、補正しない。
< 	// startPosPly = startPosPly;
< #else
< 	startPosPly = Max(2 * (startPosPly - 1), 0) + int(sideToMove == BLACK);
< 
< 	// Various initialisations
< 	chess960 = isChess960;
< 	st->checkersBB = attackers_to(king_square(sideToMove)) & pieces(flip(sideToMove));
< #endif
< 
< 	st->key = compute_key();
< #if defined(NANOHA)
< 	st->hand = hand[sideToMove].h;
< 	st->effect = (sideToMove == BLACK) ? effectB[kingG] : effectW[kingS];
< 	material = compute_material();
< #else
< 	st->pawnKey = compute_pawn_key();
< 	st->materialKey = compute_material_key();
< 	st->value = compute_value();
< 	st->npMaterial[WHITE] = compute_non_pawn_material(WHITE);
< 	st->npMaterial[BLACK] = compute_non_pawn_material(BLACK);
< #endif
< 
< 	assert(is_ok());
< #if defined(NANOHA)
< 	return;
---
>   char token;
>   int hmc, fmn;
>   std::istringstream ss(fen);
>   Square sq = SQ_A8;
> 
>   clear();
> 
>   // 1. Piece placement field
>   while (ss.get(token) && token != ' ')
>   {
>       if (pieceLetters.find(token) != pieceLetters.end())
>       {
>           put_piece(pieceLetters[token], sq);
>           sq++;
>       }
>       else if (isdigit(token))
>           sq += Square(token - '0'); // Skip the given number of files
>       else if (token == '/')
>           sq -= SQ_A3; // Jump back of 2 rows
>       else
>           goto incorrect_fen;
>   }
> 
>   // 2. Active color
>   if (!ss.get(token) || (token != 'w' && token != 'b'))
>       goto incorrect_fen;
> 
>   sideToMove = (token == 'w' ? WHITE : BLACK);
> 
>   if (!ss.get(token) || token != ' ')
>       goto incorrect_fen;
> 
>   // 3. Castling availability
>   while (ss.get(token) && token != ' ')
>       if (!set_castling_rights(token))
>           goto incorrect_fen;
> 
>   // 4. En passant square
>   char col, row;
>   if (   (ss.get(col) && (col >= 'a' && col <= 'h'))
>       && (ss.get(row) && (row == '3' || row == '6')))
>   {
>       st->epSquare = make_square(file_from_char(col), rank_from_char(row));
> 
>       // Ignore if no capture is possible
>       Color them = opposite_color(sideToMove);
>       if (!(attacks_from<PAWN>(st->epSquare, them) & pieces(PAWN, sideToMove)))
>           st->epSquare = SQ_NONE;
>   }
> 
>   // 5. Halfmove clock
>   if (ss >> hmc)
>       st->rule50 = hmc;
> 
>   // 6. Fullmove number
>   if (ss >> fmn)
>       startPosPlyCounter = (fmn - 1) * 2 + int(sideToMove == BLACK);
> 
>   // Various initialisations
>   castleRightsMask[make_square(initialKFile,  RANK_1)] ^= WHITE_OO | WHITE_OOO;
>   castleRightsMask[make_square(initialKFile,  RANK_8)] ^= BLACK_OO | BLACK_OOO;
>   castleRightsMask[make_square(initialKRFile, RANK_1)] ^= WHITE_OO;
>   castleRightsMask[make_square(initialKRFile, RANK_8)] ^= BLACK_OO;
>   castleRightsMask[make_square(initialQRFile, RANK_1)] ^= WHITE_OOO;
>   castleRightsMask[make_square(initialQRFile, RANK_8)] ^= BLACK_OOO;
> 
>   chess960 = isChess960;
>   find_checkers();
> 
>   st->key = compute_key();
>   st->pawnKey = compute_pawn_key();
>   st->materialKey = compute_material_key();
>   st->value = compute_value();
>   st->npMaterial[WHITE] = compute_non_pawn_material(WHITE);
>   st->npMaterial[BLACK] = compute_non_pawn_material(BLACK);
>   return;
484,498c271
< 	std::cerr << "Error in SFEN string: " << fenStr << endl;
< #endif
< }
< 
< 
< #if !defined(NANOHA)
< /// Position::set_castle() is an helper function used to set
< /// correct castling related flags.
< 
< void Position::set_castle(int f, Square ksq, Square rsq) {
< 
< 	st->castleRights |= f;
< 	castleRightsMask[ksq] ^= f;
< 	castleRightsMask[rsq] ^= f;
< 	castleRookSquare[f] = rsq;
---
>   cout << "Error in FEN string: " << fen << endl;
509,511c282
< void Position::set_castling_rights(char token) {
< 
< 	Color c = islower(token) ? BLACK : WHITE;
---
> bool Position::set_castling_rights(char token) {
513,515c284,327
< 	Square sqA = relative_square(c, SQ_A1);
< 	Square sqH = relative_square(c, SQ_H1);
< 	Square rsq, ksq = king_square(c);
---
>     Color c = token >= 'a' ? BLACK : WHITE;
>     Square sqA = (c == WHITE ? SQ_A1 : SQ_A8);
>     Square sqH = (c == WHITE ? SQ_H1 : SQ_H8);
>     Piece rook = (c == WHITE ? WR : BR);
> 
>     initialKFile = square_file(king_square(c));
>     token = char(toupper(token));
> 
>     if (token == 'K')
>     {
>         for (Square sq = sqH; sq >= sqA; sq--)
>             if (piece_on(sq) == rook)
>             {
>                 do_allow_oo(c);
>                 initialKRFile = square_file(sq);
>                 break;
>             }
>     }
>     else if (token == 'Q')
>     {
>         for (Square sq = sqA; sq <= sqH; sq++)
>             if (piece_on(sq) == rook)
>             {
>                 do_allow_ooo(c);
>                 initialQRFile = square_file(sq);
>                 break;
>             }
>     }
>     else if (token >= 'A' && token <= 'H')
>     {
>         File rookFile = File(token - 'A') + FILE_A;
>         if (rookFile < initialKFile)
>         {
>             do_allow_ooo(c);
>             initialQRFile = rookFile;
>         }
>         else
>         {
>             do_allow_oo(c);
>             initialKRFile = rookFile;
>         }
>     }
>     else
>         return token == '-';
517,533c329
< 	token = char(toupper(token));
< 
< 	if (token == 'K')
< 		for (rsq = sqH; piece_on(rsq) != make_piece(c, ROOK); rsq--) {}
< 
< 	else if (token == 'Q')
< 		for (rsq = sqA; piece_on(rsq) != make_piece(c, ROOK); rsq++) {}
< 
< 	else if (token >= 'A' && token <= 'H')
< 		rsq = make_square(File(token - 'A'), relative_rank(c, RANK_1));
< 
< 	else return;
< 
< 	if (file_of(rsq) < file_of(ksq))
< 		set_castle(WHITE_OOO << c, ksq, rsq);
< 	else
< 		set_castle(WHITE_OO << c, ksq, rsq);
---
>   return true;
535c331
< #endif
---
> 
542,642c338,386
< 	std::ostringstream fen;
< 	Square sq;
< 	int emptyCnt;
< 
< #if defined(NANOHA)
< 	for (Rank rank = RANK_1; rank <= RANK_9; rank++)
< #else
< 	for (Rank rank = RANK_8; rank >= RANK_1; rank--)
< #endif
< 	{
< 		emptyCnt = 0;
< 
< #if defined(NANOHA)
< 		for (File file = FILE_9; file >= FILE_1; file--)
< #else
< 		for (File file = FILE_A; file <= FILE_H; file++)
< #endif
< 		{
< 			sq = make_square(file, rank);
< 
< 			if (!square_is_empty(sq))
< 			{
< 				if (emptyCnt)
< 				{
< 					fen << emptyCnt;
< 					emptyCnt = 0;
< 				}
< #if defined(NANOHA)
< 				if (piece_on(sq) & PROMOTED) {
< 					fen << "+";
< 				}
< #endif
< 				fen << PieceToChar[piece_on(sq)];
< 			}
< 			else
< 				emptyCnt++;
< 		}
< 
< 		if (emptyCnt)
< 			fen << emptyCnt;
< 
< 		if (rank > RANK_1)
< 			fen << '/';
< 	}
< 
< 	fen << (sideToMove == WHITE ? " w " : " b ");
< 
< #if defined(NANOHA)
< 	// 持ち駒
< 	if (handS.h == 0 && handG.h == 0) {
< 		fen << "-";
< 	} else {
< 		unsigned int n;
< 		static const char *tbl[] = {
< 			 "",   "",   "2",  "3",  "4",  "5",  "6",  "7",
< 			 "8",  "9", "10", "11", "12", "13", "14", "15",
< 			"16", "17", "18"
< 		};
< #define ADD_HAND(piece,c)	n = h.get ## piece(); if (n) {fen << tbl[n]; fen << #c; }
< 
< 		Hand h = handS;
< 		ADD_HAND(HI,R)
< 		ADD_HAND(KA,B)
< 		ADD_HAND(KI,G)
< 		ADD_HAND(GI,S)
< 		ADD_HAND(KE,N)
< 		ADD_HAND(KY,L)
< 		ADD_HAND(FU,P)
< 
< 		h = handG;
< 		ADD_HAND(HI,r)
< 		ADD_HAND(KA,b)
< 		ADD_HAND(KI,g)
< 		ADD_HAND(GI,s)
< 		ADD_HAND(KE,n)
< 		ADD_HAND(KY,l)
< 		ADD_HAND(FU,p)
< 
< #undef ADD_HAND
< 	}
< #else
< 	if (st->castleRights != CASTLES_NONE)
< 	{
< 		if (can_castle(WHITE_OO))
< 			fen << (chess960 ? char(toupper(file_to_char(file_of(castle_rook_square(WHITE_OO))))) : 'K');
< 
< 		if (can_castle(WHITE_OOO))
< 			fen << (chess960 ? char(toupper(file_to_char(file_of(castle_rook_square(WHITE_OOO))))) : 'Q');
< 
< 		if (can_castle(BLACK_OO))
< 			fen << (chess960 ? file_to_char(file_of(castle_rook_square(BLACK_OO))) : 'k');
< 
< 		if (can_castle(BLACK_OOO))
< 			fen << (chess960 ? file_to_char(file_of(castle_rook_square(BLACK_OOO))) : 'q');
< 	} else
< 		fen << '-';
< 
< 	fen << (ep_square() == SQ_NONE ? " -" : " " + square_to_string(ep_square()))
< 	    << " " << st->rule50 << " " << 1 + (startPosPly - int(sideToMove == BLACK)) / 2;
< #endif
< 	return fen.str();
---
>   string fen;
>   Square sq;
>   char emptyCnt = '0';
> 
>   for (Rank rank = RANK_8; rank >= RANK_1; rank--, fen += '/')
>   {
>       for (File file = FILE_A; file <= FILE_H; file++)
>       {
>           sq = make_square(file, rank);
> 
>           if (square_is_occupied(sq))
>           {
>               if (emptyCnt != '0')
>               {
>                   fen += emptyCnt;
>                   emptyCnt = '0';
>               }
>               fen += pieceLetters.from_piece(piece_on(sq));
>           } else
>               emptyCnt++;
>       }
> 
>       if (emptyCnt != '0')
>       {
>           fen += emptyCnt;
>           emptyCnt = '0';
>       }
>   }
> 
>   fen += (sideToMove == WHITE ? " w " : " b ");
> 
>   if (st->castleRights != CASTLES_NONE)
>   {
>       if (can_castle_kingside(WHITE))
>           fen += chess960 ? char(toupper(file_to_char(initialKRFile))) : 'K';
> 
>       if (can_castle_queenside(WHITE))
>           fen += chess960 ? char(toupper(file_to_char(initialQRFile))) : 'Q';
> 
>       if (can_castle_kingside(BLACK))
>           fen += chess960 ? file_to_char(initialKRFile) : 'k';
> 
>       if (can_castle_queenside(BLACK))
>           fen += chess960 ? file_to_char(initialQRFile) : 'q';
>   } else
>       fen += '-';
> 
>   fen += (ep_square() == SQ_NONE ? " -" : " " + square_to_string(ep_square()));
>   return fen;
651,652c395
< #if defined(NANOHA)
< 	const char* dottedLine = "\n+---+---+---+---+---+---+---+---+---+\n";
---
>   const char* dottedLine = "\n+---+---+---+---+---+---+---+---+\n";
654,743c397,419
< 	if (move != MOVE_NONE)
< #else
< 	const char* dottedLine = "\n+---+---+---+---+---+---+---+---+\n";
< 
< 	if (move)
< #endif
< 	{
< 		Position p(*this, thread());
< 		string dd = (sideToMove == BLACK ? ".." : "");
< 		cout << "\nMove is: " << dd << move_to_san(p, move);
< 	}
< #if defined(NANOHA)
< 	for (Rank rank = RANK_1; rank <= RANK_9; rank++)
< 	{
< 		cout << dottedLine << '|';
< 		for (File file = FILE_9; file >= FILE_1; file--)
< 		{
< 			Square sq = make_square(file, rank);
< 			Piece piece = piece_on(sq);
< 
< 			char c = (color_of(piece_on(sq)) == BLACK ? ' ' : ' ');
< 			cout << c << pieceLetters.from_piece(piece) << c << '|';
< 		}
< 	}
< 	cout << dottedLine << "Fen is: " << to_fen() << "\nKey is: 0x" << std::hex << st->key << std::dec << endl;
< #else
< 	for (Rank rank = RANK_8; rank >= RANK_1; rank--)
< 	{
< 		cout << dottedLine << '|';
< 		for (File file = FILE_A; file <= FILE_H; file++)
< 		{
< 			Square sq = make_square(file, rank);
< 			Piece piece = piece_on(sq);
< 
< 			if (piece == PIECE_NONE && color_of(sq) == DARK)
< 				piece = PIECE_NONE_DARK_SQ;
< 
< 			char c = (color_of(piece_on(sq)) == BLACK ? '=' : ' ');
< 			cout << c << PieceToChar[piece] << c << '|';
< 		}
< 	}
< 	cout << dottedLine << "Fen is: " << to_fen() << "\nKey is: " << st->key << endl;
< #endif
< }
< 
< #if defined(NANOHA)
< void Position::print_csa(Move move) const {
< 
< 	if (move != MOVE_NONE)
< 	{
< 		cout << "\nMove is: " << move_to_csa(move) << endl;
< 	}
< 	// 盤面
< 	for (Rank rank = RANK_1; rank <= RANK_9; rank++)
< 	{
< 		cout << "P" << int(rank);
< 		for (File file = FILE_9; file >= FILE_1; file--)
< 		{
< 			Square sq = make_square(file, rank);
< 			Piece piece = piece_on(sq);
< 			cout << pieceCSA.from_piece(piece);
< 		}
< 		cout << endl;
< 	}
< 	// 持ち駒
< 	unsigned int n;
< 	cout << "P+";
< 	{
< 	const Hand &h = hand[BLACK];
< 	if ((n = h.getFU()) > 0) while (n--){ cout << "00FU"; }
< 	if ((n = h.getKY()) > 0) while (n--){ cout << "00KY"; }
< 	if ((n = h.getKE()) > 0) while (n--){ cout << "00KE"; }
< 	if ((n = h.getGI()) > 0) while (n--){ cout << "00GI"; }
< 	if ((n = h.getKI()) > 0) while (n--){ cout << "00KI"; }
< 	if ((n = h.getKA()) > 0) while (n--){ cout << "00KA"; }
< 	if ((n = h.getHI()) > 0) while (n--){ cout << "00HI"; }
< 	}
< 	cout << endl << "P-";
< 	{
< 	const Hand &h = hand[WHITE];
< 	if ((n = h.getFU()) > 0) while (n--){ cout << "00FU"; }
< 	if ((n = h.getKY()) > 0) while (n--){ cout << "00KY"; }
< 	if ((n = h.getKE()) > 0) while (n--){ cout << "00KE"; }
< 	if ((n = h.getGI()) > 0) while (n--){ cout << "00GI"; }
< 	if ((n = h.getKI()) > 0) while (n--){ cout << "00KI"; }
< 	if ((n = h.getKA()) > 0) while (n--){ cout << "00KA"; }
< 	if ((n = h.getHI()) > 0) while (n--){ cout << "00HI"; }
< 	}
< 	cout << endl << (sideToMove == BLACK ? '+' : '-') << endl;
< 	cout << "SFEN is: " << to_fen() << "\nKey is: 0x" << std::hex << st->key << endl;
---
>   if (move)
>   {
>       Position p(*this, thread());
>       string dd = (color_of_piece_on(move_from(move)) == BLACK ? ".." : "");
>       cout << "\nMove is: " << dd << move_to_san(p, move);
>   }
> 
>   for (Rank rank = RANK_8; rank >= RANK_1; rank--)
>   {
>       cout << dottedLine << '|';
>       for (File file = FILE_A; file <= FILE_H; file++)
>       {
>           Square sq = make_square(file, rank);
>           Piece piece = piece_on(sq);
> 
>           if (piece == PIECE_NONE && square_color(sq) == DARK)
>               piece = PIECE_NONE_DARK_SQ;
> 
>           char c = (color_of_piece_on(sq) == BLACK ? '=' : ' ');
>           cout << c << pieceLetters.from_piece(piece) << c << '|';
>       }
>   }
>   cout << dottedLine << "Fen is: " << to_fen() << "\nKey is: " << st->key << endl;
745d420
< #endif
747c422
< #if !defined(NANOHA)
---
> 
749,751c424,427
< /// king) pieces for the given color. Or, when template parameter FindPinned is
< /// false, the function return the pieces of the given color candidate for a
< /// discovery check against the enemy king.
---
> /// king) pieces for the given color and for the given pinner type. Or, when
> /// template parameter FindPinned is false, the pieces of the given color
> /// candidate for a discovery check against the enemy king.
> /// Bitboard checkersBB must be already updated when looking for pinners.
754c430,448
< Bitboard Position::hidden_checkers() const {
---
> Bitboard Position::hidden_checkers(Color c) const {
> 
>   Bitboard result = EmptyBoardBB;
>   Bitboard pinners = pieces_of_color(FindPinned ? opposite_color(c) : c);
> 
>   // Pinned pieces protect our king, dicovery checks attack
>   // the enemy king.
>   Square ksq = king_square(FindPinned ? c : opposite_color(c));
> 
>   // Pinners are sliders, not checkers, that give check when candidate pinned is removed
>   pinners &= (pieces(ROOK, QUEEN) & RookPseudoAttacks[ksq]) | (pieces(BISHOP, QUEEN) & BishopPseudoAttacks[ksq]);
> 
>   if (FindPinned && pinners)
>       pinners &= ~st->checkersBB;
> 
>   while (pinners)
>   {
>       Square s = pop_1st_bit(&pinners);
>       Bitboard b = squares_between(s, ksq) & occupied_squares();
756,773c450,456
< 	// Pinned pieces protect our king, dicovery checks attack the enemy king
< 	Bitboard b, result = EmptyBoardBB;
< 	Bitboard pinners = pieces(FindPinned ? flip(sideToMove) : sideToMove);
< 	Square ksq = king_square(FindPinned ? sideToMove : flip(sideToMove));
< 
< 	// Pinners are sliders, that give check when candidate pinned is removed
< 	pinners &=  (pieces(ROOK, QUEEN) & RookPseudoAttacks[ksq])
< 	          | (pieces(BISHOP, QUEEN) & BishopPseudoAttacks[ksq]);
< 
< 	while (pinners)
< 	{
< 		b = squares_between(ksq, pop_1st_bit(&pinners)) & occupied_squares();
< 
< 		// Only one bit set and is an our piece?
< 		if (b && !(b & (b - 1)) && (b & pieces(sideToMove)))
< 			result |= b;
< 	}
< 	return result;
---
>       assert(b);
> 
>       if (  !(b & (b - 1)) // Only one bit set?
>           && (b & pieces_of_color(c))) // Is an our piece?
>           result |= b;
>   }
>   return result;
778c461,462
< /// king) pieces for the side to move.
---
> /// king) pieces for the given color. Note that checkersBB bitboard must
> /// be already updated.
780c464
< Bitboard Position::pinned_pieces() const {
---
> Bitboard Position::pinned_pieces(Color c) const {
782c466
< 	return hidden_checkers<true>();
---
>   return hidden_checkers<true>(c);
787,788c471,473
< /// pieces for the side to move which are candidates for giving a discovered
< /// check.
---
> /// pieces for the given side which are candidates for giving a discovered
> /// check. Contrary to pinned_pieces() here there is no need of checkersBB
> /// to be already updated.
790c475
< Bitboard Position::discovered_check_candidates() const {
---
> Bitboard Position::discovered_check_candidates(Color c) const {
792c477
< 	return hidden_checkers<false>();
---
>   return hidden_checkers<false>(c);
800,815c485,490
< 	return  (attacks_from<PAWN>(s, BLACK) & pieces(PAWN, WHITE))
< 	      | (attacks_from<PAWN>(s, WHITE) & pieces(PAWN, BLACK))
< 	      | (attacks_from<KNIGHT>(s)      & pieces(KNIGHT))
< 	      | (attacks_from<ROOK>(s)        & pieces(ROOK, QUEEN))
< 	      | (attacks_from<BISHOP>(s)      & pieces(BISHOP, QUEEN))
< 	      | (attacks_from<KING>(s)        & pieces(KING));
< }
< 
< Bitboard Position::attackers_to(Square s, Bitboard occ) const {
< 
< 	return  (attacks_from<PAWN>(s, BLACK) & pieces(PAWN, WHITE))
< 	      | (attacks_from<PAWN>(s, WHITE) & pieces(PAWN, BLACK))
< 	      | (attacks_from<KNIGHT>(s)      & pieces(KNIGHT))
< 	      | (rook_attacks_bb(s, occ)      & pieces(ROOK, QUEEN))
< 	      | (bishop_attacks_bb(s, occ)    & pieces(BISHOP, QUEEN))
< 	      | (attacks_from<KING>(s)        & pieces(KING));
---
>   return  (attacks_from<PAWN>(s, BLACK) & pieces(PAWN, WHITE))
>         | (attacks_from<PAWN>(s, WHITE) & pieces(PAWN, BLACK))
>         | (attacks_from<KNIGHT>(s)      & pieces(KNIGHT))
>         | (attacks_from<ROOK>(s)        & pieces(ROOK, QUEEN))
>         | (attacks_from<BISHOP>(s)      & pieces(BISHOP, QUEEN))
>         | (attacks_from<KING>(s)        & pieces(KING));
823c498
< 	assert(square_is_ok(s));
---
>   assert(square_is_ok(s));
825,831c500,506
< 	switch (p)
< 	{
< 	case WB: case BB: return attacks_from<BISHOP>(s);
< 	case WR: case BR: return attacks_from<ROOK>(s);
< 	case WQ: case BQ: return attacks_from<QUEEN>(s);
< 	default: return StepAttacksBB[p][s];
< 	}
---
>   switch (p)
>   {
>   case WB: case BB: return attacks_from<BISHOP>(s);
>   case WR: case BR: return attacks_from<ROOK>(s);
>   case WQ: case BQ: return attacks_from<QUEEN>(s);
>   default: return StepAttacksBB[p][s];
>   }
836c511
< 	assert(square_is_ok(s));
---
>   assert(square_is_ok(s));
838,844c513,519
< 	switch (p)
< 	{
< 	case WB: case BB: return bishop_attacks_bb(s, occ);
< 	case WR: case BR: return rook_attacks_bb(s, occ);
< 	case WQ: case BQ: return bishop_attacks_bb(s, occ) | rook_attacks_bb(s, occ);
< 	default: return StepAttacksBB[p][s];
< 	}
---
>   switch (p)
>   {
>   case WB: case BB: return bishop_attacks_bb(s, occ);
>   case WR: case BR: return rook_attacks_bb(s, occ);
>   case WQ: case BQ: return bishop_attacks_bb(s, occ) | rook_attacks_bb(s, occ);
>   default: return StepAttacksBB[p][s];
>   }
850,851c525
< /// Position::move_attacks_square() は現局面で move が指定された升目を
< /// 攻撃するかテストする
---
> 
854,855c528,544
< 	assert(is_ok(m));
< 	assert(square_is_ok(s));
---
>   assert(move_is_ok(m));
>   assert(square_is_ok(s));
> 
>   Bitboard occ, xray;
>   Square f = move_from(m), t = move_to(m);
> 
>   assert(square_is_occupied(f));
> 
>   if (bit_is_set(attacks_from(piece_on(f), t), s))
>       return true;
> 
>   // Move the piece and scan for X-ray attacks behind it
>   occ = occupied_squares();
>   do_move_bb(&occ, make_move_bb(f, t));
>   xray = ( (rook_attacks_bb(s, occ)   & pieces(ROOK, QUEEN))
>           |(bishop_attacks_bb(s, occ) & pieces(BISHOP, QUEEN)))
>          & pieces_of_color(color_of_piece_on(f));
857,858c546,549
< 	Bitboard occ, xray;
< 	Square f = move_from(m), t = move_to(m);
---
>   // If we have attacks we need to verify that are caused by our move
>   // and are not already existent ones.
>   return xray && (xray ^ (xray & attacks_from<QUEEN>(s)));
> }
860d550
< 	assert(!square_is_empty(f));
862,863c552,556
< 	if (bit_is_set(attacks_from(piece_on(f), t), s))
< 		return true;
---
> /// Position::find_checkers() computes the checkersBB bitboard, which
> /// contains a nonzero bit for each checking piece (0, 1 or 2). It
> /// currently works by calling Position::attackers_to, which is probably
> /// inefficient. Consider rewriting this function to use the last move
> /// played, like in non-bitboard versions of Glaurung.
865,870c558
< 	// Move the piece and scan for X-ray attacks behind it
< 	occ = occupied_squares();
< 	do_move_bb(&occ, make_move_bb(f, t));
< 	xray = ( (rook_attacks_bb(s, occ)   & pieces(ROOK, QUEEN))
< 	        |(bishop_attacks_bb(s, occ) & pieces(BISHOP, QUEEN)))
< 	       & pieces(color_of(piece_on(f)));
---
> void Position::find_checkers() {
872,874c560,561
< 	// If we have attacks we need to verify that are caused by our move
< 	// and are not already existent ones.
< 	return xray && (xray ^ (xray & attacks_from<QUEEN>(s)));
---
>   Color us = side_to_move();
>   st->checkersBB = attackers_to(king_square(us)) & pieces_of_color(opposite_color(us));
876d562
< #endif
881,883d566
< #if defined(NANOHA)
< // bool Position::pl_move_is_legal(Move m) const; これは shogi.cpp に定義.
< #else
886,887c569,620
< 	assert(is_ok(m));
< 	assert(pinned == pinned_pieces());
---
>   assert(is_ok());
>   assert(move_is_ok(m));
>   assert(pinned == pinned_pieces(side_to_move()));
> 
>   // Castling moves are checked for legality during move generation.
>   if (move_is_castle(m))
>       return true;
> 
>   // En passant captures are a tricky special case. Because they are
>   // rather uncommon, we do it simply by testing whether the king is attacked
>   // after the move is made
>   if (move_is_ep(m))
>   {
>       Color us = side_to_move();
>       Color them = opposite_color(us);
>       Square from = move_from(m);
>       Square to = move_to(m);
>       Square capsq = make_square(square_file(to), square_rank(from));
>       Square ksq = king_square(us);
>       Bitboard b = occupied_squares();
> 
>       assert(to == ep_square());
>       assert(piece_on(from) == make_piece(us, PAWN));
>       assert(piece_on(capsq) == make_piece(them, PAWN));
>       assert(piece_on(to) == PIECE_NONE);
> 
>       clear_bit(&b, from);
>       clear_bit(&b, capsq);
>       set_bit(&b, to);
> 
>       return   !(rook_attacks_bb(ksq, b) & pieces(ROOK, QUEEN, them))
>             && !(bishop_attacks_bb(ksq, b) & pieces(BISHOP, QUEEN, them));
>   }
> 
>   Color us = side_to_move();
>   Square from = move_from(m);
> 
>   assert(color_of_piece_on(from) == us);
>   assert(piece_on(king_square(us)) == make_piece(us, KING));
> 
>   // If the moving piece is a king, check whether the destination
>   // square is attacked by the opponent.
>   if (type_of_piece_on(from) == KING)
>       return !(attackers_to(move_to(m)) & pieces_of_color(opposite_color(us)));
> 
>   // A non-king move is legal if and only if it is not pinned or it
>   // is moving along the ray towards or away from the king.
>   return   !pinned
>         || !bit_is_set(pinned, from)
>         ||  squares_aligned(from, move_to(m), king_square(us));
> }
> 
889,890c622
< 	Color us = side_to_move();
< 	Square from = move_from(m);
---
> /// Position::pl_move_is_evasion() tests whether a pseudo-legal move is a legal evasion
892,893c624,626
< 	assert(color_of(piece_on(from)) == us);
< 	assert(piece_on(king_square(us)) == make_piece(us, KING));
---
> bool Position::pl_move_is_evasion(Move m, Bitboard pinned) const
> {
>   assert(in_check());
895,935c628,630
< 	// En passant captures are a tricky special case. Because they are rather
< 	// uncommon, we do it simply by testing whether the king is attacked after
< 	// the move is made.
< 	if (is_enpassant(m))
< 	{
< 		Color them = flip(us);
< 		Square to = move_to(m);
< 		Square capsq = to + pawn_push(them);
< 		Square ksq = king_square(us);
< 		Bitboard b = occupied_squares();
< 
< 		assert(to == ep_square());
< 		assert(piece_on(from) == make_piece(us, PAWN));
< 		assert(piece_on(capsq) == make_piece(them, PAWN));
< 		assert(piece_on(to) == PIECE_NONE);
< 
< 		clear_bit(&b, from);
< 		clear_bit(&b, capsq);
< 		set_bit(&b, to);
< 
< 		return   !(rook_attacks_bb(ksq, b) & pieces(ROOK, QUEEN, them))
< 		      && !(bishop_attacks_bb(ksq, b) & pieces(BISHOP, QUEEN, them));
< 	}
< 
< 	// If the moving piece is a king, check whether the destination
< 	// square is attacked by the opponent. Castling moves are checked
< 	// for legality during move generation.
< 	if (type_of(piece_on(from)) == KING)
< 		return is_castle(m) || !(attackers_to(move_to(m)) & pieces(flip(us)));
< 
< 	// A non-king move is legal if and only if it is not pinned or it
< 	// is moving along the ray towards or away from the king.
< 	return   !pinned
< 	      || !bit_is_set(pinned, from)
< 	      ||  squares_aligned(from, move_to(m), king_square(us));
< }
< #endif
< 
< /// Position::move_is_legal() takes a random move and tests whether the move
< /// is legal. This version is not very fast and should be used only
< /// in non time-critical paths.
---
>   Color us = side_to_move();
>   Square from = move_from(m);
>   Square to = move_to(m);
937,945c632,644
< #if defined(NANOHA)
< bool Position::move_is_legal(const Move m) const {
< 	bool b = pl_move_is_legal(m);
< 	if (b) {
< 		Piece p1 = move_captured(m);
< 		Piece p2 = piece_on(move_to(m));
< 		if (p1 == p2) return true;
< 	}
< 	return false;
---
>   // King moves and en-passant captures are verified in pl_move_is_legal()
>   if (type_of_piece_on(from) == KING || move_is_ep(m))
>       return pl_move_is_legal(m, pinned);
> 
>   Bitboard target = checkers();
>   Square checksq = pop_1st_bit(&target);
> 
>   if (target) // double check ?
>       return false;
> 
>   // Our move must be a blocking evasion or a capture of the checking piece
>   target = squares_between(checksq, king_square(us)) | checkers();
>   return bit_is_set(target, to) && pl_move_is_legal(m, pinned);
947c646,650
< #else
---
> 
> /// Position::move_is_legal() takes a position and a (not necessarily pseudo-legal)
> /// move and tests whether the move is legal. This version is not very fast and
> /// should be used only in non time-critical paths.
> 
950,1077c653,654
< 	for (MoveList<MV_LEGAL> ml(*this); !ml.end(); ++ml)
< 		if (ml.move() == m)
< 			return true;
< 
< 	return false;
< }
< #endif
< 
< /// Position::is_pseudo_legal() takes a random move and tests whether the move
< /// is pseudo legal. It is used to validate moves from TT that can be corrupted
< /// due to SMP concurrent access or hash position key aliasing.
< 
< #if !defined(NANOHA)
< bool Position::is_pseudo_legal(const Move m) const {
< 
< 	Color us = sideToMove;
< 	Color them = flip(sideToMove);
< 	Square from = move_from(m);
< 	Square to = move_to(m);
< 	Piece pc = piece_on(from);
< 
< 	// Use a slower but simpler function for uncommon cases
< 	if (is_special(m))
< 		return move_is_legal(m);
< 
< 	// Is not a promotion, so promotion piece must be empty
< 	if (promotion_piece_type(m) - 2 != PIECE_TYPE_NONE)
< 		return false;
< 
< 	// If the from square is not occupied by a piece belonging to the side to
< 	// move, the move is obviously not legal.
< 	if (pc == PIECE_NONE || color_of(pc) != us)
< 		return false;
< 
< 	// The destination square cannot be occupied by a friendly piece
< 	if (color_of(piece_on(to)) == us)
< 		return false;
< 
< 	// Handle the special case of a pawn move
< 	if (type_of(pc) == PAWN)
< 	{
< 		// Move direction must be compatible with pawn color
< 		int direction = to - from;
< 		if ((us == WHITE) != (direction > 0))
< 			return false;
< 
< 		// We have already handled promotion moves, so destination
< 		// cannot be on the 8/1th rank.
< 		if (rank_of(to) == RANK_8 || rank_of(to) == RANK_1)
< 			return false;
< 
< 		// Proceed according to the square delta between the origin and
< 		// destination squares.
< 		switch (direction)
< 		{
< 		case DELTA_NW:
< 		case DELTA_NE:
< 		case DELTA_SW:
< 		case DELTA_SE:
< 		// Capture. The destination square must be occupied by an enemy
< 		// piece (en passant captures was handled earlier).
< 		if (color_of(piece_on(to)) != them)
< 			return false;
< 
< 		// From and to files must be one file apart, avoids a7h5
< 		if (abs(file_of(from) - file_of(to)) != 1)
< 			return false;
< 		break;
< 
< 		case DELTA_N:
< 		case DELTA_S:
< 		// Pawn push. The destination square must be empty.
< 			if (!square_is_empty(to))
< 				return false;
< 			break;
< 
< 		case DELTA_NN:
< 		// Double white pawn push. The destination square must be on the fourth
< 		// rank, and both the destination square and the square between the
< 		// source and destination squares must be empty.
< 		if (   rank_of(to) != RANK_4
< 		    || !square_is_empty(to)
< 		    || !square_is_empty(from + DELTA_N))
< 			return false;
< 			break;
< 
< 		case DELTA_SS:
< 		// Double black pawn push. The destination square must be on the fifth
< 		// rank, and both the destination square and the square between the
< 		// source and destination squares must be empty.
< 			if (   rank_of(to) != RANK_5
< 			    || !square_is_empty(to)
< 			    || !square_is_empty(from + DELTA_S))
< 				return false;
< 			break;
< 
< 		default:
< 			return false;
< 		}
< 	}
< 	else if (!bit_is_set(attacks_from(pc, from), to))
< 		return false;
< 
< 	if (in_check())
< 	{
< 		// In case of king moves under check we have to remove king so to catch
< 		// as invalid moves like b1a1 when opposite queen is on c1.
< 		if (type_of(piece_on(from)) == KING)
< 		{
< 			Bitboard b = occupied_squares();
< 			clear_bit(&b, from);
< 			if (attackers_to(move_to(m), b) & pieces(flip(us)))
< 				return false;
< 		}
< 		else
< 		{
< 			Bitboard target = checkers();
< 			Square checksq = pop_1st_bit(&target);
< 
< 			if (target) // double check ? In this case a king move is required
< 				return false;
< 
< 			// Our move must be a blocking evasion or a capture of the checking piece
< 			target = squares_between(checksq, king_square(us)) | checkers();
< 			if (!bit_is_set(target, move_to(m)))
< 				return false;
< 		}
< 	}
---
>   MoveStack mlist[MAX_MOVES];
>   MoveStack *cur, *last = generate<MV_PSEUDO_LEGAL>(*this, mlist);
1079c656,753
< 	return true;
---
>    for (cur = mlist; cur != last; cur++)
>       if (cur->move == m)
>           return pl_move_is_legal(m, pinned_pieces(sideToMove));
> 
>   return false;
> }
> 
> 
> /// Fast version of Position::move_is_legal() that takes a position a move and
> /// a bitboard of pinned pieces as input, and tests whether the move is legal.
> 
> bool Position::move_is_legal(const Move m, Bitboard pinned) const {
> 
>   assert(is_ok());
>   assert(pinned == pinned_pieces(sideToMove));
> 
>   Color us = sideToMove;
>   Color them = opposite_color(sideToMove);
>   Square from = move_from(m);
>   Square to = move_to(m);
>   Piece pc = piece_on(from);
> 
>   // Use a slower but simpler function for uncommon cases
>   if (move_is_special(m))
>       return move_is_legal(m);
> 
>   // If the from square is not occupied by a piece belonging to the side to
>   // move, the move is obviously not legal.
>   if (color_of_piece(pc) != us)
>       return false;
> 
>   // The destination square cannot be occupied by a friendly piece
>   if (color_of_piece_on(to) == us)
>       return false;
> 
>   // Handle the special case of a pawn move
>   if (type_of_piece(pc) == PAWN)
>   {
>       // Move direction must be compatible with pawn color
>       int direction = to - from;
>       if ((us == WHITE) != (direction > 0))
>           return false;
> 
>       // We have already handled promotion moves, so destination
>       // cannot be on the 8/1th rank.
>       if (square_rank(to) == RANK_8 || square_rank(to) == RANK_1)
>           return false;
> 
>       // Proceed according to the square delta between the origin and
>       // destination squares.
>       switch (direction)
>       {
>       case DELTA_NW:
>       case DELTA_NE:
>       case DELTA_SW:
>       case DELTA_SE:
>       // Capture. The destination square must be occupied by an enemy
>       // piece (en passant captures was handled earlier).
>           if (color_of_piece_on(to) != them)
>               return false;
>           break;
> 
>       case DELTA_N:
>       case DELTA_S:
>       // Pawn push. The destination square must be empty.
>           if (!square_is_empty(to))
>               return false;
>           break;
> 
>       case DELTA_NN:
>       // Double white pawn push. The destination square must be on the fourth
>       // rank, and both the destination square and the square between the
>       // source and destination squares must be empty.
>       if (   square_rank(to) != RANK_4
>           || !square_is_empty(to)
>           || !square_is_empty(from + DELTA_N))
>           return false;
>           break;
> 
>       case DELTA_SS:
>       // Double black pawn push. The destination square must be on the fifth
>       // rank, and both the destination square and the square between the
>       // source and destination squares must be empty.
>           if (   square_rank(to) != RANK_5
>               || !square_is_empty(to)
>               || !square_is_empty(from + DELTA_S))
>               return false;
>           break;
> 
>       default:
>           return false;
>       }
>   }
>   else if (!bit_is_set(attacks_from(pc, from), to))
>       return false;
> 
>   // The move is pseudo-legal, check if it is also legal
>   return in_check() ? pl_move_is_evasion(m, pinned) : pl_move_is_legal(m, pinned);
1081d754
< #endif
1083d755
< /// Position::move_gives_check() tests whether a pseudo-legal move gives a check
1085,1086c757
< #if !defined(NANOHA)
< bool Position::move_gives_check(Move m, const CheckInfo& ci) const {
---
> /// Position::move_gives_check() tests whether a pseudo-legal move is a check
1088,1171c759
< 	assert(is_ok(m));
< 	assert(ci.dcCandidates == discovered_check_candidates());
< 	assert(color_of(piece_on(move_from(m))) == side_to_move());
< 
< 	Square from = move_from(m);
< 	Square to = move_to(m);
< 	PieceType pt = type_of(piece_on(from));
< 
< 	// Direct check ?
< 	if (bit_is_set(ci.checkSq[pt], to))
< 		return true;
< 
< 	// Discovery check ?
< 	if (ci.dcCandidates && bit_is_set(ci.dcCandidates, from))
< 	{
< 		// For pawn and king moves we need to verify also direction
< 		if (  (pt != PAWN && pt != KING)
< 		    || !squares_aligned(from, to, king_square(flip(side_to_move()))))
< 			return true;
< 	}
< 
< 	// Can we skip the ugly special cases ?
< 	if (!is_special(m))
< 		return false;
< 
< 	Color us = side_to_move();
< 	Bitboard b = occupied_squares();
< 	Square ksq = king_square(flip(us));
< 
< 	// Promotion with check ?
< 	if (is_promotion(m))
< 	{
< 		clear_bit(&b, from);
< 
< 		switch (promotion_piece_type(m))
< 		{
< 		case KNIGHT:
< 			return bit_is_set(attacks_from<KNIGHT>(to), ksq);
< 		case BISHOP:
< 			return bit_is_set(bishop_attacks_bb(to, b), ksq);
< 		case ROOK:
< 			return bit_is_set(rook_attacks_bb(to, b), ksq);
< 		case QUEEN:
< 			return bit_is_set(queen_attacks_bb(to, b), ksq);
< 		default:
< 			assert(false);
< 		}
< 	}
< 
< 	// En passant capture with check ? We have already handled the case
< 	// of direct checks and ordinary discovered check, the only case we
< 	// need to handle is the unusual case of a discovered check through
< 	// the captured pawn.
< 	if (is_enpassant(m))
< 	{
< 		Square capsq = make_square(file_of(to), rank_of(from));
< 		clear_bit(&b, from);
< 		clear_bit(&b, capsq);
< 		set_bit(&b, to);
< 		return  (rook_attacks_bb(ksq, b) & pieces(ROOK, QUEEN, us))
< 		      ||(bishop_attacks_bb(ksq, b) & pieces(BISHOP, QUEEN, us));
< 	}
< 
< 	// Castling with check ?
< 	if (is_castle(m))
< 	{
< 		Square kfrom, kto, rfrom, rto;
< 		kfrom = from;
< 		rfrom = to;
< 
< 		if (rfrom > kfrom)
< 		{
< 			kto = relative_square(us, SQ_G1);
< 			rto = relative_square(us, SQ_F1);
< 		} else {
< 			kto = relative_square(us, SQ_C1);
< 			rto = relative_square(us, SQ_D1);
< 		}
< 		clear_bit(&b, kfrom);
< 		clear_bit(&b, rfrom);
< 		set_bit(&b, rto);
< 		set_bit(&b, kto);
< 		return bit_is_set(rook_attacks_bb(rto, b), ksq);
< 	}
---
> bool Position::move_gives_check(Move m) const {
1173c761
< 	return false;
---
>   return move_gives_check(m, CheckInfo(*this));
1175c763,877
< #endif
---
> 
> bool Position::move_gives_check(Move m, const CheckInfo& ci) const {
> 
>   assert(is_ok());
>   assert(move_is_ok(m));
>   assert(ci.dcCandidates == discovered_check_candidates(side_to_move()));
>   assert(color_of_piece_on(move_from(m)) == side_to_move());
>   assert(piece_on(ci.ksq) == make_piece(opposite_color(side_to_move()), KING));
> 
>   Square from = move_from(m);
>   Square to = move_to(m);
>   PieceType pt = type_of_piece_on(from);
> 
>   // Direct check ?
>   if (bit_is_set(ci.checkSq[pt], to))
>       return true;
> 
>   // Discovery check ?
>   if (ci.dcCandidates && bit_is_set(ci.dcCandidates, from))
>   {
>       // For pawn and king moves we need to verify also direction
>       if (  (pt != PAWN && pt != KING)
>           || !squares_aligned(from, to, ci.ksq))
>           return true;
>   }
> 
>   // Can we skip the ugly special cases ?
>   if (!move_is_special(m))
>       return false;
> 
>   Color us = side_to_move();
>   Bitboard b = occupied_squares();
> 
>   // Promotion with check ?
>   if (move_is_promotion(m))
>   {
>       clear_bit(&b, from);
> 
>       switch (move_promotion_piece(m))
>       {
>       case KNIGHT:
>           return bit_is_set(attacks_from<KNIGHT>(to), ci.ksq);
>       case BISHOP:
>           return bit_is_set(bishop_attacks_bb(to, b), ci.ksq);
>       case ROOK:
>           return bit_is_set(rook_attacks_bb(to, b), ci.ksq);
>       case QUEEN:
>           return bit_is_set(queen_attacks_bb(to, b), ci.ksq);
>       default:
>           assert(false);
>       }
>   }
> 
>   // En passant capture with check ? We have already handled the case
>   // of direct checks and ordinary discovered check, the only case we
>   // need to handle is the unusual case of a discovered check through
>   // the captured pawn.
>   if (move_is_ep(m))
>   {
>       Square capsq = make_square(square_file(to), square_rank(from));
>       clear_bit(&b, from);
>       clear_bit(&b, capsq);
>       set_bit(&b, to);
>       return  (rook_attacks_bb(ci.ksq, b) & pieces(ROOK, QUEEN, us))
>             ||(bishop_attacks_bb(ci.ksq, b) & pieces(BISHOP, QUEEN, us));
>   }
> 
>   // Castling with check ?
>   if (move_is_castle(m))
>   {
>       Square kfrom, kto, rfrom, rto;
>       kfrom = from;
>       rfrom = to;
> 
>       if (rfrom > kfrom)
>       {
>           kto = relative_square(us, SQ_G1);
>           rto = relative_square(us, SQ_F1);
>       } else {
>           kto = relative_square(us, SQ_C1);
>           rto = relative_square(us, SQ_D1);
>       }
>       clear_bit(&b, kfrom);
>       clear_bit(&b, rfrom);
>       set_bit(&b, rto);
>       set_bit(&b, kto);
>       return bit_is_set(rook_attacks_bb(rto, b), ci.ksq);
>   }
> 
>   return false;
> }
> 
> 
> /// Position::do_setup_move() makes a permanent move on the board. It should
> /// be used when setting up a position on board. You can't undo the move.
> 
> void Position::do_setup_move(Move m) {
> 
>   StateInfo newSt;
> 
>   do_move(m, newSt);
> 
>   // Reset "game ply" in case we made a non-reversible move.
>   // "game ply" is used for repetition detection.
>   if (st->rule50 == 0)
>       st->gamePly = 0;
> 
>   // Update the number of plies played from the starting position
>   startPosPlyCounter++;
> 
>   // Our StateInfo newSt is about going out of scope so copy
>   // its content before it disappears.
>   detach();
> }
> 
1180c882
< #if !defined(NANOHA)	// shogi.cppに定義
---
> 
1183,1184c885,886
< 	CheckInfo ci(*this);
< 	do_move(m, newSt, ci, move_gives_check(m, ci));
---
>   CheckInfo ci(*this);
>   do_move(m, newSt, ci, move_gives_check(m, ci));
1189,1382c891,1090
< 	assert(is_ok(m));
< 	assert(&newSt != st);
< 
< 	nodes++;
< 	Key key = st->key;
< 
< 	// Copy some fields of old state to our new StateInfo object except the
< 	// ones which are recalculated from scratch anyway, then switch our state
< 	// pointer to point to the new, ready to be updated, state.
< 	struct ReducedStateInfo {
< 		Key pawnKey, materialKey;
< 		Value npMaterial[2];
< 		int castleRights, rule50, pliesFromNull;
< 		Score value;
< 		Square epSquare;
< 	};
< 
< 	memcpy(&newSt, st, sizeof(ReducedStateInfo));
< 
< 	newSt.previous = st;
< 	st = &newSt;
< 
< 	// Update side to move
< 	key ^= zobSideToMove;
< 
< 	// Increment the 50 moves rule draw counter. Resetting it to zero in the
< 	// case of non-reversible moves is taken care of later.
< 	st->rule50++;
< 	st->pliesFromNull++;
< 
< 	if (is_castle(m))
< 	{
< 		st->key = key;
< 		do_castle_move(m);
< 		return;
< 	}
< 
< 	Color us = side_to_move();
< 	Color them = flip(us);
< 	Square from = move_from(m);
< 	Square to = move_to(m);
< 	bool ep = is_enpassant(m);
< 	bool pm = is_promotion(m);
< 
< 	Piece piece = piece_on(from);
< 	PieceType pt = type_of(piece);
< 	PieceType capture = ep ? PAWN : type_of(piece_on(to));
< 
< 	assert(color_of(piece_on(from)) == us);
< 	assert(color_of(piece_on(to)) == them || square_is_empty(to));
< 	assert(!(ep || pm) || piece == make_piece(us, PAWN));
< 	assert(!pm || relative_rank(us, to) == RANK_8);
< 
< 	if (capture)
< 		do_capture_move(key, capture, them, to, ep);
< 
< 	// Update hash key
< 	key ^= zobrist[us][pt][from] ^ zobrist[us][pt][to];
< 
< 	// Reset en passant square
< 	if (st->epSquare != SQ_NONE)
< 	{
< 		key ^= zobEp[st->epSquare];
< 		st->epSquare = SQ_NONE;
< 	}
< 
< 	// Update castle rights if needed
< 	if (    st->castleRights != CASTLES_NONE
< 	    && (castleRightsMask[from] & castleRightsMask[to]) != ALL_CASTLES)
< 	{
< 		key ^= zobCastle[st->castleRights];
< 		st->castleRights &= castleRightsMask[from] & castleRightsMask[to];
< 		key ^= zobCastle[st->castleRights];
< 	}
< 
< 	// Prefetch TT access as soon as we know key is updated
< 	prefetch((char*)TT.first_entry(key));
< 
< 	// Move the piece
< 	Bitboard move_bb = make_move_bb(from, to);
< 	do_move_bb(&byColorBB[us], move_bb);
< 	do_move_bb(&byTypeBB[pt], move_bb);
< 	do_move_bb(&byTypeBB[0], move_bb); // HACK: byTypeBB[0] == occupied squares
< 
< 	board[to] = board[from];
< 	board[from] = PIECE_NONE;
< 
< 	// Update piece lists, note that index[from] is not updated and
< 	// becomes stale. This works as long as index[] is accessed just
< 	// by known occupied squares.
< 	index[to] = index[from];
< 	pieceList[us][pt][index[to]] = to;
< 
< 	// If the moving piece was a pawn do some special extra work
< 	if (pt == PAWN)
< 	{
< 		// Reset rule 50 draw counter
< 		st->rule50 = 0;
< 
< 		// Update pawn hash key and prefetch in L1/L2 cache
< 		st->pawnKey ^= zobrist[us][PAWN][from] ^ zobrist[us][PAWN][to];
< 
< 		// Set en passant square, only if moved pawn can be captured
< 		if ((to ^ from) == 16)
< 		{
< 			if (attacks_from<PAWN>(from + pawn_push(us), us) & pieces(PAWN, them))
< 			{
< 				st->epSquare = Square((int(from) + int(to)) / 2);
< 				key ^= zobEp[st->epSquare];
< 			}
< 		}
< 
< 		if (pm) // promotion ?
< 		{
< 			PieceType promotion = promotion_piece_type(m);
< 
< 			assert(promotion >= KNIGHT && promotion <= QUEEN);
< 
< 			// Insert promoted piece instead of pawn
< 			clear_bit(&byTypeBB[PAWN], to);
< 			set_bit(&byTypeBB[promotion], to);
< 			board[to] = make_piece(us, promotion);
< 
< 			// Update piece counts
< 			pieceCount[us][promotion]++;
< 			pieceCount[us][PAWN]--;
< 
< 			// Update material key
< 			st->materialKey ^= zobrist[us][PAWN][pieceCount[us][PAWN]];
< 			st->materialKey ^= zobrist[us][promotion][pieceCount[us][promotion]-1];
< 
< 			// Update piece lists, move the last pawn at index[to] position
< 			// and shrink the list. Add a new promotion piece to the list.
< 			Square lastPawnSquare = pieceList[us][PAWN][pieceCount[us][PAWN]];
< 			index[lastPawnSquare] = index[to];
< 			pieceList[us][PAWN][index[lastPawnSquare]] = lastPawnSquare;
< 			pieceList[us][PAWN][pieceCount[us][PAWN]] = SQ_NONE;
< 			index[to] = pieceCount[us][promotion] - 1;
< 			pieceList[us][promotion][index[to]] = to;
< 
< 			// Partially revert hash keys update
< 			key ^= zobrist[us][PAWN][to] ^ zobrist[us][promotion][to];
< 			st->pawnKey ^= zobrist[us][PAWN][to];
< 
< 			// Partially revert and update incremental scores
< 			st->value -= pst(make_piece(us, PAWN), to);
< 			st->value += pst(make_piece(us, promotion), to);
< 
< 			// Update material
< 			st->npMaterial[us] += PieceValueMidgame[promotion];
< 		}
< 	}
< 
< 	// Prefetch pawn and material hash tables
< 	Threads[threadID].pawnTable.prefetch(st->pawnKey);
< 	Threads[threadID].materialTable.prefetch(st->materialKey);
< 
< 	// Update incremental scores
< 	st->value += pst_delta(piece, from, to);
< 
< 	// Set capture piece
< 	st->capturedType = capture;
< 
< 	// Update the key with the final value
< 	st->key = key;
< 
< 	// Update checkers bitboard, piece must be already moved
< 	st->checkersBB = EmptyBoardBB;
< 
< 	if (moveIsCheck)
< 	{
< 		if (ep | pm)
< 			st->checkersBB = attackers_to(king_square(them)) & pieces(us);
< 		else
< 		{
< 			// Direct checks
< 			if (bit_is_set(ci.checkSq[pt], to))
< 				st->checkersBB = SetMaskBB[to];
< 
< 			// Discovery checks
< 			if (ci.dcCandidates && bit_is_set(ci.dcCandidates, from))
< 			{
< 				if (pt != ROOK)
< 					st->checkersBB |= (attacks_from<ROOK>(king_square(them)) & pieces(ROOK, QUEEN, us));
< 
< 				if (pt != BISHOP)
< 					st->checkersBB |= (attacks_from<BISHOP>(king_square(them)) & pieces(BISHOP, QUEEN, us));
< 			}
< 		}
< 	}
< 
< 	// Finish
< 	sideToMove = flip(sideToMove);
< 	st->value += (sideToMove == WHITE ?  TempoValue : -TempoValue);
---
>   assert(is_ok());
>   assert(move_is_ok(m));
>   assert(&newSt != st);
> 
>   nodes++;
>   Key key = st->key;
> 
>   // Copy some fields of old state to our new StateInfo object except the
>   // ones which are recalculated from scratch anyway, then switch our state
>   // pointer to point to the new, ready to be updated, state.
>   struct ReducedStateInfo {
>     Key pawnKey, materialKey;
>     int castleRights, rule50, gamePly, pliesFromNull;
>     Square epSquare;
>     Score value;
>     Value npMaterial[2];
>   };
> 
>   memcpy(&newSt, st, sizeof(ReducedStateInfo));
> 
>   newSt.previous = st;
>   st = &newSt;
> 
>   // Save the current key to the history[] array, in order to be able to
>   // detect repetition draws.
>   history[st->gamePly++] = key;
> 
>   // Update side to move
>   key ^= zobSideToMove;
> 
>   // Increment the 50 moves rule draw counter. Resetting it to zero in the
>   // case of non-reversible moves is taken care of later.
>   st->rule50++;
>   st->pliesFromNull++;
> 
>   if (move_is_castle(m))
>   {
>       st->key = key;
>       do_castle_move(m);
>       return;
>   }
> 
>   Color us = side_to_move();
>   Color them = opposite_color(us);
>   Square from = move_from(m);
>   Square to = move_to(m);
>   bool ep = move_is_ep(m);
>   bool pm = move_is_promotion(m);
> 
>   Piece piece = piece_on(from);
>   PieceType pt = type_of_piece(piece);
>   PieceType capture = ep ? PAWN : type_of_piece_on(to);
> 
>   assert(color_of_piece_on(from) == us);
>   assert(color_of_piece_on(to) == them || square_is_empty(to));
>   assert(!(ep || pm) || piece == make_piece(us, PAWN));
>   assert(!pm || relative_rank(us, to) == RANK_8);
> 
>   if (capture)
>       do_capture_move(key, capture, them, to, ep);
> 
>   // Update hash key
>   key ^= zobrist[us][pt][from] ^ zobrist[us][pt][to];
> 
>   // Reset en passant square
>   if (st->epSquare != SQ_NONE)
>   {
>       key ^= zobEp[st->epSquare];
>       st->epSquare = SQ_NONE;
>   }
> 
>   // Update castle rights, try to shortcut a common case
>   int cm = castleRightsMask[from] & castleRightsMask[to];
>   if (cm != ALL_CASTLES && ((cm & st->castleRights) != st->castleRights))
>   {
>       key ^= zobCastle[st->castleRights];
>       st->castleRights &= castleRightsMask[from];
>       st->castleRights &= castleRightsMask[to];
>       key ^= zobCastle[st->castleRights];
>   }
> 
>   // Prefetch TT access as soon as we know key is updated
>   prefetch((char*)TT.first_entry(key));
> 
>   // Move the piece
>   Bitboard move_bb = make_move_bb(from, to);
>   do_move_bb(&(byColorBB[us]), move_bb);
>   do_move_bb(&(byTypeBB[pt]), move_bb);
>   do_move_bb(&(byTypeBB[0]), move_bb); // HACK: byTypeBB[0] == occupied squares
> 
>   board[to] = board[from];
>   board[from] = PIECE_NONE;
> 
>   // Update piece lists, note that index[from] is not updated and
>   // becomes stale. This works as long as index[] is accessed just
>   // by known occupied squares.
>   index[to] = index[from];
>   pieceList[us][pt][index[to]] = to;
> 
>   // If the moving piece was a pawn do some special extra work
>   if (pt == PAWN)
>   {
>       // Reset rule 50 draw counter
>       st->rule50 = 0;
> 
>       // Update pawn hash key and prefetch in L1/L2 cache
>       st->pawnKey ^= zobrist[us][PAWN][from] ^ zobrist[us][PAWN][to];
> 
>       // Set en passant square, only if moved pawn can be captured
>       if ((to ^ from) == 16)
>       {
>           if (attacks_from<PAWN>(from + (us == WHITE ? DELTA_N : DELTA_S), us) & pieces(PAWN, them))
>           {
>               st->epSquare = Square((int(from) + int(to)) / 2);
>               key ^= zobEp[st->epSquare];
>           }
>       }
> 
>       if (pm) // promotion ?
>       {
>           PieceType promotion = move_promotion_piece(m);
> 
>           assert(promotion >= KNIGHT && promotion <= QUEEN);
> 
>           // Insert promoted piece instead of pawn
>           clear_bit(&(byTypeBB[PAWN]), to);
>           set_bit(&(byTypeBB[promotion]), to);
>           board[to] = make_piece(us, promotion);
> 
>           // Update piece counts
>           pieceCount[us][promotion]++;
>           pieceCount[us][PAWN]--;
> 
>           // Update material key
>           st->materialKey ^= zobrist[us][PAWN][pieceCount[us][PAWN]];
>           st->materialKey ^= zobrist[us][promotion][pieceCount[us][promotion]-1];
> 
>           // Update piece lists, move the last pawn at index[to] position
>           // and shrink the list. Add a new promotion piece to the list.
>           Square lastPawnSquare = pieceList[us][PAWN][pieceCount[us][PAWN]];
>           index[lastPawnSquare] = index[to];
>           pieceList[us][PAWN][index[lastPawnSquare]] = lastPawnSquare;
>           pieceList[us][PAWN][pieceCount[us][PAWN]] = SQ_NONE;
>           index[to] = pieceCount[us][promotion] - 1;
>           pieceList[us][promotion][index[to]] = to;
> 
>           // Partially revert hash keys update
>           key ^= zobrist[us][PAWN][to] ^ zobrist[us][promotion][to];
>           st->pawnKey ^= zobrist[us][PAWN][to];
> 
>           // Partially revert and update incremental scores
>           st->value -= pst(us, PAWN, to);
>           st->value += pst(us, promotion, to);
> 
>           // Update material
>           st->npMaterial[us] += PieceValueMidgame[promotion];
>       }
>   }
> 
>   // Prefetch pawn and material hash tables
>   Threads[threadID].pawnTable.prefetch(st->pawnKey);
>   Threads[threadID].materialTable.prefetch(st->materialKey);
> 
>   // Update incremental scores
>   st->value += pst_delta(piece, from, to);
> 
>   // Set capture piece
>   st->capturedType = capture;
> 
>   // Update the key with the final value
>   st->key = key;
> 
>   // Update checkers bitboard, piece must be already moved
>   st->checkersBB = EmptyBoardBB;
> 
>   if (moveIsCheck)
>   {
>       if (ep | pm)
>           st->checkersBB = attackers_to(king_square(them)) & pieces_of_color(us);
>       else
>       {
>           // Direct checks
>           if (bit_is_set(ci.checkSq[pt], to))
>               st->checkersBB = SetMaskBB[to];
> 
>           // Discovery checks
>           if (ci.dcCandidates && bit_is_set(ci.dcCandidates, from))
>           {
>               if (pt != ROOK)
>                   st->checkersBB |= (attacks_from<ROOK>(ci.ksq) & pieces(ROOK, QUEEN, us));
> 
>               if (pt != BISHOP)
>                   st->checkersBB |= (attacks_from<BISHOP>(ci.ksq) & pieces(BISHOP, QUEEN, us));
>           }
>       }
>   }
> 
>   // Finish
>   sideToMove = opposite_color(sideToMove);
>   st->value += (sideToMove == WHITE ?  TempoValue : -TempoValue);
1384c1092
< 	assert(is_ok());
---
>   assert(is_ok());
1393c1101
< 	assert(capture != KING);
---
>     assert(capture != KING);
1395c1103
< 	Square capsq = to;
---
>     Square capsq = to;
1397,1444c1105,1152
< 	// If the captured piece was a pawn, update pawn hash key,
< 	// otherwise update non-pawn material.
< 	if (capture == PAWN)
< 	{
< 		if (ep) // en passant ?
< 		{
< 			capsq = to + pawn_push(them);
< 
< 			assert(to == st->epSquare);
< 			assert(relative_rank(flip(them), to) == RANK_6);
< 			assert(piece_on(to) == PIECE_NONE);
< 			assert(piece_on(capsq) == make_piece(them, PAWN));
< 
< 			board[capsq] = PIECE_NONE;
< 		}
< 		st->pawnKey ^= zobrist[them][PAWN][capsq];
< 	}
< 	else
< 		st->npMaterial[them] -= PieceValueMidgame[capture];
< 
< 	// Remove captured piece
< 	clear_bit(&byColorBB[them], capsq);
< 	clear_bit(&byTypeBB[capture], capsq);
< 	clear_bit(&byTypeBB[0], capsq);
< 
< 	// Update hash key
< 	key ^= zobrist[them][capture][capsq];
< 
< 	// Update incremental scores
< 	st->value -= pst(make_piece(them, capture), capsq);
< 
< 	// Update piece count
< 	pieceCount[them][capture]--;
< 
< 	// Update material hash key
< 	st->materialKey ^= zobrist[them][capture][pieceCount[them][capture]];
< 
< 	// Update piece list, move the last piece at index[capsq] position
< 	//
< 	// WARNING: This is a not perfectly revresible operation. When we
< 	// will reinsert the captured piece in undo_move() we will put it
< 	// at the end of the list and not in its original place, it means
< 	// index[] and pieceList[] are not guaranteed to be invariant to a
< 	// do_move() + undo_move() sequence.
< 	Square lastPieceSquare = pieceList[them][capture][pieceCount[them][capture]];
< 	index[lastPieceSquare] = index[capsq];
< 	pieceList[them][capture][index[lastPieceSquare]] = lastPieceSquare;
< 	pieceList[them][capture][pieceCount[them][capture]] = SQ_NONE;
---
>     // If the captured piece was a pawn, update pawn hash key,
>     // otherwise update non-pawn material.
>     if (capture == PAWN)
>     {
>         if (ep) // en passant ?
>         {
>             capsq = (them == BLACK)? (to - DELTA_N) : (to - DELTA_S);
> 
>             assert(to == st->epSquare);
>             assert(relative_rank(opposite_color(them), to) == RANK_6);
>             assert(piece_on(to) == PIECE_NONE);
>             assert(piece_on(capsq) == make_piece(them, PAWN));
> 
>             board[capsq] = PIECE_NONE;
>         }
>         st->pawnKey ^= zobrist[them][PAWN][capsq];
>     }
>     else
>         st->npMaterial[them] -= PieceValueMidgame[capture];
> 
>     // Remove captured piece
>     clear_bit(&(byColorBB[them]), capsq);
>     clear_bit(&(byTypeBB[capture]), capsq);
>     clear_bit(&(byTypeBB[0]), capsq);
> 
>     // Update hash key
>     key ^= zobrist[them][capture][capsq];
> 
>     // Update incremental scores
>     st->value -= pst(them, capture, capsq);
> 
>     // Update piece count
>     pieceCount[them][capture]--;
> 
>     // Update material hash key
>     st->materialKey ^= zobrist[them][capture][pieceCount[them][capture]];
> 
>     // Update piece list, move the last piece at index[capsq] position
>     //
>     // WARNING: This is a not perfectly revresible operation. When we
>     // will reinsert the captured piece in undo_move() we will put it
>     // at the end of the list and not in its original place, it means
>     // index[] and pieceList[] are not guaranteed to be invariant to a
>     // do_move() + undo_move() sequence.
>     Square lastPieceSquare = pieceList[them][capture][pieceCount[them][capture]];
>     index[lastPieceSquare] = index[capsq];
>     pieceList[them][capture][index[lastPieceSquare]] = lastPieceSquare;
>     pieceList[them][capture][pieceCount[them][capture]] = SQ_NONE;
1446,1447c1154,1155
< 	// Reset rule 50 counter
< 	st->rule50 = 0;
---
>     // Reset rule 50 counter
>     st->rule50 = 0;
1458,1459c1166,1167
< 	assert(is_ok(m));
< 	assert(is_castle(m));
---
>   assert(move_is_ok(m));
>   assert(move_is_castle(m));
1461,1462c1169,1170
< 	Color us = side_to_move();
< 	Color them = flip(us);
---
>   Color us = side_to_move();
>   Color them = opposite_color(us);
1464,1545c1172,1173
< 	// Find source squares for king and rook
< 	Square kfrom = move_from(m);
< 	Square rfrom = move_to(m);
< 	Square kto, rto;
< 
< 	assert(piece_on(kfrom) == make_piece(us, KING));
< 	assert(piece_on(rfrom) == make_piece(us, ROOK));
< 
< 	// Find destination squares for king and rook
< 	if (rfrom > kfrom) // O-O
< 	{
< 		kto = relative_square(us, SQ_G1);
< 		rto = relative_square(us, SQ_F1);
< 	}
< 	else // O-O-O
< 	{
< 		kto = relative_square(us, SQ_C1);
< 		rto = relative_square(us, SQ_D1);
< 	}
< 
< 	// Remove pieces from source squares
< 	clear_bit(&byColorBB[us], kfrom);
< 	clear_bit(&byTypeBB[KING], kfrom);
< 	clear_bit(&byTypeBB[0], kfrom);
< 	clear_bit(&byColorBB[us], rfrom);
< 	clear_bit(&byTypeBB[ROOK], rfrom);
< 	clear_bit(&byTypeBB[0], rfrom);
< 
< 	// Put pieces on destination squares
< 	set_bit(&byColorBB[us], kto);
< 	set_bit(&byTypeBB[KING], kto);
< 	set_bit(&byTypeBB[0], kto);
< 	set_bit(&byColorBB[us], rto);
< 	set_bit(&byTypeBB[ROOK], rto);
< 	set_bit(&byTypeBB[0], rto);
< 
< 	// Update board
< 	Piece king = make_piece(us, KING);
< 	Piece rook = make_piece(us, ROOK);
< 	board[kfrom] = board[rfrom] = PIECE_NONE;
< 	board[kto] = king;
< 	board[rto] = rook;
< 
< 	// Update piece lists
< 	pieceList[us][KING][index[kfrom]] = kto;
< 	pieceList[us][ROOK][index[rfrom]] = rto;
< 	int tmp = index[rfrom]; // In Chess960 could be kto == rfrom
< 	index[kto] = index[kfrom];
< 	index[rto] = tmp;
< 
< 	// Reset capture field
< 	st->capturedType = PIECE_TYPE_NONE;
< 
< 	// Update incremental scores
< 	st->value += pst_delta(king, kfrom, kto);
< 	st->value += pst_delta(rook, rfrom, rto);
< 
< 	// Update hash key
< 	st->key ^= zobrist[us][KING][kfrom] ^ zobrist[us][KING][kto];
< 	st->key ^= zobrist[us][ROOK][rfrom] ^ zobrist[us][ROOK][rto];
< 
< 	// Clear en passant square
< 	if (st->epSquare != SQ_NONE)
< 	{
< 		st->key ^= zobEp[st->epSquare];
< 		st->epSquare = SQ_NONE;
< 	}
< 
< 	// Update castling rights
< 	st->key ^= zobCastle[st->castleRights];
< 	st->castleRights &= castleRightsMask[kfrom];
< 	st->key ^= zobCastle[st->castleRights];
< 
< 	// Reset rule 50 counter
< 	st->rule50 = 0;
< 
< 	// Update checkers BB
< 	st->checkersBB = attackers_to(king_square(them)) & pieces(us);
< 
< 	// Finish
< 	sideToMove = flip(sideToMove);
< 	st->value += (sideToMove == WHITE ?  TempoValue : -TempoValue);
---
>   // Reset capture field
>   st->capturedType = PIECE_TYPE_NONE;
1547c1175,1253
< 	assert(is_ok());
---
>   // Find source squares for king and rook
>   Square kfrom = move_from(m);
>   Square rfrom = move_to(m);  // HACK: See comment at beginning of function
>   Square kto, rto;
> 
>   assert(piece_on(kfrom) == make_piece(us, KING));
>   assert(piece_on(rfrom) == make_piece(us, ROOK));
> 
>   // Find destination squares for king and rook
>   if (rfrom > kfrom) // O-O
>   {
>       kto = relative_square(us, SQ_G1);
>       rto = relative_square(us, SQ_F1);
>   } else { // O-O-O
>       kto = relative_square(us, SQ_C1);
>       rto = relative_square(us, SQ_D1);
>   }
> 
>   // Remove pieces from source squares:
>   clear_bit(&(byColorBB[us]), kfrom);
>   clear_bit(&(byTypeBB[KING]), kfrom);
>   clear_bit(&(byTypeBB[0]), kfrom); // HACK: byTypeBB[0] == occupied squares
>   clear_bit(&(byColorBB[us]), rfrom);
>   clear_bit(&(byTypeBB[ROOK]), rfrom);
>   clear_bit(&(byTypeBB[0]), rfrom); // HACK: byTypeBB[0] == occupied squares
> 
>   // Put pieces on destination squares:
>   set_bit(&(byColorBB[us]), kto);
>   set_bit(&(byTypeBB[KING]), kto);
>   set_bit(&(byTypeBB[0]), kto); // HACK: byTypeBB[0] == occupied squares
>   set_bit(&(byColorBB[us]), rto);
>   set_bit(&(byTypeBB[ROOK]), rto);
>   set_bit(&(byTypeBB[0]), rto); // HACK: byTypeBB[0] == occupied squares
> 
>   // Update board array
>   Piece king = make_piece(us, KING);
>   Piece rook = make_piece(us, ROOK);
>   board[kfrom] = board[rfrom] = PIECE_NONE;
>   board[kto] = king;
>   board[rto] = rook;
> 
>   // Update piece lists
>   pieceList[us][KING][index[kfrom]] = kto;
>   pieceList[us][ROOK][index[rfrom]] = rto;
>   int tmp = index[rfrom]; // In Chess960 could be rto == kfrom
>   index[kto] = index[kfrom];
>   index[rto] = tmp;
> 
>   // Update incremental scores
>   st->value += pst_delta(king, kfrom, kto);
>   st->value += pst_delta(rook, rfrom, rto);
> 
>   // Update hash key
>   st->key ^= zobrist[us][KING][kfrom] ^ zobrist[us][KING][kto];
>   st->key ^= zobrist[us][ROOK][rfrom] ^ zobrist[us][ROOK][rto];
> 
>   // Clear en passant square
>   if (st->epSquare != SQ_NONE)
>   {
>       st->key ^= zobEp[st->epSquare];
>       st->epSquare = SQ_NONE;
>   }
> 
>   // Update castling rights
>   st->key ^= zobCastle[st->castleRights];
>   st->castleRights &= castleRightsMask[kfrom];
>   st->key ^= zobCastle[st->castleRights];
> 
>   // Reset rule 50 counter
>   st->rule50 = 0;
> 
>   // Update checkers BB
>   st->checkersBB = attackers_to(king_square(them)) & pieces_of_color(us);
> 
>   // Finish
>   sideToMove = opposite_color(sideToMove);
>   st->value += (sideToMove == WHITE ?  TempoValue : -TempoValue);
> 
>   assert(is_ok());
1556c1262,1263
< 	assert(is_ok(m));
---
>   assert(is_ok());
>   assert(move_is_ok(m));
1558c1265
< 	sideToMove = flip(sideToMove);
---
>   sideToMove = opposite_color(sideToMove);
1560,1643c1267,1350
< 	if (is_castle(m))
< 	{
< 		undo_castle_move(m);
< 		return;
< 	}
< 
< 	Color us = side_to_move();
< 	Color them = flip(us);
< 	Square from = move_from(m);
< 	Square to = move_to(m);
< 	bool ep = is_enpassant(m);
< 	bool pm = is_promotion(m);
< 
< 	PieceType pt = type_of(piece_on(to));
< 
< 	assert(square_is_empty(from));
< 	assert(color_of(piece_on(to)) == us);
< 	assert(!pm || relative_rank(us, to) == RANK_8);
< 	assert(!ep || to == st->previous->epSquare);
< 	assert(!ep || relative_rank(us, to) == RANK_6);
< 	assert(!ep || piece_on(to) == make_piece(us, PAWN));
< 
< 	if (pm) // promotion ?
< 	{
< 		PieceType promotion = promotion_piece_type(m);
< 		pt = PAWN;
< 
< 		assert(promotion >= KNIGHT && promotion <= QUEEN);
< 		assert(piece_on(to) == make_piece(us, promotion));
< 
< 		// Replace promoted piece with a pawn
< 		clear_bit(&byTypeBB[promotion], to);
< 		set_bit(&byTypeBB[PAWN], to);
< 
< 		// Update piece counts
< 		pieceCount[us][promotion]--;
< 		pieceCount[us][PAWN]++;
< 
< 		// Update piece list replacing promotion piece with a pawn
< 		Square lastPromotionSquare = pieceList[us][promotion][pieceCount[us][promotion]];
< 		index[lastPromotionSquare] = index[to];
< 		pieceList[us][promotion][index[lastPromotionSquare]] = lastPromotionSquare;
< 		pieceList[us][promotion][pieceCount[us][promotion]] = SQ_NONE;
< 		index[to] = pieceCount[us][PAWN] - 1;
< 		pieceList[us][PAWN][index[to]] = to;
< 	}
< 
< 	// Put the piece back at the source square
< 	Bitboard move_bb = make_move_bb(to, from);
< 	do_move_bb(&byColorBB[us], move_bb);
< 	do_move_bb(&byTypeBB[pt], move_bb);
< 	do_move_bb(&byTypeBB[0], move_bb); // HACK: byTypeBB[0] == occupied squares
< 
< 	board[from] = make_piece(us, pt);
< 	board[to] = PIECE_NONE;
< 
< 	// Update piece list
< 	index[from] = index[to];
< 	pieceList[us][pt][index[from]] = from;
< 
< 	if (st->capturedType)
< 	{
< 		Square capsq = to;
< 
< 		if (ep)
< 			capsq = to - pawn_push(us);
< 
< 		assert(st->capturedType != KING);
< 		assert(!ep || square_is_empty(capsq));
< 
< 		// Restore the captured piece
< 		set_bit(&byColorBB[them], capsq);
< 		set_bit(&byTypeBB[st->capturedType], capsq);
< 		set_bit(&byTypeBB[0], capsq);
< 
< 		board[capsq] = make_piece(them, st->capturedType);
< 
< 		// Update piece count
< 		pieceCount[them][st->capturedType]++;
< 
< 		// Update piece list, add a new captured piece in capsq square
< 		index[capsq] = pieceCount[them][st->capturedType] - 1;
< 		pieceList[them][st->capturedType][index[capsq]] = capsq;
< 	}
---
>   if (move_is_castle(m))
>   {
>       undo_castle_move(m);
>       return;
>   }
> 
>   Color us = side_to_move();
>   Color them = opposite_color(us);
>   Square from = move_from(m);
>   Square to = move_to(m);
>   bool ep = move_is_ep(m);
>   bool pm = move_is_promotion(m);
> 
>   PieceType pt = type_of_piece_on(to);
> 
>   assert(square_is_empty(from));
>   assert(color_of_piece_on(to) == us);
>   assert(!pm || relative_rank(us, to) == RANK_8);
>   assert(!ep || to == st->previous->epSquare);
>   assert(!ep || relative_rank(us, to) == RANK_6);
>   assert(!ep || piece_on(to) == make_piece(us, PAWN));
> 
>   if (pm) // promotion ?
>   {
>       PieceType promotion = move_promotion_piece(m);
>       pt = PAWN;
> 
>       assert(promotion >= KNIGHT && promotion <= QUEEN);
>       assert(piece_on(to) == make_piece(us, promotion));
> 
>       // Replace promoted piece with a pawn
>       clear_bit(&(byTypeBB[promotion]), to);
>       set_bit(&(byTypeBB[PAWN]), to);
> 
>       // Update piece counts
>       pieceCount[us][promotion]--;
>       pieceCount[us][PAWN]++;
> 
>       // Update piece list replacing promotion piece with a pawn
>       Square lastPromotionSquare = pieceList[us][promotion][pieceCount[us][promotion]];
>       index[lastPromotionSquare] = index[to];
>       pieceList[us][promotion][index[lastPromotionSquare]] = lastPromotionSquare;
>       pieceList[us][promotion][pieceCount[us][promotion]] = SQ_NONE;
>       index[to] = pieceCount[us][PAWN] - 1;
>       pieceList[us][PAWN][index[to]] = to;
>   }
> 
>   // Put the piece back at the source square
>   Bitboard move_bb = make_move_bb(to, from);
>   do_move_bb(&(byColorBB[us]), move_bb);
>   do_move_bb(&(byTypeBB[pt]), move_bb);
>   do_move_bb(&(byTypeBB[0]), move_bb); // HACK: byTypeBB[0] == occupied squares
> 
>   board[from] = make_piece(us, pt);
>   board[to] = PIECE_NONE;
> 
>   // Update piece list
>   index[from] = index[to];
>   pieceList[us][pt][index[from]] = from;
> 
>   if (st->capturedType)
>   {
>       Square capsq = to;
> 
>       if (ep)
>           capsq = (us == WHITE)? (to - DELTA_N) : (to - DELTA_S);
> 
>       assert(st->capturedType != KING);
>       assert(!ep || square_is_empty(capsq));
> 
>       // Restore the captured piece
>       set_bit(&(byColorBB[them]), capsq);
>       set_bit(&(byTypeBB[st->capturedType]), capsq);
>       set_bit(&(byTypeBB[0]), capsq);
> 
>       board[capsq] = make_piece(them, st->capturedType);
> 
>       // Update piece count
>       pieceCount[them][st->capturedType]++;
> 
>       // Update piece list, add a new captured piece in capsq square
>       index[capsq] = pieceCount[them][st->capturedType] - 1;
>       pieceList[them][st->capturedType][index[capsq]] = capsq;
>   }
1645,1646c1352,1353
< 	// Finally point our state pointer back to the previous state
< 	st = st->previous;
---
>   // Finally point our state pointer back to the previous state
>   st = st->previous;
1648c1355
< 	assert(is_ok());
---
>   assert(is_ok());
1659,1660c1366,1367
< 	assert(is_ok(m));
< 	assert(is_castle(m));
---
>   assert(move_is_ok(m));
>   assert(move_is_castle(m));
1662,1715c1369,1418
< 	// When we have arrived here, some work has already been done by
< 	// Position::undo_move.  In particular, the side to move has been switched,
< 	// so the code below is correct.
< 	Color us = side_to_move();
< 
< 	// Find source squares for king and rook
< 	Square kfrom = move_from(m);
< 	Square rfrom = move_to(m);
< 	Square kto, rto;
< 
< 	// Find destination squares for king and rook
< 	if (rfrom > kfrom) // O-O
< 	{
< 		kto = relative_square(us, SQ_G1);
< 		rto = relative_square(us, SQ_F1);
< 	}
< 	else // O-O-O
< 	{
< 		kto = relative_square(us, SQ_C1);
< 		rto = relative_square(us, SQ_D1);
< 	}
< 
< 	assert(piece_on(kto) == make_piece(us, KING));
< 	assert(piece_on(rto) == make_piece(us, ROOK));
< 
< 	// Remove pieces from destination squares
< 	clear_bit(&byColorBB[us], kto);
< 	clear_bit(&byTypeBB[KING], kto);
< 	clear_bit(&byTypeBB[0], kto);
< 	clear_bit(&byColorBB[us], rto);
< 	clear_bit(&byTypeBB[ROOK], rto);
< 	clear_bit(&byTypeBB[0], rto);
< 
< 	// Put pieces on source squares
< 	set_bit(&byColorBB[us], kfrom);
< 	set_bit(&byTypeBB[KING], kfrom);
< 	set_bit(&byTypeBB[0], kfrom);
< 	set_bit(&byColorBB[us], rfrom);
< 	set_bit(&byTypeBB[ROOK], rfrom);
< 	set_bit(&byTypeBB[0], rfrom);
< 
< 	// Update board
< 	Piece king = make_piece(us, KING);
< 	Piece rook = make_piece(us, ROOK);
< 	board[kto] = board[rto] = PIECE_NONE;
< 	board[kfrom] = king;
< 	board[rfrom] = rook;
< 
< 	// Update piece lists
< 	pieceList[us][KING][index[kto]] = kfrom;
< 	pieceList[us][ROOK][index[rto]] = rfrom;
< 	int tmp = index[rto];  // In Chess960 could be rto == kfrom
< 	index[kfrom] = index[kto];
< 	index[rfrom] = tmp;
---
>   // When we have arrived here, some work has already been done by
>   // Position::undo_move.  In particular, the side to move has been switched,
>   // so the code below is correct.
>   Color us = side_to_move();
> 
>   // Find source squares for king and rook
>   Square kfrom = move_from(m);
>   Square rfrom = move_to(m);  // HACK: See comment at beginning of function
>   Square kto, rto;
> 
>   // Find destination squares for king and rook
>   if (rfrom > kfrom) // O-O
>   {
>       kto = relative_square(us, SQ_G1);
>       rto = relative_square(us, SQ_F1);
>   } else { // O-O-O
>       kto = relative_square(us, SQ_C1);
>       rto = relative_square(us, SQ_D1);
>   }
> 
>   assert(piece_on(kto) == make_piece(us, KING));
>   assert(piece_on(rto) == make_piece(us, ROOK));
> 
>   // Remove pieces from destination squares:
>   clear_bit(&(byColorBB[us]), kto);
>   clear_bit(&(byTypeBB[KING]), kto);
>   clear_bit(&(byTypeBB[0]), kto); // HACK: byTypeBB[0] == occupied squares
>   clear_bit(&(byColorBB[us]), rto);
>   clear_bit(&(byTypeBB[ROOK]), rto);
>   clear_bit(&(byTypeBB[0]), rto); // HACK: byTypeBB[0] == occupied squares
> 
>   // Put pieces on source squares:
>   set_bit(&(byColorBB[us]), kfrom);
>   set_bit(&(byTypeBB[KING]), kfrom);
>   set_bit(&(byTypeBB[0]), kfrom); // HACK: byTypeBB[0] == occupied squares
>   set_bit(&(byColorBB[us]), rfrom);
>   set_bit(&(byTypeBB[ROOK]), rfrom);
>   set_bit(&(byTypeBB[0]), rfrom); // HACK: byTypeBB[0] == occupied squares
> 
>   // Update board
>   board[rto] = board[kto] = PIECE_NONE;
>   board[rfrom] = make_piece(us, ROOK);
>   board[kfrom] = make_piece(us, KING);
> 
>   // Update piece lists
>   pieceList[us][KING][index[kto]] = kfrom;
>   pieceList[us][ROOK][index[rto]] = rfrom;
>   int tmp = index[rto];  // In Chess960 could be rto == kfrom
>   index[kfrom] = index[kto];
>   index[rfrom] = tmp;
1717,1718c1420,1421
< 	// Finally point our state pointer back to the previous state
< 	st = st->previous;
---
>   // Finally point our state pointer back to the previous state
>   st = st->previous;
1720c1423
< 	assert(is_ok());
---
>   assert(is_ok());
1722d1424
< #endif
1730c1432,1433
< 	assert(!in_check());
---
>   assert(is_ok());
>   assert(!in_check());
1732,1769c1435,1461
< 	// Back up the information necessary to undo the null move to the supplied
< 	// StateInfo object.
< 	// Note that differently from normal case here backupSt is actually used as
< 	// a backup storage not as a new state to be used.
< 	backupSt.key      = st->key;
< #if !defined(NANOHA)
< 	backupSt.epSquare = st->epSquare;
< 	backupSt.value    = st->value;
< #endif
< 	backupSt.previous = st->previous;
< 	backupSt.pliesFromNull = st->pliesFromNull;
< 	st->previous = &backupSt;
< 
< #if !defined(NANOHA)
< 	// Update the necessary information
< 	if (st->epSquare != SQ_NONE)
< 		st->key ^= zobEp[st->epSquare];
< #endif
< 
< 	st->key ^= zobSideToMove;
< 	prefetch((char*)TT.first_entry(st->key));
< 
< 	sideToMove = flip(sideToMove);
< #if !defined(NANOHA)
< 	st->epSquare = SQ_NONE;
< 	st->rule50++;
< #endif
< 	st->pliesFromNull = 0;
< #if !defined(NANOHA)
< 	st->value += (sideToMove == WHITE) ?  TempoValue : -TempoValue;
< #endif
< #if defined(NANOHA)
< 	if (in_check()) {
< 	print_csa();
< 	MYABORT();
< 	}
< #endif
< 	assert(is_ok());
---
>   // Back up the information necessary to undo the null move to the supplied
>   // StateInfo object.
>   // Note that differently from normal case here backupSt is actually used as
>   // a backup storage not as a new state to be used.
>   backupSt.key      = st->key;
>   backupSt.epSquare = st->epSquare;
>   backupSt.value    = st->value;
>   backupSt.previous = st->previous;
>   backupSt.pliesFromNull = st->pliesFromNull;
>   st->previous = &backupSt;
> 
>   // Save the current key to the history[] array, in order to be able to
>   // detect repetition draws.
>   history[st->gamePly++] = st->key;
> 
>   // Update the necessary information
>   if (st->epSquare != SQ_NONE)
>       st->key ^= zobEp[st->epSquare];
> 
>   st->key ^= zobSideToMove;
>   prefetch((char*)TT.first_entry(st->key));
> 
>   sideToMove = opposite_color(sideToMove);
>   st->epSquare = SQ_NONE;
>   st->rule50++;
>   st->pliesFromNull = 0;
>   st->value += (sideToMove == WHITE) ?  TempoValue : -TempoValue;
1777,1801c1469,1483
< #if defined(NANOHA)
< 	if (in_check()) {
< 	print_csa();
< 	MYABORT();
< 	}
< #else
< 	assert(!in_check());
< #endif
< 
< 	// Restore information from the our backup StateInfo object
< 	StateInfo* backupSt = st->previous;
< 	st->key      = backupSt->key;
< #if !defined(NANOHA)
< 	st->epSquare = backupSt->epSquare;
< 	st->value    = backupSt->value;
< #endif
< 	st->previous = backupSt->previous;
< 	st->pliesFromNull = backupSt->pliesFromNull;
< 
< 	// Update the necessary information
< 	sideToMove = flip(sideToMove);
< #if !defined(NANOHA)
< 	st->rule50--;
< #endif
< 	assert(is_ok());
---
>   assert(is_ok());
>   assert(!in_check());
> 
>   // Restore information from the our backup StateInfo object
>   StateInfo* backupSt = st->previous;
>   st->key      = backupSt->key;
>   st->epSquare = backupSt->epSquare;
>   st->value    = backupSt->value;
>   st->previous = backupSt->previous;
>   st->pliesFromNull = backupSt->pliesFromNull;
> 
>   // Update the necessary information
>   sideToMove = opposite_color(sideToMove);
>   st->rule50--;
>   st->gamePly--;
1811,1816c1493
< #if defined(NANOHA)
< static int SEERec(int kind, int *attacker, int *defender)
< {
< 	//  手番の一番安い駒を動かす
< 	//  value = 取った駒の交換値(ふつうの2枚分)
< 	if (*attacker == 0) return 0;
---
> int Position::see(Move m) const {
1818,1819c1495,1496
< 	int value = NanohaTbl::KomaValueEx[kind];
< 	return Max(value - SEERec(*attacker, defender, attacker+1), 0);
---
>   assert(move_is_ok(m));
>   return see(move_from(m), move_to(m));
1821d1497
< #endif
1825c1501
< 	assert(is_ok(m));
---
>   assert(move_is_ok(m));
1827,1828c1503,1504
< 	Square from = move_from(m);
< 	Square to = move_to(m);
---
>   Square from = move_from(m);
>   Square to = move_to(m);
1830,1840c1506,1610
< 	// Early return if SEE cannot be negative because captured piece value
< 	// is not less then capturing one. Note that king moves always return
< 	// here because king midgame value is set to 0.
< #if defined(NANOHA)
< 	if (move_is_drop(m) == false && piece_value_midgame(piece_on(to)) >= piece_value_midgame(piece_on(from)))
< 		return 1;
< 
< 	return see(m);
< #else
< 	if (piece_value_midgame(piece_on(to)) >= piece_value_midgame(piece_on(from)))
< 		return 1;
---
>   // Early return if SEE cannot be negative because captured piece value
>   // is not less then capturing one. Note that king moves always return
>   // here because king midgame value is set to 0.
>   if (midgame_value_of_piece_on(to) >= midgame_value_of_piece_on(from))
>       return 1;
> 
>   return see(from, to);
> }
> 
> int Position::see(Square from, Square to) const {
> 
>   Bitboard occupied, attackers, stmAttackers, b;
>   int swapList[32], slIndex = 1;
>   PieceType capturedType, pt;
>   Color stm;
> 
>   assert(square_is_ok(from));
>   assert(square_is_ok(to));
> 
>   capturedType = type_of_piece_on(to);
> 
>   // King cannot be recaptured
>   if (capturedType == KING)
>       return seeValues[capturedType];
> 
>   occupied = occupied_squares();
> 
>   // Handle en passant moves
>   if (st->epSquare == to && type_of_piece_on(from) == PAWN)
>   {
>       Square capQq = (side_to_move() == WHITE ? to - DELTA_N : to - DELTA_S);
> 
>       assert(capturedType == PIECE_TYPE_NONE);
>       assert(type_of_piece_on(capQq) == PAWN);
> 
>       // Remove the captured pawn
>       clear_bit(&occupied, capQq);
>       capturedType = PAWN;
>   }
> 
>   // Find all attackers to the destination square, with the moving piece
>   // removed, but possibly an X-ray attacker added behind it.
>   clear_bit(&occupied, from);
>   attackers =  (rook_attacks_bb(to, occupied)  & pieces(ROOK, QUEEN))
>              | (bishop_attacks_bb(to, occupied)& pieces(BISHOP, QUEEN))
>              | (attacks_from<KNIGHT>(to)       & pieces(KNIGHT))
>              | (attacks_from<KING>(to)         & pieces(KING))
>              | (attacks_from<PAWN>(to, WHITE)  & pieces(PAWN, BLACK))
>              | (attacks_from<PAWN>(to, BLACK)  & pieces(PAWN, WHITE));
> 
>   // If the opponent has no attackers we are finished
>   stm = opposite_color(color_of_piece_on(from));
>   stmAttackers = attackers & pieces_of_color(stm);
>   if (!stmAttackers)
>       return seeValues[capturedType];
> 
>   // The destination square is defended, which makes things rather more
>   // difficult to compute. We proceed by building up a "swap list" containing
>   // the material gain or loss at each stop in a sequence of captures to the
>   // destination square, where the sides alternately capture, and always
>   // capture with the least valuable piece. After each capture, we look for
>   // new X-ray attacks from behind the capturing piece.
>   swapList[0] = seeValues[capturedType];
>   capturedType = type_of_piece_on(from);
> 
>   do {
>       // Locate the least valuable attacker for the side to move. The loop
>       // below looks like it is potentially infinite, but it isn't. We know
>       // that the side to move still has at least one attacker left.
>       for (pt = PAWN; !(stmAttackers & pieces(pt)); pt++)
>           assert(pt < KING);
> 
>       // Remove the attacker we just found from the 'occupied' bitboard,
>       // and scan for new X-ray attacks behind the attacker.
>       b = stmAttackers & pieces(pt);
>       occupied ^= (b & (~b + 1));
>       attackers |=  (rook_attacks_bb(to, occupied)   & pieces(ROOK, QUEEN))
>                   | (bishop_attacks_bb(to, occupied) & pieces(BISHOP, QUEEN));
> 
>       attackers &= occupied; // Cut out pieces we've already done
> 
>       // Add the new entry to the swap list
>       assert(slIndex < 32);
>       swapList[slIndex] = -swapList[slIndex - 1] + seeValues[capturedType];
>       slIndex++;
> 
>       // Remember the value of the capturing piece, and change the side to
>       // move before beginning the next iteration.
>       capturedType = pt;
>       stm = opposite_color(stm);
>       stmAttackers = attackers & pieces_of_color(stm);
> 
>       // Stop before processing a king capture
>       if (capturedType == KING && stmAttackers)
>       {
>           assert(slIndex < 32);
>           swapList[slIndex++] = QueenValueMidgame*10;
>           break;
>       }
>   } while (stmAttackers);
> 
>   // Having built the swap list, we negamax through it to find the best
>   // achievable score from the point of view of the side to move.
>   while (--slIndex)
>       swapList[slIndex-1] = Min(-swapList[slIndex], swapList[slIndex-1]);
1842,2038c1612
< 	return see(m);
< #endif
< }
< 
< int Position::see(Move m) const {
< 
< 	assert(is_ok(m));
< #if defined(NANOHA)
< 	//  value = 成りによる加点 + 取りによる加点;
< 	int from = move_from(m);
< 	int to = move_to(m);
< 	int fKind = move_ptype(m);
< 	int tKind = is_promotion(m) ? Piece(fKind | PROMOTED) : fKind;
< 	int cap = move_captured(m) & ~GOTE;
< 	Color us = side_to_move();
< 	int value = is_promotion(m) ? NanohaTbl::KomaValuePro[fKind] + NanohaTbl::KomaValueEx[cap] : NanohaTbl::KomaValueEx[cap]; // = (promote + capture) value
< 
< 	//
< 	const effect_t *dKiki = (us == BLACK) ? effectW : effectB;
< 	int defender[32];	// to に利いている守りの駒
< 	int ndef = 0;
< 	effect_t k = EXIST_EFFECT(dKiki[to]);
< 	while (k) {
< 		unsigned long id;
< 		_BitScanForward(&id, k);
< 		k &= k-1;
< 		if (id < 16) {
< 			int z = to - NanohaTbl::Direction[id];
< 			defender[ndef++] = ban[z] & ~GOTE;
< 			if (dKiki[z] & (0x100u << id)) {
< 				z = SkipOverEMP(to, -NanohaTbl::Direction[id]);
< 				defender[ndef++] = ban[z] & ~GOTE;
< 			}
< 		} else {
< 			int z = SkipOverEMP(to, -NanohaTbl::Direction[id]);
< 			defender[ndef++] = ban[z] & ~GOTE;
< 			if (dKiki[z] & (0x1u << id)) {
< 				z = SkipOverEMP(to, -NanohaTbl::Direction[id]);
< 				defender[ndef++] = ban[z] & ~GOTE;
< 			}
< 		}
< 	}
< 	defender[ndef] = 0;
< 	assert(ndef < 32-1);
< 
< 	if (ndef == 0) return value; // no defender -> stop SEE
< 
< 	const effect_t *aKiki = (us == BLACK) ? effectB : effectW;
< 	int attacker[32];	// to に利いている攻めの駒
< 	int natk = 0;
< 	k = EXIST_EFFECT(aKiki[to]);
< 	while (k) {
< 		unsigned long id;
< 		_BitScanForward(&id, k);
< 		k &= k-1;
< 		if (id < 16) {
< 			int z = to - NanohaTbl::Direction[id];
< 			if (from != z) attacker[natk++] = ban[z] & ~GOTE;
< 			if (dKiki[z] & (0x100u << id)) {
< 				z = SkipOverEMP(to, -NanohaTbl::Direction[id]);
< 				attacker[natk++] = ban[z] & ~GOTE;
< 			}
< 		} else {
< 			int z = SkipOverEMP(to, -NanohaTbl::Direction[id]);
< 			if (from != z) attacker[natk++] = ban[z] & ~GOTE;
< 			if (dKiki[z] & (0x1u << id)) {
< 				z = SkipOverEMP(to, -NanohaTbl::Direction[id]);
< 				attacker[natk++] = ban[z] & ~GOTE;
< 			}
< 		}
< 	}
< 	attacker[natk] = 0;
< 	assert(natk < 32-1);
< 
< 	int i, j;
< 	int *p;
< 	int n;
< 	p = defender;
< 	n = ndef;
< 	for (i = 0; i < n - 1; i++) {
< 		for (j = i + 1; j < n; j++) {
< 			if (NanohaTbl::KomaValueEx[p[i]] > NanohaTbl::KomaValueEx[p[j]]) {
< 				int tmp = p[i];
< 				p[i] = p[j];
< 				p[j] = tmp;
< 			}
< 		}
< 	}
< 	p = attacker;
< 	n = natk;
< 	for (i = 0; i < n - 1; i++) {
< 		for (j = i + 1; j < n; j++) {
< 			if (NanohaTbl::KomaValueEx[p[i]] > NanohaTbl::KomaValueEx[p[j]]) {
< 				int tmp = p[i];
< 				p[i] = p[j];
< 				p[j] = tmp;
< 			}
< 		}
< 	}
< 	return value - SEERec(tKind, defender, attacker); // counter
< #else
< 
< 	Square from, to;
< 	Bitboard occupied, attackers, stmAttackers, b;
< 	int swapList[32], slIndex = 1;
< 	PieceType capturedType, pt;
< 	Color stm;
< 
< 	assert(is_ok(m));
< 
< 	// As castle moves are implemented as capturing the rook, they have
< 	// SEE == RookValueMidgame most of the times (unless the rook is under
< 	// attack).
< 	if (is_castle(m))
< 		return 0;
< 
< 	from = move_from(m);
< 	to = move_to(m);
< 	capturedType = type_of(piece_on(to));
< 	occupied = occupied_squares();
< 
< 	// Handle en passant moves
< 	if (st->epSquare == to && type_of(piece_on(from)) == PAWN)
< 	{
< 		Square capQq = to - pawn_push(side_to_move());
< 
< 		assert(capturedType == PIECE_TYPE_NONE);
< 		assert(type_of(piece_on(capQq)) == PAWN);
< 
< 		// Remove the captured pawn
< 		clear_bit(&occupied, capQq);
< 		capturedType = PAWN;
< 	}
< 
< 	// Find all attackers to the destination square, with the moving piece
< 	// removed, but possibly an X-ray attacker added behind it.
< 	clear_bit(&occupied, from);
< 	attackers = attackers_to(to, occupied);
< 
< 	// If the opponent has no attackers we are finished
< 	stm = flip(color_of(piece_on(from)));
< 	stmAttackers = attackers & pieces(stm);
< 	if (!stmAttackers)
< 		return PieceValueMidgame[capturedType];
< 
< 	// The destination square is defended, which makes things rather more
< 	// difficult to compute. We proceed by building up a "swap list" containing
< 	// the material gain or loss at each stop in a sequence of captures to the
< 	// destination square, where the sides alternately capture, and always
< 	// capture with the least valuable piece. After each capture, we look for
< 	// new X-ray attacks from behind the capturing piece.
< 	swapList[0] = PieceValueMidgame[capturedType];
< 	capturedType = type_of(piece_on(from));
< 
< 	do {
< 		// Locate the least valuable attacker for the side to move. The loop
< 		// below looks like it is potentially infinite, but it isn't. We know
< 		// that the side to move still has at least one attacker left.
< 		for (pt = PAWN; !(stmAttackers & pieces(pt)); pt++)
< 			assert(pt < KING);
< 
< 		// Remove the attacker we just found from the 'occupied' bitboard,
< 		// and scan for new X-ray attacks behind the attacker.
< 		b = stmAttackers & pieces(pt);
< 		occupied ^= (b & (~b + 1));
< 		attackers |=  (rook_attacks_bb(to, occupied)   & pieces(ROOK, QUEEN))
< 		            | (bishop_attacks_bb(to, occupied) & pieces(BISHOP, QUEEN));
< 
< 		attackers &= occupied; // Cut out pieces we've already done
< 
< 		// Add the new entry to the swap list
< 		assert(slIndex < 32);
< 		swapList[slIndex] = -swapList[slIndex - 1] + PieceValueMidgame[capturedType];
< 		slIndex++;
< 
< 		// Remember the value of the capturing piece, and change the side to
< 		// move before beginning the next iteration.
< 		capturedType = pt;
< 		stm = flip(stm);
< 		stmAttackers = attackers & pieces(stm);
< 
< 		// Stop before processing a king capture
< 		if (capturedType == KING && stmAttackers)
< 		{
< 			assert(slIndex < 32);
< 			swapList[slIndex++] = QueenValueMidgame*10;
< 			break;
< 		}
< 	} while (stmAttackers);
< 
< 	// Having built the swap list, we negamax through it to find the best
< 	// achievable score from the point of view of the side to move.
< 	while (--slIndex)
< 		swapList[slIndex-1] = Min(-swapList[slIndex], swapList[slIndex-1]);
< 
< 	return swapList[0];
< #endif
---
>   return swapList[0];
2047,2092c1621,1645
< 	st = &startState;
< 	memset(st, 0, sizeof(StateInfo));
< #if !defined(NANOHA)
< 	st->epSquare = SQ_NONE;
< 
< 	memset(byColorBB,  0, sizeof(Bitboard) * 2);
< 	memset(byTypeBB,   0, sizeof(Bitboard) * 8);
< 	memset(pieceCount, 0, sizeof(int) * 2 * 8);
< 	memset(index,      0, sizeof(int) * 64);
< 
< 	for (int i = 0; i < 8; i++)
< 		for (int j = 0; j < 16; j++)
< 			pieceList[0][i][j] = pieceList[1][i][j] = SQ_NONE;
< 
< 	for (Square sq = SQ_A1; sq <= SQ_H8; sq++)
< 	{
< 		board[sq] = PIECE_NONE;
< 		castleRightsMask[sq] = ALL_CASTLES;
< 	}
< #endif
< 
< #if defined(NANOHA)
< 	// 将棋はBLACKが先番.
< 	sideToMove = BLACK;
< 	tnodes = 0;
< #if defined(CHK_PERFORM)
< 	count_Mate1plyDrop = 0;		// 駒打ちで詰んだ回数
< 	count_Mate1plyMove = 0;		// 駒移動で詰んだ回数
< 	count_Mate3ply = 0;			// Mate3()で詰んだ回数
< #endif // defined(CHK_PERFORM)
< #define FILL_ZERO(x)	memset(x, 0, sizeof(x))
< 	FILL_ZERO(banpadding);
< 	FILL_ZERO(ban);
< 	FILL_ZERO(komano);
< 	FILL_ZERO(effect);
< 	FILL_ZERO(pin);
< 	hand[0] = hand[1] = 0;
< 	FILL_ZERO(knkind);
< 	FILL_ZERO(knpos);
< 	material = 0;
< 	bInaniwa = false;
< #undef FILL_ZERO
< #else
< 	sideToMove = WHITE;
< #endif
< 	nodes = 0;
---
>   st = &startState;
>   memset(st, 0, sizeof(StateInfo));
>   st->epSquare = SQ_NONE;
>   startPosPlyCounter = 0;
>   nodes = 0;
> 
>   memset(byColorBB,  0, sizeof(Bitboard) * 2);
>   memset(byTypeBB,   0, sizeof(Bitboard) * 8);
>   memset(pieceCount, 0, sizeof(int) * 2 * 8);
>   memset(index,      0, sizeof(int) * 64);
> 
>   for (int i = 0; i < 64; i++)
>       board[i] = PIECE_NONE;
> 
>   for (int i = 0; i < 8; i++)
>       for (int j = 0; j < 16; j++)
>           pieceList[0][i][j] = pieceList[1][i][j] = SQ_NONE;
> 
>   for (Square sq = SQ_A1; sq <= SQ_H8; sq++)
>       castleRightsMask[sq] = ALL_CASTLES;
> 
>   sideToMove = WHITE;
>   initialKFile = FILE_E;
>   initialKRFile = FILE_H;
>   initialQRFile = FILE_A;
2099d1651
< #if !defined(NANOHA)
2102,2103c1654,1664
< 	Color c = color_of(p);
< 	PieceType pt = type_of(p);
---
>   Color c = color_of_piece(p);
>   PieceType pt = type_of_piece(p);
> 
>   board[s] = p;
>   index[s] = pieceCount[c][pt]++;
>   pieceList[c][pt][index[s]] = s;
> 
>   set_bit(&(byTypeBB[pt]), s);
>   set_bit(&(byColorBB[c]), s);
>   set_bit(&(byTypeBB[0]), s); // HACK: byTypeBB[0] contains all occupied squares.
> }
2105,2118d1665
< 	board[s] = p;
< 	index[s] = pieceCount[c][pt]++;
< 	pieceList[c][pt][index[s]] = s;
< 
< 	set_bit(&byTypeBB[pt], s);
< 	set_bit(&byColorBB[c], s);
< 	set_bit(&byTypeBB[0], s); // HACK: byTypeBB[0] contains all occupied squares.
< }
< #endif
< 
< /// Position::compute_key() は局面のハッシュキーの計算をする。
< /// ハッシュキーは通常は手を進めたり戻すことで差分計算される。
< /// compute_key()は新たに局面がセットされた時のみに使われる
< /// (あとデバッグモードでのハッシュキーの検証のため)
2127,2152c1674,1681
< #if defined(NANOHA)
< 	Key result = 0;
< 	int z;
< 	for(int dan = 1; dan <= 9; dan++) {
< 		for(int suji = 0x10; suji <= 0x90; suji += 0x10) {
< 			z = suji + dan;
< 			if (!square_is_empty(Square(z))) {
< 				result ^= zobrist[piece_on(Square(z))][z];
< 			}
< 		}
< 	}
< 	if (side_to_move() != BLACK)
< 		result ^= zobSideToMove;
< #else
< 	Key result = zobCastle[st->castleRights];
< 
< 	for (Square s = SQ_A1; s <= SQ_H8; s++)
< 		if (!square_is_empty(s))
< 			result ^= zobrist[color_of(piece_on(s))][type_of(piece_on(s))][s];
< 
< 	if (ep_square() != SQ_NONE)
< 		result ^= zobEp[ep_square()];
< 
< 	if (side_to_move() == BLACK)
< 		result ^= zobSideToMove;
< #endif
---
>   Key result = zobCastle[st->castleRights];
> 
>   for (Square s = SQ_A1; s <= SQ_H8; s++)
>       if (square_is_occupied(s))
>           result ^= zobrist[color_of_piece_on(s)][type_of_piece_on(s)][s];
> 
>   if (ep_square() != SQ_NONE)
>       result ^= zobEp[ep_square()];
2154c1683,1686
< 	return result;
---
>   if (side_to_move() == BLACK)
>       result ^= zobSideToMove;
> 
>   return result;
2164d1695
< #if !defined(NANOHA)
2167,2168c1698,1699
< 	Bitboard b;
< 	Key result = 0;
---
>   Bitboard b;
>   Key result = 0;
2170,2176c1701,1707
< 	for (Color c = WHITE; c <= BLACK; c++)
< 	{
< 		b = pieces(PAWN, c);
< 		while (b)
< 			result ^= zobrist[c][PAWN][pop_1st_bit(&b)];
< 	}
< 	return result;
---
>   for (Color c = WHITE; c <= BLACK; c++)
>   {
>       b = pieces(PAWN, c);
>       while (b)
>           result ^= zobrist[c][PAWN][pop_1st_bit(&b)];
>   }
>   return result;
2188,2193c1719,1720
< 	Key result = 0;
< 
< 	for (Color c = WHITE; c <= BLACK; c++)
< 		for (PieceType pt = PAWN; pt <= QUEEN; pt++)
< 			for (int i = 0, cnt = piece_count(c, pt); i < cnt; i++)
< 				result ^= zobrist[c][pt][i];
---
>   int count;
>   Key result = 0;
2195c1722,1729
< 	return result;
---
>   for (Color c = WHITE; c <= BLACK; c++)
>       for (PieceType pt = PAWN; pt <= QUEEN; pt++)
>       {
>           count = piece_count(c, pt);
>           for (int i = 0; i < count; i++)
>               result ^= zobrist[c][pt][i];
>       }
>   return result;
2197d1730
< #endif
2204d1736
< #if !defined(NANOHA)
2207,2208c1739,1740
< 	Bitboard b;
< 	Score result = SCORE_ZERO;
---
>   Bitboard b;
>   Score result = SCORE_ZERO;
2210,2216c1742,1748
< 	for (Color c = WHITE; c <= BLACK; c++)
< 		for (PieceType pt = PAWN; pt <= KING; pt++)
< 		{
< 			b = pieces(pt, c);
< 			while (b)
< 				result += pst(make_piece(c, pt), pop_1st_bit(&b));
< 		}
---
>   for (Color c = WHITE; c <= BLACK; c++)
>       for (PieceType pt = PAWN; pt <= KING; pt++)
>       {
>           b = pieces(pt, c);
>           while (b)
>               result += pst(c, pt, pop_1st_bit(&b));
>       }
2218,2219c1750,1751
< 	result += (side_to_move() == WHITE ? TempoValue / 2 : -TempoValue / 2);
< 	return result;
---
>   result += (side_to_move() == WHITE ? TempoValue / 2 : -TempoValue / 2);
>   return result;
2221c1753
< #endif
---
> 
2228d1759
< #if !defined(NANOHA)
2231c1762
< 	Value result = VALUE_ZERO;
---
>   Value result = VALUE_ZERO;
2233,2234c1764,1765
< 	for (PieceType pt = KNIGHT; pt <= QUEEN; pt++)
< 		result += piece_count(c, pt) * PieceValueMidgame[pt];
---
>   for (PieceType pt = KNIGHT; pt <= QUEEN; pt++)
>       result += piece_count(c, pt) * PieceValueMidgame[pt];
2236c1767
< 	return result;
---
>   return result;
2238c1769
< #endif
---
> 
2244,2275d1774
< #if defined(NANOHA)
< bool Position::is_draw(int& ret) const {
< 	ret=0;
< 	int i = 5, e = st->pliesFromNull;
< 
< 	if (i <= e)
< 	{
< 		StateInfo* stp = st->previous->previous;
< 		int rept = 0;
< 		bool cont_check = (st->previous->effect && stp->previous->effect) ? true : false;
< 
< 		do {
< 			stp = stp->previous->previous;
< 			if (stp->previous->effect == 0) cont_check = false;
< 
< 			if (stp->key == st->key && stp->hand == st->hand) {
< 				rept++;
< 				// 過去に3回(現局面含めて4回)出現していたら千日手.
< 				if (rept >= 3) {
< 					if (cont_check) {ret = -1; return false; }
< 					return true;
< 				}
< 			}
< 
< 			i +=2;
< 
< 		} while (i < e);
< 	}
< 	return false;
< }
< #else
< template<bool SkipRepetition>
2278,2281c1777,1792
< 	// Draw by material?
< 	if (   !pieces(PAWN)
< 	    && (non_pawn_material(WHITE) + non_pawn_material(BLACK) <= BishopValueMidgame))
< 		return true;
---
>   // Draw by material?
>   if (   !pieces(PAWN)
>       && (non_pawn_material(WHITE) + non_pawn_material(BLACK) <= BishopValueMidgame))
>       return true;
> 
>   // Draw by the 50 moves rule?
>   if (st->rule50 > 99 && !is_mate())
>       return true;
> 
>   // Draw by repetition?
>   for (int i = 4, e = Min(Min(st->gamePly, st->rule50), st->pliesFromNull); i <= e; i += 2)
>       if (history[st->gamePly - i] == st->key)
>           return true;
> 
>   return false;
> }
2283,2285d1793
< 	// Draw by the 50 moves rule?
< 	if (st->rule50 > 99 && !is_mate())
< 		return true;
2287,2290c1795,1802
< 	// Draw by repetition?
< 	if (!SkipRepetition)
< 	{
< 		int i = 4, e = Min(st->rule50, st->pliesFromNull);
---
> /// Position::is_mate() returns true or false depending on whether the
> /// side to move is checkmated.
> 
> bool Position::is_mate() const {
> 
>   MoveStack moves[MAX_MOVES];
>   return in_check() && generate<MV_LEGAL>(*this, moves) == moves;
> }
2292,2294d1803
< 		if (i <= e)
< 		{
< 			StateInfo* stp = st->previous->previous;
2296,2297c1805,1806
< 			do {
< 				stp = stp->previous->previous;
---
> /// Position::init_zobrist() is a static member function which initializes at
> /// startup the various arrays used to compute hash keys.
2299,2300c1808
< 				if (stp->key == st->key)
< 					return true;
---
> void Position::init_zobrist() {
2302c1810,1811
< 				i +=2;
---
>   int i,j, k;
>   RKISS rk;
2304,2306c1813,1814
< 			} while (i <= e);
< 		}
< 	}
---
>   for (i = 0; i < 2; i++) for (j = 0; j < 8; j++) for (k = 0; k < 64; k++)
>       zobrist[i][j][k] = rk.rand<Key>();
2308c1816,1823
< 	return false;
---
>   for (i = 0; i < 64; i++)
>       zobEp[i] = rk.rand<Key>();
> 
>   for (i = 0; i < 16; i++)
>       zobCastle[i] = rk.rand<Key>();
> 
>   zobSideToMove = rk.rand<Key>();
>   zobExclusion  = rk.rand<Key>();
2311,2314d1825
< // Explicit template instantiations
< template bool Position::is_draw<false>() const;
< template bool Position::is_draw<true>() const;
< #endif
2315a1827,1831
> /// Position::init_piece_square_tables() initializes the piece square tables.
> /// This is a two-step operation: First, the white halves of the tables are
> /// copied from the MgPST[][] and EgPST[][] arrays. Second, the black halves
> /// of the tables are initialized by mirroring and changing the sign of the
> /// corresponding white scores.
2317,2318c1833
< /// Position::is_mate() returns true or false depending on whether the
< /// side to move is checkmated.
---
> void Position::init_piece_square_tables() {
2320c1835,1837
< bool Position::is_mate() const {
---
>   for (Square s = SQ_A1; s <= SQ_H8; s++)
>       for (Piece p = WP; p <= WK; p++)
>           PieceSquareTable[p][s] = make_score(MgPST[p][s], EgPST[p][s]);
2322c1839,1841
< 	return in_check() && !MoveList<MV_LEGAL>(*this).size();
---
>   for (Square s = SQ_A1; s <= SQ_H8; s++)
>       for (Piece p = BP; p <= BK; p++)
>           PieceSquareTable[p][s] = -PieceSquareTable[p-8][flip_square(s)];
2326,2331c1845,1848
< /// Position::init() is a static member function which initializes at
< /// startup the various arrays used to compute hash keys and the piece
< /// square tables. The latter is a two-step operation: First, the white
< /// halves of the tables are copied from the MgPST[][] and EgPST[][] arrays.
< /// Second, the black halves of the tables are initialized by flipping
< /// and changing the sign of the corresponding white scores.
---
> /// Position::flip() flips position with the white and black sides reversed. This
> /// is only useful for debugging especially for finding evaluation symmetry bugs.
> 
> void Position::flip() {
2333c1850
< void Position::init() {
---
>   assert(is_ok());
2335c1852,1853
< 	RKISS rk;
---
>   // Make a copy of current position before to start changing
>   const Position pos(*this, threadID);
2337,2345c1855,1856
< #if defined(NANOHA)
< 	int j, k;
< 	for (j = 0; j < GRY+1; j++) for (k = 0; k < 0x100; k++)
< 		zobrist[j][k] = rk.rand<Key>() << 1;
< #else
< 	for (Color c = WHITE; c <= BLACK; c++)
< 		for (PieceType pt = PAWN; pt <= KING; pt++)
< 			for (Square s = SQ_A1; s <= SQ_H8; s++)
< 				zobrist[c][pt][s] = rk.rand<Key>();
---
>   clear();
>   threadID = pos.thread();
2347,2348c1858,1861
< 	for (Square s = SQ_A1; s <= SQ_H8; s++)
< 		zobEp[s] = rk.rand<Key>();
---
>   // Board
>   for (Square s = SQ_A1; s <= SQ_H8; s++)
>       if (!pos.square_is_empty(s))
>           put_piece(Piece(pos.piece_on(s) ^ 8), flip_square(s));
2350,2352c1863,1864
< 	for (int i = 0; i < 16; i++)
< 		zobCastle[i] = rk.rand<Key>();
< #endif
---
>   // Side to move
>   sideToMove = opposite_color(pos.side_to_move());
2354,2359c1866,1870
< #if defined(NANOHA)
< 	zobSideToMove = (rk.rand<Key>() << 1) | 1;
< 	zobExclusion  = (rk.rand<Key>() << 1);
< #else
< 	zobSideToMove = rk.rand<Key>();
< 	zobExclusion  = rk.rand<Key>();
---
>   // Castling rights
>   if (pos.can_castle_kingside(WHITE))  do_allow_oo(BLACK);
>   if (pos.can_castle_queenside(WHITE)) do_allow_ooo(BLACK);
>   if (pos.can_castle_kingside(BLACK))  do_allow_oo(WHITE);
>   if (pos.can_castle_queenside(BLACK)) do_allow_ooo(WHITE);
2361,2368c1872,1874
< 	for (Piece p = WP; p <= WK; p++)
< 		for (Square s = SQ_A1; s <= SQ_H8; s++)
< 		{
< 			pieceSquareTable[p][s] = make_score(MgPST[p][s], EgPST[p][s]);
< 			pieceSquareTable[p+8][flip(s)] = -pieceSquareTable[p][s];
< 		}
< #endif
< }
---
>   initialKFile  = pos.initialKFile;
>   initialKRFile = pos.initialKRFile;
>   initialQRFile = pos.initialQRFile;
2369a1876,1881
>   castleRightsMask[make_square(initialKFile,  RANK_1)] ^= (WHITE_OO | WHITE_OOO);
>   castleRightsMask[make_square(initialKFile,  RANK_8)] ^= (BLACK_OO | BLACK_OOO);
>   castleRightsMask[make_square(initialKRFile, RANK_1)] ^=  WHITE_OO;
>   castleRightsMask[make_square(initialKRFile, RANK_8)] ^=  BLACK_OO;
>   castleRightsMask[make_square(initialQRFile, RANK_1)] ^=  WHITE_OOO;
>   castleRightsMask[make_square(initialQRFile, RANK_8)] ^=  BLACK_OOO;
2371,2372c1883,1885
< /// Position::flip_me() flips position with the white and black sides reversed. This
< /// is only useful for debugging especially for finding evaluation symmetry bugs.
---
>   // En passant square
>   if (pos.st->epSquare != SQ_NONE)
>       st->epSquare = flip_square(pos.st->epSquare);
2374,2375c1887,1888
< #if !defined(NANOHA)
< void Position::flip_me() {
---
>   // Checkers
>   find_checkers();
2377,2378c1890,1893
< 	// Make a copy of current position before to start changing
< 	const Position pos(*this, threadID);
---
>   // Hash keys
>   st->key = compute_key();
>   st->pawnKey = compute_pawn_key();
>   st->materialKey = compute_material_key();
2380,2381c1895,1896
< 	clear();
< 	threadID = pos.thread();
---
>   // Incremental scores
>   st->value = compute_value();
2383,2418c1898,1900
< 	// Board
< 	for (Square s = SQ_A1; s <= SQ_H8; s++)
< 		if (!pos.square_is_empty(s))
< 			put_piece(Piece(pos.piece_on(s) ^ 8), flip(s));
< 
< 	// Side to move
< 	sideToMove = flip(pos.side_to_move());
< 
< 	// Castling rights
< 	if (pos.can_castle(WHITE_OO))
< 		set_castle(BLACK_OO,  king_square(BLACK), flip(pos.castle_rook_square(WHITE_OO)));
< 	if (pos.can_castle(WHITE_OOO))
< 		set_castle(BLACK_OOO, king_square(BLACK), flip(pos.castle_rook_square(WHITE_OOO)));
< 	if (pos.can_castle(BLACK_OO))
< 		set_castle(WHITE_OO,  king_square(WHITE), flip(pos.castle_rook_square(BLACK_OO)));
< 	if (pos.can_castle(BLACK_OOO))
< 		set_castle(WHITE_OOO, king_square(WHITE), flip(pos.castle_rook_square(BLACK_OOO)));
< 
< 	// En passant square
< 	if (pos.st->epSquare != SQ_NONE)
< 		st->epSquare = flip(pos.st->epSquare);
< 
< 	// Checkers
< 	st->checkersBB = attackers_to(king_square(sideToMove)) & pieces(flip(sideToMove));
< 
< 	// Hash keys
< 	st->key = compute_key();
< 	st->pawnKey = compute_pawn_key();
< 	st->materialKey = compute_material_key();
< 
< 	// Incremental scores
< 	st->value = compute_value();
< 
< 	// Material
< 	st->npMaterial[WHITE] = compute_non_pawn_material(WHITE);
< 	st->npMaterial[BLACK] = compute_non_pawn_material(BLACK);
---
>   // Material
>   st->npMaterial[WHITE] = compute_non_pawn_material(WHITE);
>   st->npMaterial[BLACK] = compute_non_pawn_material(BLACK);
2420c1902
< 	assert(is_ok());
---
>   assert(is_ok());
2422c1904
< #endif
---
> 
2429,2664c1911,2083
< #ifndef MINIMAL
< 	// What features of the position should be verified?
< 	const bool debugAll = false;
< #if defined(NANOHA)
< 	const bool debugKingCount       = debugAll || false;
< 	const bool debugKingCapture     = debugAll || false;
< #else
< 	const bool debugBitboards       = debugAll || false;
< 	const bool debugKingCount       = debugAll || false;
< 	const bool debugKingCapture     = debugAll || false;
< 	const bool debugCheckerCount    = debugAll || false;
< #endif
< 	const bool debugKey             = debugAll || false;
< #if defined(NANOHA)
< //  const bool debugIncrementalEval = debugAll || false;
< 	const bool debugPieceCounts     = debugAll || false;
< #else
< 	const bool debugMaterialKey     = debugAll || false;
< 	const bool debugPawnKey         = debugAll || false;
< 	const bool debugIncrementalEval = debugAll || false;
< 	const bool debugNonPawnMaterial = debugAll || false;
< 	const bool debugPieceCounts     = debugAll || false;
< 	const bool debugPieceList       = debugAll || false;
< 	const bool debugCastleSquares   = debugAll || false;
< #endif
< 
< 	if (failedStep) *failedStep = 1;
< 
< 	// Side to move OK?
< 	if (side_to_move() != WHITE && side_to_move() != BLACK)
< 		return false;
< 
< #if defined(NANOHA)
< 	// Are the king squares in the position correct?
< 	if (failedStep) (*failedStep)++;
< 	if (king_square(WHITE) != 0 && piece_on(king_square(WHITE)) != GOU) {
< 		std::cerr << "kposW=0x" << std::hex << int(king_square(WHITE)) << ", Piece=0x" << int(piece_on(king_square(WHITE))) << endl;
< 		print_csa();
< 		return false;
< 	}
< 
< 	if (failedStep) (*failedStep)++;
< 	if (king_square(BLACK) != 0 && piece_on(king_square(BLACK)) != SOU) {
< 		std::cerr << "kposB=0x" << std::hex << int(king_square(BLACK)) << ", Piece=0x" << int(piece_on(king_square(BLACK))) << endl;
< 		print_csa();
< 		return false;
< 	}
< #else
< 	// Are the king squares in the position correct?
< 	if (failedStep) (*failedStep)++;
< 	if (piece_on(king_square(WHITE)) != WK)
< 		return false;
< 
< 	if (failedStep) (*failedStep)++;
< 	if (piece_on(king_square(BLACK)) != BK)
< 		return false;
< 
< #endif
< 
< #if defined(NANOHA)
< 	// Do both sides have exactly one king?
< 	if (failedStep) (*failedStep)++;
< 	if (debugKingCount)
< 	{
< 		int kingCount[2] = {0, 0};
< 		for (Square s = SQ_A1; s <= SQ_I9; s++)
< 			if (type_of(piece_on(s)) == OU)
< 				kingCount[color_of(piece_on(s))]++;
< 
< 		if (kingCount[0] != 1 || kingCount[1] != 1)
< 			return false;
< 	}
< 
< 	// Can the side to move capture the opponent's king?
< 	if (failedStep) (*failedStep)++;
< 	if (debugKingCapture)
< 	{
< 		// TODO: 玉に相手駒の利きがあるか？
< //      Color us = side_to_move();
< //      Color them = flip(us);
< //      Square ksq = king_square(them);
< //      if (attackers_to(ksq) & pieces_of_color(us))
< //          return false;
< 	}
< 
< 	// Is there more than 2 checkers?
< 	if (failedStep) (*failedStep)++;
< 	// TODO:玉に3駒以上の利きがあったら不正な状態
< //  if (debugCheckerCount && count_1s<CNT32>(st->checkersBB) > 2)
< //      return false;
< #else
< 	// Do both sides have exactly one king?
< 	if (failedStep) (*failedStep)++;
< 	if (debugKingCount)
< 	{
< 		int kingCount[2] = {0, 0};
< 		for (Square s = SQ_A1; s <= SQ_H8; s++)
< 			if (type_of(piece_on(s)) == KING)
< 				kingCount[color_of(piece_on(s))]++;
< 
< 		if (kingCount[0] != 1 || kingCount[1] != 1)
< 			return false;
< 	}
< 
< 	// Can the side to move capture the opponent's king?
< 	if (failedStep) (*failedStep)++;
< 	if (debugKingCapture)
< 	{
< 		Color us = side_to_move();
< 		Color them = flip(us);
< 		Square ksq = king_square(them);
< 		if (attackers_to(ksq) & pieces(us))
< 			return false;
< 	}
< 
< 	// Is there more than 2 checkers?
< 	if (failedStep) (*failedStep)++;
< 	if (debugCheckerCount && count_1s<CNT32>(st->checkersBB) > 2)
< 		return false;
< 
< 	// Bitboards OK?
< 	if (failedStep) (*failedStep)++;
< 	if (debugBitboards)
< 	{
< 		// The intersection of the white and black pieces must be empty
< 		if ((pieces(WHITE) & pieces(BLACK)) != EmptyBoardBB)
< 			return false;
< 
< 		// The union of the white and black pieces must be equal to all
< 		// occupied squares
< 		if ((pieces(WHITE) | pieces(BLACK)) != occupied_squares())
< 			return false;
< 
< 		// Separate piece type bitboards must have empty intersections
< 		for (PieceType p1 = PAWN; p1 <= KING; p1++)
< 			for (PieceType p2 = PAWN; p2 <= KING; p2++)
< 				if (p1 != p2 && (pieces(p1) & pieces(p2)))
< 					return false;
< 	}
< 
< 	// En passant square OK?
< 	if (failedStep) (*failedStep)++;
< 	if (ep_square() != SQ_NONE)
< 	{
< 		// The en passant square must be on rank 6, from the point of view of the
< 		// side to move.
< 		if (relative_rank(side_to_move(), ep_square()) != RANK_6)
< 			return false;
< 	}
< #endif
< 
< 	// Hash key OK?
< 	if (failedStep) (*failedStep)++;
< 	if (debugKey && st->key != compute_key())
< 		return false;
< 
< #if !defined(NANOHA)
< 	// Pawn hash key OK?
< 	if (failedStep) (*failedStep)++;
< 	if (debugPawnKey && st->pawnKey != compute_pawn_key())
< 		return false;
< 
< 	// Material hash key OK?
< 	if (failedStep) (*failedStep)++;
< 	if (debugMaterialKey && st->materialKey != compute_material_key())
< 		return false;
< #endif
< 
< 	// Incremental eval OK?
< 	if (failedStep) (*failedStep)++;
< #if defined(NANOHA)
< 	// TODO:
< //  if (debugIncrementalEval && st->value != compute_value())
< //      return false;
< 
< 	// TODO:行き所のない駒(1段目の歩、香、桂、2段目の桂)
< 
< 	// Piece counts OK?
< 	if (failedStep) (*failedStep)++;
< 	if (debugPieceCounts) {
< 	}
< 	// TODO:盤面情報と駒番号の情報のチェック.
< #else
< 	if (debugIncrementalEval && st->value != compute_value())
< 		return false;
< 
< 	// Non-pawn material OK?
< 	if (failedStep) (*failedStep)++;
< 	if (debugNonPawnMaterial)
< 	{
< 		if (st->npMaterial[WHITE] != compute_non_pawn_material(WHITE))
< 			return false;
< 
< 		if (st->npMaterial[BLACK] != compute_non_pawn_material(BLACK))
< 			return false;
< 	}
< 
< 	// Piece counts OK?
< 	if (failedStep) (*failedStep)++;
< 	if (debugPieceCounts)
< 		for (Color c = WHITE; c <= BLACK; c++)
< 			for (PieceType pt = PAWN; pt <= KING; pt++)
< 				if (pieceCount[c][pt] != count_1s<CNT32>(pieces(pt, c)))
< 					return false;
< 
< 	if (failedStep) (*failedStep)++;
< 	if (debugPieceList)
< 		for (Color c = WHITE; c <= BLACK; c++)
< 			for (PieceType pt = PAWN; pt <= KING; pt++)
< 				for (int i = 0; i < pieceCount[c][pt]; i++)
< 				{
< 					if (piece_on(piece_list(c, pt)[i]) != make_piece(c, pt))
< 						return false;
< 
< 					if (index[piece_list(c, pt)[i]] != i)
< 						return false;
< 				}
< 
< 	if (failedStep) (*failedStep)++;
< 	if (debugCastleSquares)
< 		for (CastleRight f = WHITE_OO; f <= BLACK_OOO; f = CastleRight(f << 1))
< 		{
< 			if (!can_castle(f))
< 				continue;
< 
< 			Piece rook = (f & (WHITE_OO | WHITE_OOO) ? WR : BR);
< 
< 			if (   castleRightsMask[castleRookSquare[f]] != (ALL_CASTLES ^ f)
< 			    || piece_on(castleRookSquare[f]) != rook)
< 				return false;
< 		}
< #endif
< 
< 	if (failedStep) *failedStep = 0;
< #endif
< 	return true;
---
>   // What features of the position should be verified?
>   const bool debugAll = false;
> 
>   const bool debugBitboards       = debugAll || false;
>   const bool debugKingCount       = debugAll || false;
>   const bool debugKingCapture     = debugAll || false;
>   const bool debugCheckerCount    = debugAll || false;
>   const bool debugKey             = debugAll || false;
>   const bool debugMaterialKey     = debugAll || false;
>   const bool debugPawnKey         = debugAll || false;
>   const bool debugIncrementalEval = debugAll || false;
>   const bool debugNonPawnMaterial = debugAll || false;
>   const bool debugPieceCounts     = debugAll || false;
>   const bool debugPieceList       = debugAll || false;
>   const bool debugCastleSquares   = debugAll || false;
> 
>   if (failedStep) *failedStep = 1;
> 
>   // Side to move OK?
>   if (!color_is_ok(side_to_move()))
>       return false;
> 
>   // Are the king squares in the position correct?
>   if (failedStep) (*failedStep)++;
>   if (piece_on(king_square(WHITE)) != WK)
>       return false;
> 
>   if (failedStep) (*failedStep)++;
>   if (piece_on(king_square(BLACK)) != BK)
>       return false;
> 
>   // Castle files OK?
>   if (failedStep) (*failedStep)++;
>   if (!file_is_ok(initialKRFile))
>       return false;
> 
>   if (!file_is_ok(initialQRFile))
>       return false;
> 
>   // Do both sides have exactly one king?
>   if (failedStep) (*failedStep)++;
>   if (debugKingCount)
>   {
>       int kingCount[2] = {0, 0};
>       for (Square s = SQ_A1; s <= SQ_H8; s++)
>           if (type_of_piece_on(s) == KING)
>               kingCount[color_of_piece_on(s)]++;
> 
>       if (kingCount[0] != 1 || kingCount[1] != 1)
>           return false;
>   }
> 
>   // Can the side to move capture the opponent's king?
>   if (failedStep) (*failedStep)++;
>   if (debugKingCapture)
>   {
>       Color us = side_to_move();
>       Color them = opposite_color(us);
>       Square ksq = king_square(them);
>       if (attackers_to(ksq) & pieces_of_color(us))
>           return false;
>   }
> 
>   // Is there more than 2 checkers?
>   if (failedStep) (*failedStep)++;
>   if (debugCheckerCount && count_1s<CNT32>(st->checkersBB) > 2)
>       return false;
> 
>   // Bitboards OK?
>   if (failedStep) (*failedStep)++;
>   if (debugBitboards)
>   {
>       // The intersection of the white and black pieces must be empty
>       if ((pieces_of_color(WHITE) & pieces_of_color(BLACK)) != EmptyBoardBB)
>           return false;
> 
>       // The union of the white and black pieces must be equal to all
>       // occupied squares
>       if ((pieces_of_color(WHITE) | pieces_of_color(BLACK)) != occupied_squares())
>           return false;
> 
>       // Separate piece type bitboards must have empty intersections
>       for (PieceType p1 = PAWN; p1 <= KING; p1++)
>           for (PieceType p2 = PAWN; p2 <= KING; p2++)
>               if (p1 != p2 && (pieces(p1) & pieces(p2)))
>                   return false;
>   }
> 
>   // En passant square OK?
>   if (failedStep) (*failedStep)++;
>   if (ep_square() != SQ_NONE)
>   {
>       // The en passant square must be on rank 6, from the point of view of the
>       // side to move.
>       if (relative_rank(side_to_move(), ep_square()) != RANK_6)
>           return false;
>   }
> 
>   // Hash key OK?
>   if (failedStep) (*failedStep)++;
>   if (debugKey && st->key != compute_key())
>       return false;
> 
>   // Pawn hash key OK?
>   if (failedStep) (*failedStep)++;
>   if (debugPawnKey && st->pawnKey != compute_pawn_key())
>       return false;
> 
>   // Material hash key OK?
>   if (failedStep) (*failedStep)++;
>   if (debugMaterialKey && st->materialKey != compute_material_key())
>       return false;
> 
>   // Incremental eval OK?
>   if (failedStep) (*failedStep)++;
>   if (debugIncrementalEval && st->value != compute_value())
>       return false;
> 
>   // Non-pawn material OK?
>   if (failedStep) (*failedStep)++;
>   if (debugNonPawnMaterial)
>   {
>       if (st->npMaterial[WHITE] != compute_non_pawn_material(WHITE))
>           return false;
> 
>       if (st->npMaterial[BLACK] != compute_non_pawn_material(BLACK))
>           return false;
>   }
> 
>   // Piece counts OK?
>   if (failedStep) (*failedStep)++;
>   if (debugPieceCounts)
>       for (Color c = WHITE; c <= BLACK; c++)
>           for (PieceType pt = PAWN; pt <= KING; pt++)
>               if (pieceCount[c][pt] != count_1s<CNT32>(pieces(pt, c)))
>                   return false;
> 
>   if (failedStep) (*failedStep)++;
>   if (debugPieceList)
>       for (Color c = WHITE; c <= BLACK; c++)
>           for (PieceType pt = PAWN; pt <= KING; pt++)
>               for (int i = 0; i < pieceCount[c][pt]; i++)
>               {
>                   if (piece_on(piece_list(c, pt, i)) != make_piece(c, pt))
>                       return false;
> 
>                   if (index[piece_list(c, pt, i)] != i)
>                       return false;
>               }
> 
>   if (failedStep) (*failedStep)++;
>   if (debugCastleSquares)
>   {
>       for (Color c = WHITE; c <= BLACK; c++)
>       {
>           if (can_castle_kingside(c) && piece_on(initial_kr_square(c)) != make_piece(c, ROOK))
>               return false;
> 
>           if (can_castle_queenside(c) && piece_on(initial_qr_square(c)) != make_piece(c, ROOK))
>               return false;
>       }
>       if (castleRightsMask[initial_kr_square(WHITE)] != (ALL_CASTLES ^ WHITE_OO))
>           return false;
>       if (castleRightsMask[initial_qr_square(WHITE)] != (ALL_CASTLES ^ WHITE_OOO))
>           return false;
>       if (castleRightsMask[initial_kr_square(BLACK)] != (ALL_CASTLES ^ BLACK_OO))
>           return false;
>       if (castleRightsMask[initial_qr_square(BLACK)] != (ALL_CASTLES ^ BLACK_OOO))
>           return false;
>   }
> 
>   if (failedStep) *failedStep = 0;
>   return true;
########################## problem.cpp
########################## search.cpp
2c2
<   NanohaMini, a USI shogi(japanese-chess) playing engine derived from Stockfish 2.1
---
>   Stockfish, a UCI chess playing engine derived from Glaurung 2.1
4,5c4
<   Copyright (C) 2008-2010 Marco Costalba, Joona Kiiski, Tord Romstad (Stockfish author)
<   Copyright (C) 2014 Kazuyuki Kawabata
---
>   Copyright (C) 2008-2010 Marco Costalba, Joona Kiiski, Tord Romstad
7c6
<   NanohaMini is free software: you can redistribute it and/or modify
---
>   Stockfish is free software: you can redistribute it and/or modify
12c11
<   NanohaMini is distributed in the hope that it will be useful,
---
>   Stockfish is distributed in the hope that it will be useful,
25d23
< #include <iomanip>
43,48d40
< #if defined(NANOHA)
< # define NANOHA_CHECKMATE3
< # define NANOHA_CHECKMATE3_QUIESCE
< # define NANOHA_DFPN
< #endif
< 
51d42
< using std::string;
55,56c46,180
< 	// Set to true to force running with one thread. Used for debugging
< 	const bool FakeSplit = false;
---
>   // Set to true to force running with one thread. Used for debugging
>   const bool FakeSplit = false;
> 
>   // Different node types, used as template parameter
>   enum NodeType { NonPV, PV };
> 
>   // RootMove struct is used for moves at the root of the tree. For each root
>   // move, we store two scores, a node count, and a PV (really a refutation
>   // in the case of moves which fail low). Value pv_score is normally set at
>   // -VALUE_INFINITE for all non-pv moves, while non_pv_score is computed
>   // according to the order in which moves are returned by MovePicker.
>   struct RootMove {
> 
>     RootMove();
>     RootMove(const RootMove& rm) { *this = rm; }
>     RootMove& operator=(const RootMove& rm);
> 
>     // RootMove::operator<() is the comparison function used when
>     // sorting the moves. A move m1 is considered to be better
>     // than a move m2 if it has an higher pv_score, or if it has
>     // equal pv_score but m1 has the higher non_pv_score. In this way
>     // we are guaranteed that PV moves are always sorted as first.
>     bool operator<(const RootMove& m) const {
>       return pv_score != m.pv_score ? pv_score < m.pv_score
>                                     : non_pv_score < m.non_pv_score;
>     }
> 
>     void extract_pv_from_tt(Position& pos);
>     void insert_pv_in_tt(Position& pos);
>     std::string pv_info_to_uci(Position& pos, int depth, int selDepth,
>                                Value alpha, Value beta, int pvIdx);
>     int64_t nodes;
>     Value pv_score;
>     Value non_pv_score;
>     Move pv[PLY_MAX_PLUS_2];
>   };
> 
>   // RootMoveList struct is just a vector of RootMove objects,
>   // with an handful of methods above the standard ones.
>   struct RootMoveList : public std::vector<RootMove> {
> 
>     typedef std::vector<RootMove> Base;
> 
>     void init(Position& pos, Move searchMoves[]);
>     void sort() { insertion_sort<RootMove, Base::iterator>(begin(), end()); }
>     void sort_multipv(int n) { insertion_sort<RootMove, Base::iterator>(begin(), begin() + n); }
> 
>     int bestMoveChanges;
>   };
> 
>   // MovePickerExt template class extends MovePicker and allows to choose at compile
>   // time the proper moves source according to the type of node. In the default case
>   // we simply create and use a standard MovePicker object.
>   template<bool SpNode, bool Root> struct MovePickerExt : public MovePicker {
> 
>     MovePickerExt(const Position& p, Move ttm, Depth d, const History& h, SearchStack* ss, Value b)
>                   : MovePicker(p, ttm, d, h, ss, b) {}
> 
>     RootMoveList::iterator rm; // Dummy, needed to compile
>   };
> 
>   // In case of a SpNode we use split point's shared MovePicker object as moves source
>   template<> struct MovePickerExt<true, false> : public MovePicker {
> 
>     MovePickerExt(const Position& p, Move ttm, Depth d, const History& h, SearchStack* ss, Value b)
>                   : MovePicker(p, ttm, d, h, ss, b), mp(ss->sp->mp) {}
> 
>     Move get_next_move() { return mp->get_next_move(); }
> 
>     RootMoveList::iterator rm; // Dummy, needed to compile
>     MovePicker* mp;
>   };
> 
>   // In case of a Root node we use RootMoveList as moves source
>   template<> struct MovePickerExt<false, true> : public MovePicker {
> 
>     MovePickerExt(const Position&, Move, Depth, const History&, SearchStack*, Value);
>     Move get_next_move();
> 
>     RootMoveList::iterator rm;
>     bool firstCall;
>   };
> 
> 
>   /// Constants
> 
>   // Lookup table to check if a Piece is a slider and its access function
>   const bool Slidings[18] = { 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1 };
>   inline bool piece_is_slider(Piece p) { return Slidings[p]; }
> 
>   // Step 6. Razoring
> 
>   // Maximum depth for razoring
>   const Depth RazorDepth = 4 * ONE_PLY;
> 
>   // Dynamic razoring margin based on depth
>   inline Value razor_margin(Depth d) { return Value(0x200 + 0x10 * int(d)); }
> 
>   // Maximum depth for use of dynamic threat detection when null move fails low
>   const Depth ThreatDepth = 5 * ONE_PLY;
> 
>   // Step 9. Internal iterative deepening
> 
>   // Minimum depth for use of internal iterative deepening
>   const Depth IIDDepth[] = { 8 * ONE_PLY, 5 * ONE_PLY };
> 
>   // At Non-PV nodes we do an internal iterative deepening search
>   // when the static evaluation is bigger then beta - IIDMargin.
>   const Value IIDMargin = Value(0x100);
> 
>   // Step 11. Decide the new search depth
> 
>   // Extensions. Array index 0 is used for non-PV nodes, index 1 for PV nodes
>   const Depth CheckExtension[]         = { ONE_PLY / 2, ONE_PLY / 1 };
>   const Depth PawnEndgameExtension[]   = { ONE_PLY / 1, ONE_PLY / 1 };
>   const Depth PawnPushTo7thExtension[] = { ONE_PLY / 2, ONE_PLY / 2 };
>   const Depth PassedPawnExtension[]    = {  DEPTH_ZERO, ONE_PLY / 2 };
> 
>   // Minimum depth for use of singular extension
>   const Depth SingularExtensionDepth[] = { 8 * ONE_PLY, 6 * ONE_PLY };
> 
>   // Step 12. Futility pruning
> 
>   // Futility margin for quiescence search
>   const Value FutilityMarginQS = Value(0x80);
> 
>   // Futility lookup tables (initialized at startup) and their access functions
>   Value FutilityMargins[16][64]; // [depth][moveNumber]
>   int FutilityMoveCounts[32];    // [depth]
> 
>   inline Value futility_margin(Depth d, int mn) {
> 
>     return d < 7 * ONE_PLY ? FutilityMargins[Max(d, 1)][Min(mn, 63)]
>                            : 2 * VALUE_INFINITE;
>   }
58,59c182
< 	// Different node types, used as template parameter
< 	enum NodeType { Root, PV, NonPV, SplitPointRoot, SplitPointPV, SplitPointNonPV };
---
>   inline int futility_move_count(Depth d) {
61,330c184,185
< 	// RootMove struct is used for moves at the root of the tree. For each root
< 	// move, we store a score, a node count, and a PV (really a refutation
< 	// in the case of moves which fail low). Score is normally set at
< 	// -VALUE_INFINITE for all non-pv moves.
< 	struct RootMove {
< 
< 		// RootMove::operator<() is the comparison function used when
< 		// sorting the moves. A move m1 is considered to be better
< 		// than a move m2 if it has an higher score
< 		bool operator<(const RootMove& m) const { return score < m.score; }
< 
< #if defined(NANOHA)
< 		void extract_pv_from_tt_rec(Position& pos,int ply);
< #endif
< 		void extract_pv_from_tt(Position& pos);
< #if defined(NANOHA)
< 		void insert_pv_in_tt_rec(Position& pos,int ply);
< #endif
< 		void insert_pv_in_tt(Position& pos);
< 
< 		int64_t nodes;
< 		Value score;
< 		Value prevScore;
< 		std::vector<Move> pv;
< 	};
< 
< 	// RootMoveList struct is mainly a std::vector of RootMove objects
< 	struct RootMoveList : public std::vector<RootMove> {
< 
< 		void init(Position& pos, Move searchMoves[]);
< 		RootMove* find(const Move& m, int startIndex = 0);
< 
< 		int bestMoveChanges;
< 	};
< 
< 
< 	/// Constants
< 
< #if !defined(NANOHA)
< 	// Lookup table to check if a Piece is a slider and its access function
< 	const bool Slidings[18] = { 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1 };
< 	inline bool piece_is_slider(Piece p) { return Slidings[p]; }
< #endif
< 
< 	// Step 6. Razoring
< 
< 	// Maximum depth for razoring
< 	const Depth RazorDepth = 4 * ONE_PLY;
< 
< 	// Dynamic razoring margin based on depth
< 	inline Value razor_margin(Depth d) { return Value(0x200 + 0x10 * int(d)); }
< 
< 	// Maximum depth for use of dynamic threat detection when null move fails low
< 	const Depth ThreatDepth = 5 * ONE_PLY;
< 
< 	// Step 9. Internal iterative deepening
< 
< 	// Minimum depth for use of internal iterative deepening
< 	const Depth IIDDepth[] = { 8 * ONE_PLY, 5 * ONE_PLY };
< 
< 	// At Non-PV nodes we do an internal iterative deepening search
< 	// when the static evaluation is bigger then beta - IIDMargin.
< 	const Value IIDMargin = Value(0x100);
< 
< 	// Step 11. Decide the new search depth
< 
< 	// Extensions. Array index 0 is used for non-PV nodes, index 1 for PV nodes
< 	const Depth CheckExtension[]         = { ONE_PLY / 2, ONE_PLY / 1 };
< #if !defined(NANOHA)
< 	const Depth PawnEndgameExtension[]   = { ONE_PLY / 1, ONE_PLY / 1 };
< 	const Depth PawnPushTo7thExtension[] = { ONE_PLY / 2, ONE_PLY / 2 };
< 	const Depth PassedPawnExtension[]    = {  DEPTH_ZERO, ONE_PLY / 2 };
< #endif
< 
< 	// Minimum depth for use of singular extension
< 	const Depth SingularExtensionDepth[] = { 8 * ONE_PLY, 6 * ONE_PLY };
< 
< 	// Step 12. Futility pruning
< 
< 	// Futility margin for quiescence search
< 	const Value FutilityMarginQS = Value(0x80);
< 
< 	// Futility lookup tables (initialized at startup) and their access functions
< 	Value FutilityMargins[16][64]; // [depth][moveNumber]
< 	int FutilityMoveCounts[32];    // [depth]
< 
< 	inline Value futility_margin(Depth d, int mn) {
< 
< 		return d < 7 * ONE_PLY ? FutilityMargins[Max(d, 1)][Min(mn, 63)]
< 		                       : 2 * VALUE_INFINITE;
< 	}
< 
< 	inline int futility_move_count(Depth d) {
< 
< 		return d < 16 * ONE_PLY ? FutilityMoveCounts[d] : MAX_MOVES;
< 	}
< 
< 	// Step 14. Reduced search
< 
< 	// Reduction lookup tables (initialized at startup) and their access function
< 	int8_t Reductions[2][64][64]; // [pv][depth][moveNumber]
< 
< 	template <bool PvNode> inline Depth reduction(Depth d, int mn) {
< 
< 		return (Depth) Reductions[PvNode][Min(d / ONE_PLY, 63)][Min(mn, 63)];
< 	}
< 
< 	// Easy move margin. An easy move candidate must be at least this much
< 	// better than the second best move.
< 	const Value EasyMoveMargin = Value(0x200);
< 
< 
< 	/// Namespace variables
< 
< 	// Root move list
< 	RootMoveList Rml;
< 
< 	// MultiPV mode
< 	int MultiPV, UCIMultiPV, MultiPVIteration;
< 
< #if defined(NANOHA)
< 	Value DrawValue;
< #endif
< 	// Time management variables
< 	bool StopOnPonderhit, FirstRootMove, StopRequest, QuitRequest, AspirationFailLow;
< 	TimeManager TimeMgr;
< 	SearchLimits Limits;
< 
< 	// Log file
< 	std::ofstream LogFile;
< 
< 	// Skill level adjustment
< 	int SkillLevel;
< 	bool SkillLevelEnabled;
< 
< 	// Node counters, used only by thread[0] but try to keep in different cache
< 	// lines (64 bytes each) from the heavy multi-thread read accessed variables.
< 	int NodesSincePoll;
< 	int NodesBetweenPolls = 30000;
< 
< 	// History table
< 	History H;
< 
< 
< 	/// Local functions
< 
< 	Move id_loop(Position& pos, Move searchMoves[], Move* ponderMove);
< 
< 	template <NodeType NT>
< 	Value search(Position& pos, SearchStack* ss, Value alpha, Value beta, Depth depth);
< 
< 	template <NodeType NT>
< 	Value qsearch(Position& pos, SearchStack* ss, Value alpha, Value beta, Depth depth);
< 
< 	bool check_is_dangerous(Position &pos, Move move, Value futilityBase, Value beta, Value *bValue);
< 	bool connected_moves(const Position& pos, Move m1, Move m2);
< 	Value value_to_tt(Value v, int ply);
< 	Value value_from_tt(Value v, int ply);
< 	bool can_return_tt(const TTEntry* tte, Depth depth, Value beta, int ply);
< 	bool connected_threat(const Position& pos, Move m, Move threat);
< 	Value refine_eval(const TTEntry* tte, Value defaultEval, int ply);
< 	void update_history(const Position& pos, Move move, Depth depth, Move movesSearched[], int moveCount);
< 	void update_gains(const Position& pos, Move move, Value before, Value after);
< 	void do_skill_level(Move* best, Move* ponder);
< 
< 	int current_search_time(int set = 0);
< 	string score_to_uci(Value v, Value alpha = -VALUE_INFINITE, Value beta = VALUE_INFINITE);
< 	string speed_to_uci(int64_t nodes);
< 	string pv_to_uci(const Move pv[], int pvNum, bool chess960);
< 	string pretty_pv(Position& pos, int depth, Value score, int time, Move pv[]);
< 	string depth_to_uci(Depth depth);
< 	void poll(const Position& pos);
< 	void wait_for_stop_or_ponderhit();
< 
< 	// MovePickerExt template class extends MovePicker and allows to choose at compile
< 	// time the proper moves source according to the type of node. In the default case
< 	// we simply create and use a standard MovePicker object.
< 	template<bool SpNode> struct MovePickerExt : public MovePicker {
< 
< 		MovePickerExt(const Position& p, Move ttm, Depth d, const History& h, SearchStack* ss, Value b)
< 		              : MovePicker(p, ttm, d, h, ss, b) {}
< 	};
< 
< 	// In case of a SpNode we use split point's shared MovePicker object as moves source
< 	template<> struct MovePickerExt<true> : public MovePicker {
< 
< 		MovePickerExt(const Position& p, Move ttm, Depth d, const History& h, SearchStack* ss, Value b)
< 		  : MovePicker(p, ttm, d, h, ss, b), mp(ss->sp->mp) {}
< 
< 		Move get_next_move() { return mp->get_next_move(); }
< 		MovePicker* mp;
< 	};
< 
< 	// Overload operator<<() to make it easier to print moves in a coordinate
< 	// notation compatible with UCI protocol.
< 	std::ostream& operator<<(std::ostream& os, Move m) {
< 
< #if !defined(NANOHA)
< 		bool chess960 = (os.iword(0) != 0); // See set960()
< 		return os << move_to_uci(m, chess960);
< #else
< 		return os << move_to_uci(m);
< #endif
< 	}
< 
< 	// When formatting a move for std::cout we must know if we are in Chess960
< 	// or not. To keep using the handy operator<<() on the move the trick is to
< 	// embed this flag in the stream itself. Function-like named enum set960 is
< 	// used as a custom manipulator and the stream internal general-purpose array,
< 	// accessed through ios_base::iword(), is used to pass the flag to the move's
< 	// operator<<() that will read it to properly format castling moves.
< #if !defined(NANOHA)
< 	enum set960 {};
< 
< 	std::ostream& operator<< (std::ostream& os, const set960& f) {
< 
< 		os.iword(0) = int(f);
< 		return os;
< 	}
< #endif
< #if defined(NANOHA)
< 	Value value_draw(Position const& pos){
< 		if(pos.side_to_move() == BLACK) return DrawValue;
< 		else return -DrawValue;
< 	}
< #endif
< 
< 	// extension() decides whether a move should be searched with normal depth,
< 	// or with extended depth. Certain classes of moves (checking moves, in
< 	// particular) are searched with bigger depth than ordinary moves and in
< 	// any case are marked as 'dangerous'. Note that also if a move is not
< 	// extended, as example because the corresponding UCI option is set to zero,
< 	// the move is marked as 'dangerous' so, at least, we avoid to prune it.
< 	template <bool PvNode>
< 	FORCE_INLINE Depth extension(const Position& pos, Move m, bool captureOrPromotion,
< 	                             bool moveIsCheck, bool* dangerous) {
< 		assert(m != MOVE_NONE);
< 
< 		Depth result = DEPTH_ZERO;
< 		*dangerous = moveIsCheck;
< 
< 		if (moveIsCheck && pos.see_sign(m) >= 0)
< 			result += CheckExtension[PvNode];
< 
< #if !defined(NANOHA)
< 		if (type_of(pos.piece_on(move_from(m))) == PAWN)
< 		{
< 			Color c = pos.side_to_move();
< 			if (relative_rank(c, move_to(m)) == RANK_7)
< 			{
< 				result += PawnPushTo7thExtension[PvNode];
< 				*dangerous = true;
< 			}
< 			if (pos.pawn_is_passed(c, move_to(m)))
< 			{
< 				result += PassedPawnExtension[PvNode];
< 				*dangerous = true;
< 			}
< 		}
< 
< 		if (   captureOrPromotion
< 		    && type_of(pos.piece_on(move_to(m))) != PAWN
< 		    && (  pos.non_pawn_material(WHITE) + pos.non_pawn_material(BLACK)
< 		        - piece_value_midgame(pos.piece_on(move_to(m))) == VALUE_ZERO)
< 		    && !is_special(m))
< 		{
< 			result += PawnEndgameExtension[PvNode];
< 			*dangerous = true;
< 		}
< #endif
---
>     return d < 16 * ONE_PLY ? FutilityMoveCounts[d] : MAX_MOVES;
>   }
332,333c187,289
< 		return Min(result, ONE_PLY);
< 	}
---
>   // Step 14. Reduced search
> 
>   // Reduction lookup tables (initialized at startup) and their access function
>   int8_t Reductions[2][64][64]; // [pv][depth][moveNumber]
> 
>   template <NodeType PV> inline Depth reduction(Depth d, int mn) {
> 
>     return (Depth) Reductions[PV][Min(d / ONE_PLY, 63)][Min(mn, 63)];
>   }
> 
>   // Easy move margin. An easy move candidate must be at least this much
>   // better than the second best move.
>   const Value EasyMoveMargin = Value(0x200);
> 
> 
>   /// Namespace variables
> 
>   // Root move list
>   RootMoveList Rml;
> 
>   // MultiPV mode
>   int MultiPV, UCIMultiPV;
> 
>   // Time management variables
>   bool StopOnPonderhit, FirstRootMove, StopRequest, QuitRequest, AspirationFailLow;
>   TimeManager TimeMgr;
>   SearchLimits Limits;
> 
>   // Log file
>   std::ofstream LogFile;
> 
>   // Skill level adjustment
>   int SkillLevel;
>   bool SkillLevelEnabled;
> 
>   // Node counters, used only by thread[0] but try to keep in different cache
>   // lines (64 bytes each) from the heavy multi-thread read accessed variables.
>   bool SendSearchedNodes;
>   int NodesSincePoll;
>   int NodesBetweenPolls = 30000;
> 
>   // History table
>   History H;
> 
> 
>   /// Local functions
> 
>   Move id_loop(Position& pos, Move searchMoves[], Move* ponderMove);
> 
>   template <NodeType PvNode, bool SpNode, bool Root>
>   Value search(Position& pos, SearchStack* ss, Value alpha, Value beta, Depth depth);
> 
>   template <NodeType PvNode>
>   Value qsearch(Position& pos, SearchStack* ss, Value alpha, Value beta, Depth depth);
> 
>   template <NodeType PvNode>
>   inline Value search(Position& pos, SearchStack* ss, Value alpha, Value beta, Depth depth) {
> 
>     return depth < ONE_PLY ? qsearch<PvNode>(pos, ss, alpha, beta, DEPTH_ZERO)
>                            : search<PvNode, false, false>(pos, ss, alpha, beta, depth);
>   }
> 
>   template <NodeType PvNode>
>   Depth extension(const Position& pos, Move m, bool captureOrPromotion, bool moveIsCheck, bool* dangerous);
> 
>   bool check_is_dangerous(Position &pos, Move move, Value futilityBase, Value beta, Value *bValue);
>   bool connected_moves(const Position& pos, Move m1, Move m2);
>   Value value_to_tt(Value v, int ply);
>   Value value_from_tt(Value v, int ply);
>   bool ok_to_use_TT(const TTEntry* tte, Depth depth, Value beta, int ply);
>   bool connected_threat(const Position& pos, Move m, Move threat);
>   Value refine_eval(const TTEntry* tte, Value defaultEval, int ply);
>   void update_history(const Position& pos, Move move, Depth depth, Move movesSearched[], int moveCount);
>   void update_gains(const Position& pos, Move move, Value before, Value after);
>   void do_skill_level(Move* best, Move* ponder);
> 
>   int current_search_time(int set = 0);
>   std::string value_to_uci(Value v);
>   std::string speed_to_uci(int64_t nodes);
>   void poll(const Position& pos);
>   void wait_for_stop_or_ponderhit();
> 
>   // Overload operator<<() to make it easier to print moves in a coordinate
>   // notation compatible with UCI protocol.
>   std::ostream& operator<<(std::ostream& os, Move m) {
> 
>     bool chess960 = (os.iword(0) != 0); // See set960()
>     return os << move_to_uci(m, chess960);
>   }
> 
>   // When formatting a move for std::cout we must know if we are in Chess960
>   // or not. To keep using the handy operator<<() on the move the trick is to
>   // embed this flag in the stream itself. Function-like named enum set960 is
>   // used as a custom manipulator and the stream internal general-purpose array,
>   // accessed through ios_base::iword(), is used to pass the flag to the move's
>   // operator<<() that will read it to properly format castling moves.
>   enum set960 {};
> 
>   std::ostream& operator<< (std::ostream& os, const set960& f) {
> 
>     os.iword(0) = int(f);
>     return os;
>   }
342,361c298,317
< 	int d;  // depth (ONE_PLY == 2)
< 	int hd; // half depth (ONE_PLY == 1)
< 	int mc; // moveCount
< 
< 	// Init reductions array
< 	for (hd = 1; hd < 64; hd++) for (mc = 1; mc < 64; mc++)
< 	{
< 		double    pvRed = log(double(hd)) * log(double(mc)) / 3.0;
< 		double nonPVRed = 0.33 + log(double(hd)) * log(double(mc)) / 2.25;
< 		Reductions[1][hd][mc] = (int8_t) (   pvRed >= 1.0 ? floor(   pvRed * int(ONE_PLY)) : 0);
< 		Reductions[0][hd][mc] = (int8_t) (nonPVRed >= 1.0 ? floor(nonPVRed * int(ONE_PLY)) : 0);
< 	}
< 
< 	// Init futility margins array
< 	for (d = 1; d < 16; d++) for (mc = 0; mc < 64; mc++)
< 		FutilityMargins[d][mc] = Value(112 * int(log(double(d * d) / 2) / log(2.0) + 1.001) - 8 * mc + 45);
< 
< 	// Init futility move count array
< 	for (d = 0; d < 32; d++)
< 		FutilityMoveCounts[d] = int(3.001 + 0.25 * pow(d, 2.0));
---
>   int d;  // depth (ONE_PLY == 2)
>   int hd; // half depth (ONE_PLY == 1)
>   int mc; // moveCount
> 
>   // Init reductions array
>   for (hd = 1; hd < 64; hd++) for (mc = 1; mc < 64; mc++)
>   {
>       double    pvRed = log(double(hd)) * log(double(mc)) / 3.0;
>       double nonPVRed = 0.33 + log(double(hd)) * log(double(mc)) / 2.25;
>       Reductions[PV][hd][mc]    = (int8_t) (   pvRed >= 1.0 ? floor(   pvRed * int(ONE_PLY)) : 0);
>       Reductions[NonPV][hd][mc] = (int8_t) (nonPVRed >= 1.0 ? floor(nonPVRed * int(ONE_PLY)) : 0);
>   }
> 
>   // Init futility margins array
>   for (d = 1; d < 16; d++) for (mc = 0; mc < 64; mc++)
>       FutilityMargins[d][mc] = Value(112 * int(log(double(d * d) / 2) / log(2.0) + 1.001) - 8 * mc + 45);
> 
>   // Init futility move count array
>   for (d = 0; d < 32; d++)
>       FutilityMoveCounts[d] = int(3.001 + 0.25 * pow(d, 2.0));
370,397c326,348
< 	StateInfo st;
< 	int64_t sum = 0;
< 
< 	// Generate all legal moves
< 	MoveList<MV_LEGAL> ml(pos);
< 
< 	// If we are at the last ply we don't need to do and undo
< 	// the moves, just to count them.
< 	if (depth <= ONE_PLY)
< 		return ml.size();
< 
< 	// Loop through all legal moves
< #if !defined(NANOHA)
< 	CheckInfo ci(pos);
< #endif
< 	for ( ; !ml.end(); ++ml)
< 	{
< #if defined(NANOHA)
< 		pos.do_move(ml.move(), st);
< 		sum += perft(pos, depth - ONE_PLY);
< 		pos.undo_move(ml.move());
< #else
< 		pos.do_move(ml.move(), st, ci, pos.move_gives_check(ml.move(), ci));
< 		sum += perft(pos, depth - ONE_PLY);
< 		pos.undo_move(ml.move());
< #endif
< 	}
< 	return sum;
---
>   MoveStack mlist[MAX_MOVES];
>   StateInfo st;
>   Move m;
>   int64_t sum = 0;
> 
>   // Generate all legal moves
>   MoveStack* last = generate<MV_LEGAL>(pos, mlist);
> 
>   // If we are at the last ply we don't need to do and undo
>   // the moves, just to count them.
>   if (depth <= ONE_PLY)
>       return int(last - mlist);
> 
>   // Loop through all legal moves
>   CheckInfo ci(pos);
>   for (MoveStack* cur = mlist; cur != last; cur++)
>   {
>       m = cur->move;
>       pos.do_move(m, st, ci, pos.move_gives_check(m, ci));
>       sum += perft(pos, depth - ONE_PLY);
>       pos.undo_move(m);
>   }
>   return sum;
408,591c359,476
< #if !defined(NANOHA)
< 	static Book book; // Define static to initialize the PRNG only once
< #endif
< 
< 	// Initialize global search-related variables
< 	StopOnPonderhit = StopRequest = QuitRequest = AspirationFailLow = false;
< 	NodesSincePoll = 0;
< 	current_search_time(get_system_time());
< 	Limits = limits;
< 	TimeMgr.init(Limits, pos.startpos_ply_counter());
< 
< #if !defined(NANOHA)
< 	// Set output steram in normal or chess960 mode
< 	cout << set960(pos.is_chess960());
< #endif
< 
< 	// Set best NodesBetweenPolls interval to avoid lagging under time pressure
< 	if (Limits.maxNodes)
< 		NodesBetweenPolls = Min(Limits.maxNodes, 30000);
< 	else if (Limits.time && Limits.time < 1000)
< 		NodesBetweenPolls = 1000;
< 	else if (Limits.time && Limits.time < 5000)
< 		NodesBetweenPolls = 5000;
< 	else
< 		NodesBetweenPolls = 30000;
< 
< 	// Look for a book move
< 	if (Options["OwnBook"].value<bool>())
< 	{
< #if defined(NANOHA)
< 		bool bBestBookMove = !Options["RandomBookSelect"].value<bool>();
< 		Move bookMove = book ? book->get_move(pos, bBestBookMove) : MOVE_NONE;
< #else
< 		if (Options["Book File"].value<string>() != book.name())
< 			book.open(Options["Book File"].value<string>());
< 
< 		Move bookMove = book.probe(pos, Options["Best Book Move"].value<bool>());
< #endif
< 		if (bookMove != MOVE_NONE)
< 		{
< 			if (Limits.ponder)
< 				wait_for_stop_or_ponderhit();
< 
< #if defined(NANOHA)
< 			cout << "bestmove " << move_to_uci(bookMove) << endl;
< 			searchMoves[0] = bookMove;
< #else
< 			cout << "bestmove " << bookMove << endl;
< #endif
< 			return !QuitRequest;
< 		}
< 	}
< 
< #if defined(NANOHA)
< 	// 入玉勝ち宣言できるか？
< 	if (pos.IsKachi(pos.side_to_move()) != false) {
< 		if (Limits.ponder)
< 			wait_for_stop_or_ponderhit();
< 
< 		cout << "bestmove win" << endl;
< 		searchMoves[0] = MOVE_NONE;
< 		return !QuitRequest;
< 	}
< #endif
< 
< #if defined(NANOHA_DFPN)
< 	// 即詰みを確認する
< 	{
< 		// 一手詰めを確認する
< 		uint32_t refInfo;
< 		Move m;
< 		int value = (pos.side_to_move() == BLACK)
< 		           ? pos.Mate1ply<BLACK>(m, refInfo)
< 		           : pos.Mate1ply<WHITE>(m, refInfo);
< 		if (value == VALUE_MATE && m != MOVE_NONE) {
< 			if (Limits.ponder)
< 				wait_for_stop_or_ponderhit();
< 
< 			cout << "bestmove " << move_to_uci(m) << endl;
< 			searchMoves[0] = m;
< 			return !QuitRequest;
< 		}
< 	}
< #endif
< 
< 	// Read UCI options
< 	UCIMultiPV = Options["MultiPV"].value<int>();
< 	SkillLevel = Options["Skill Level"].value<int>();
< #if defined(NANOHA)
< 	DrawValue = (Value)(Options["DrawValue"].value<int>()*2);
< #endif
< 
< #if !defined(NANOHA)
< 	read_evaluation_uci_options(pos.side_to_move());
< #endif
< 	Threads.read_uci_options();
< 
< 	// Set a new TT size if changed
< 	TT.set_size(Options["Hash"].value<int>());
< 
< 	if (Options["Clear Hash"].value<bool>())
< 	{
< 		Options["Clear Hash"].set_value("false");
< 		TT.clear();
< 	}
< 
< 	// Do we have to play with skill handicap? In this case enable MultiPV that
< 	// we will use behind the scenes to retrieve a set of possible moves.
< 	SkillLevelEnabled = (SkillLevel < 20);
< 	MultiPV = (SkillLevelEnabled ? Max(UCIMultiPV, 4) : UCIMultiPV);
< 
< 	// Wake up needed threads and reset maxPly counter
< 	for (int i = 0; i < Threads.size(); i++)
< 	{
< 		Threads[i].wake_up();
< 		Threads[i].maxPly = 0;
< 	}
< 
< 	// Write to log file and keep it open to be accessed during the search
< 	if (Options["Use Search Log"].value<bool>())
< 	{
< 		string name = Options["Search Log Filename"].value<string>();
< 		LogFile.open(name.c_str(), std::ios::out | std::ios::app);
< 
< 		if (LogFile.is_open())
< 			LogFile << "\nSearching: "  << pos.to_fen()
< 			        << "\ninfinite: "   << Limits.infinite
< 			        << " ponder: "      << Limits.ponder
< 			        << " time: "        << Limits.time
< 			        << " increment: "   << Limits.increment
< 			        << " moves to go: " << Limits.movesToGo
< 			        << endl;
< 	}
< 
< 	// We're ready to start thinking. Call the iterative deepening loop function
< 	Move ponderMove = MOVE_NONE;
< 	Move bestMove = id_loop(pos, searchMoves, &ponderMove);
< 
< 	// Write final search statistics and close log file
< 	if (LogFile.is_open())
< 	{
< 		int t = current_search_time();
< 
< 		LogFile << "Nodes: "          << pos.nodes_searched()
< 		        << "\nNodes/second: " << (t > 0 ? pos.nodes_searched() * 1000 / t : 0)
< 		        << "\nBest move: "    << move_to_san(pos, bestMove);
< 
< 		StateInfo st;
< 		pos.do_move(bestMove, st);
< 		LogFile << "\nPonder move: " << move_to_san(pos, ponderMove) << endl;
< 		pos.undo_move(bestMove); // Return from think() with unchanged position
< 		LogFile.close();
< 	}
< 
< 	// This makes all the threads to go to sleep
< 	Threads.set_size(1);
< 
< 	// If we are pondering or in infinite search, we shouldn't print the
< 	// best move before we are told to do so.
< 	if (!StopRequest && (Limits.ponder || Limits.infinite))
< 		wait_for_stop_or_ponderhit();
< 
< 	// Could be MOVE_NONE when searching on a stalemate position
< #if defined(NANOHA)
< 	if (bestMove == MOVE_NONE) {
< 		cout << "bestmove resign";
< 	} else {
< 		cout << "bestmove " << move_to_uci(bestMove);
< 	}
< #else
< 	cout << "bestmove " << bestMove;
< #endif
< 
< 	// UCI protol is not clear on allowing sending an empty ponder move, instead
< 	// it is clear that ponder move is optional. So skip it if empty.
< #if defined(NANOHA)
< 	if (ponderMove != MOVE_NONE && Options["Ponder"].value<bool>())
< 		cout << " ponder " << move_to_uci(ponderMove);
< 
< 	searchMoves[0] = bestMove;
< #else
< 	if (ponderMove != MOVE_NONE)
< 		cout << " ponder " << ponderMove;
< #endif
---
>   static Book book;
> 
>   // Initialize global search-related variables
>   StopOnPonderhit = StopRequest = QuitRequest = AspirationFailLow = SendSearchedNodes = false;
>   NodesSincePoll = 0;
>   current_search_time(get_system_time());
>   Limits = limits;
>   TimeMgr.init(Limits, pos.startpos_ply_counter());
> 
>   // Set best NodesBetweenPolls interval to avoid lagging under time pressure
>   if (Limits.maxNodes)
>       NodesBetweenPolls = Min(Limits.maxNodes, 30000);
>   else if (Limits.time && Limits.time < 1000)
>       NodesBetweenPolls = 1000;
>   else if (Limits.time && Limits.time < 5000)
>       NodesBetweenPolls = 5000;
>   else
>       NodesBetweenPolls = 30000;
> 
>   // Look for a book move
>   if (Options["OwnBook"].value<bool>())
>   {
>       if (Options["Book File"].value<std::string>() != book.name())
>           book.open(Options["Book File"].value<std::string>());
> 
>       Move bookMove = book.get_move(pos, Options["Best Book Move"].value<bool>());
>       if (bookMove != MOVE_NONE)
>       {
>           if (Limits.ponder)
>               wait_for_stop_or_ponderhit();
> 
>           cout << "bestmove " << bookMove << endl;
>           return !QuitRequest;
>       }
>   }
> 
>   // Read UCI options
>   UCIMultiPV = Options["MultiPV"].value<int>();
>   SkillLevel = Options["Skill Level"].value<int>();
> 
>   read_evaluation_uci_options(pos.side_to_move());
>   Threads.read_uci_options();
> 
>   // If needed allocate pawn and material hash tables and adjust TT size
>   Threads.init_hash_tables();
>   TT.set_size(Options["Hash"].value<int>());
> 
>   if (Options["Clear Hash"].value<bool>())
>   {
>       Options["Clear Hash"].set_value("false");
>       TT.clear();
>   }
> 
>   // Do we have to play with skill handicap? In this case enable MultiPV that
>   // we will use behind the scenes to retrieve a set of possible moves.
>   SkillLevelEnabled = (SkillLevel < 20);
>   MultiPV = (SkillLevelEnabled ? Max(UCIMultiPV, 4) : UCIMultiPV);
> 
>   // Wake up needed threads and reset maxPly counter
>   for (int i = 0; i < Threads.size(); i++)
>   {
>       Threads[i].wake_up();
>       Threads[i].maxPly = 0;
>   }
> 
>   // Write to log file and keep it open to be accessed during the search
>   if (Options["Use Search Log"].value<bool>())
>   {
>       std::string name = Options["Search Log Filename"].value<std::string>();
>       LogFile.open(name.c_str(), std::ios::out | std::ios::app);
> 
>       if (LogFile.is_open())
>           LogFile << "\nSearching: "  << pos.to_fen()
>                   << "\ninfinite: "   << Limits.infinite
>                   << " ponder: "      << Limits.ponder
>                   << " time: "        << Limits.time
>                   << " increment: "   << Limits.increment
>                   << " moves to go: " << Limits.movesToGo
>                   << endl;
>   }
> 
>   // We're ready to start thinking. Call the iterative deepening loop function
>   Move ponderMove = MOVE_NONE;
>   Move bestMove = id_loop(pos, searchMoves, &ponderMove);
> 
>   cout << "info" << speed_to_uci(pos.nodes_searched()) << endl;
> 
>   // Write final search statistics and close log file
>   if (LogFile.is_open())
>   {
>       int t = current_search_time();
> 
>       LogFile << "Nodes: "          << pos.nodes_searched()
>               << "\nNodes/second: " << (t > 0 ? pos.nodes_searched() * 1000 / t : 0)
>               << "\nBest move: "    << move_to_san(pos, bestMove);
> 
>       StateInfo st;
>       pos.do_move(bestMove, st);
>       LogFile << "\nPonder move: " << move_to_san(pos, ponderMove) << endl;
>       pos.undo_move(bestMove); // Return from think() with unchanged position
>       LogFile.close();
>   }
> 
>   // This makes all the threads to go to sleep
>   Threads.set_size(1);
> 
>   // If we are pondering or in infinite search, we shouldn't print the
>   // best move before we are told to do so.
>   if (!StopRequest && (Limits.ponder || Limits.infinite))
>       wait_for_stop_or_ponderhit();
> 
>   // Could be MOVE_NONE when searching on a stalemate position
>   cout << "bestmove " << bestMove;
> 
>   // UCI protol is not clear on allowing sending an empty ponder move, instead
>   // it is clear that ponder move is optional. So skip it if empty.
>   if (ponderMove != MOVE_NONE)
>       cout << " ponder " << ponderMove;
593c478
< 	cout << endl;
---
>   cout << endl;
595c480
< 	return !QuitRequest;
---
>   return !QuitRequest;
601,1154c486,876
< 	// id_loop() is the main iterative deepening loop. It calls search() repeatedly
< 	// with increasing depth until the allocated thinking time has been consumed,
< 	// user stops the search, or the maximum search depth is reached.
< 
< 	Move id_loop(Position& pos, Move searchMoves[], Move* ponderMove) {
< 
< 		SearchStack ss[PLY_MAX_PLUS_2];
< 		Value bestValues[PLY_MAX_PLUS_2];
< 		int bestMoveChanges[PLY_MAX_PLUS_2];
< 		int depth, aspirationDelta;
< 		Value value, alpha, beta;
< 		Move bestMove, easyMove, skillBest, skillPonder;
< 
< 		// Initialize stuff before a new search
< 		memset(ss, 0, 4 * sizeof(SearchStack));
< 		TT.new_search();
< 		H.clear();
< 		*ponderMove = bestMove = easyMove = skillBest = skillPonder = MOVE_NONE;
< 		depth = aspirationDelta = 0;
< 		value = alpha = -VALUE_INFINITE, beta = VALUE_INFINITE;
< 		ss->currentMove = MOVE_NULL; // Hack to skip update_gains()
< 
< 		// Moves to search are verified and copied
< 		Rml.init(pos, searchMoves);
< 
< 		// Handle special case of searching on a mate/stalemate position
< 		if (!Rml.size())
< 		{
< #if defined(NANOHA)
< 			// 将棋で Stalemate は投了.
< 			cout << "info" << depth_to_uci(DEPTH_ZERO)
< 			     << score_to_uci(-VALUE_MATE, alpha, beta) << endl;
< #else
< 			cout << "info" << depth_to_uci(DEPTH_ZERO)
< 			     << score_to_uci(pos.in_check() ? -VALUE_MATE : VALUE_DRAW, alpha, beta) << endl;
< #endif
< 
< 			return MOVE_NONE;
< 		}
< 
< 		// Iterative deepening loop until requested to stop or target depth reached
< 		while (!StopRequest && ++depth <= PLY_MAX && (!Limits.maxDepth || depth <= Limits.maxDepth))
< 		{
< 			// Save last iteration's scores, this needs to be done now, because in
< 			// the following MultiPV loop Rml moves could be reordered.
< 			for (size_t i = 0; i < Rml.size(); i++)
< 				Rml[i].prevScore = Rml[i].score;
< 
< 			Rml.bestMoveChanges = 0;
< 
< 			// MultiPV iteration loop
< 			for (MultiPVIteration = 0; MultiPVIteration < Min(MultiPV, (int)Rml.size()); MultiPVIteration++)
< 			{
< 				// Calculate dynamic aspiration window based on previous iterations
< 				if (depth >= 5 && abs(Rml[MultiPVIteration].prevScore) < VALUE_KNOWN_WIN)
< 				{
< 					int prevDelta1 = bestValues[depth - 1] - bestValues[depth - 2];
< 					int prevDelta2 = bestValues[depth - 2] - bestValues[depth - 3];
< 
< 					aspirationDelta = Min(Max(abs(prevDelta1) + abs(prevDelta2) / 2, 16), 24);
< 					aspirationDelta = (aspirationDelta + 7) / 8 * 8; // Round to match grainSize
< 
< 					alpha = Max(Rml[MultiPVIteration].prevScore - aspirationDelta, -VALUE_INFINITE);
< 					beta  = Min(Rml[MultiPVIteration].prevScore + aspirationDelta,  VALUE_INFINITE);
< 				}
< 				else
< 				{
< 					alpha = -VALUE_INFINITE;
< 					beta  =  VALUE_INFINITE;
< 				}
< 
< 				// Start with a small aspiration window and, in case of fail high/low,
< 				// research with bigger window until not failing high/low anymore.
< 				do {
< 					// Search starting from ss+1 to allow referencing (ss-1). This is
< 					// needed by update_gains() and ss copy when splitting at Root.
< 					value = search<Root>(pos, ss+1, alpha, beta, depth * ONE_PLY);
< 
< 					// It is critical that sorting is done with a stable algorithm
< 					// because all the values but the first are usually set to
< 					// -VALUE_INFINITE and we want to keep the same order for all
< 					// the moves but the new PV that goes to head.
< 					sort<RootMove>(Rml.begin() + MultiPVIteration, Rml.end());
< 
< 					// In case we have found an exact score reorder the PV moves
< 					// before leaving the fail high/low loop, otherwise leave the
< 					// last PV move in its position so to be searched again.
< 					if (value > alpha && value < beta)
< 						sort<RootMove>(Rml.begin(), Rml.begin() + MultiPVIteration);
< 
< 					// Write PV back to transposition table in case the relevant entries
< 					// have been overwritten during the search.
< 					for (int i = 0; i <= MultiPVIteration; i++)
< 						Rml[i].insert_pv_in_tt(pos);
< 
< 					// Value cannot be trusted. Break out immediately!
< 					if (StopRequest)
< 						break;
< 
< 					// Send full PV info to GUI if we are going to leave the loop or
< 					// if we have a fail high/low and we are deep in the search.
< #if defined(NANOHA)
< 					if (Options["Output_AllDepth"].value<bool>() || (value > alpha && value < beta) || current_search_time() > 500)
< #else
< 					if ((value > alpha && value < beta) || current_search_time() > 2000)
< #endif
< 						for (int i = 0; i < Min(UCIMultiPV, MultiPVIteration + 1); i++)
< 							cout << "info"
< 							     << depth_to_uci(depth * ONE_PLY)
< 							     << (i == MultiPVIteration ? score_to_uci(Rml[i].score, alpha, beta) :
< 							                                 score_to_uci(Rml[i].score))
< 							     << speed_to_uci(pos.nodes_searched())
< #if defined(NANOHA)
< 							     << pv_to_uci(&Rml[i].pv[0], i + 1, false)
< #else
< 							     << pv_to_uci(&Rml[i].pv[0], i + 1, pos.is_chess960())
< #endif
< 							     << endl;
< 
< 					// In case of failing high/low increase aspiration window and research,
< 					// otherwise exit the fail high/low loop.
< 					if (value >= beta)
< 					{
< 						beta = Min(beta + aspirationDelta, VALUE_INFINITE);
< 						aspirationDelta += aspirationDelta / 2;
< 					}
< 					else if (value <= alpha)
< 					{
< 						AspirationFailLow = true;
< 						StopOnPonderhit = false;
< 
< 						alpha = Max(alpha - aspirationDelta, -VALUE_INFINITE);
< 						aspirationDelta += aspirationDelta / 2;
< 					}
< 					else
< 						break;
< 
< 				} while (abs(value) < VALUE_KNOWN_WIN);
< 			}
< 
< 			// Collect info about search result
< 			bestMove = Rml[0].pv[0];
< 			*ponderMove = Rml[0].pv[1];
< 			bestValues[depth] = value;
< 			bestMoveChanges[depth] = Rml.bestMoveChanges;
< 
< 			// Do we need to pick now the best and the ponder moves ?
< 			if (SkillLevelEnabled && depth == 1 + SkillLevel)
< 				do_skill_level(&skillBest, &skillPonder);
< 
< 			if (LogFile.is_open())
< 				LogFile << pretty_pv(pos, depth, value, current_search_time(), &Rml[0].pv[0]) << endl;
< 
< 			// Init easyMove after first iteration or drop if differs from the best move
< 			if (depth == 1 && (Rml.size() == 1 || Rml[0].score > Rml[1].score + EasyMoveMargin))
< 				easyMove = bestMove;
< 			else if (bestMove != easyMove)
< 				easyMove = MOVE_NONE;
< 
< 			// Check for some early stop condition
< 			if (!StopRequest && Limits.useTimeManagement())
< 			{
< 				// Stop search early if one move seems to be much better than the
< 				// others or if there is only a single legal move. Also in the latter
< 				// case we search up to some depth anyway to get a proper score.
< 				if (   depth >= 7
< 				    && easyMove == bestMove
< 				    && (   Rml.size() == 1
< 				        ||(   Rml[0].nodes > (pos.nodes_searched() * 85) / 100
< 				           && current_search_time() > TimeMgr.available_time() / 16)
< 				        ||(   Rml[0].nodes > (pos.nodes_searched() * 98) / 100
< 				           && current_search_time() > TimeMgr.available_time() / 32)))
< 					StopRequest = true;
< 
< 				// Take in account some extra time if the best move has changed
< 				if (depth > 4 && depth < 50)
< 					TimeMgr.pv_instability(bestMoveChanges[depth], bestMoveChanges[depth - 1]);
< 
< 				// Stop search if most of available time is already consumed. We probably don't
< 				// have enough time to search the first move at the next iteration anyway.
< 				if (current_search_time() > (TimeMgr.available_time() * 62) / 100)
< 					StopRequest = true;
< 
< 				// If we are allowed to ponder do not stop the search now but keep pondering
< 				if (StopRequest && Limits.ponder)
< 				{
< 					StopRequest = false;
< 					StopOnPonderhit = true;
< 				}
< 			}
< 		}
< 
< 		// When using skills overwrite best and ponder moves with the sub-optimal ones
< 		if (SkillLevelEnabled)
< 		{
< 			if (skillBest == MOVE_NONE) // Still unassigned ?
< 				do_skill_level(&skillBest, &skillPonder);
< 
< 			bestMove = skillBest;
< 			*ponderMove = skillPonder;
< 		}
< 
< 		return bestMove;
< 	}
< 
< 
< 	// search<>() is the main search function for both PV and non-PV nodes and for
< 	// normal and SplitPoint nodes. When called just after a split point the search
< 	// is simpler because we have already probed the hash table, done a null move
< 	// search, and searched the first move before splitting, we don't have to repeat
< 	// all this work again. We also don't need to store anything to the hash table
< 	// here: This is taken care of after we return from the split point.
< 
< 	template <NodeType NT>
< 	Value search(Position& pos, SearchStack* ss, Value alpha, Value beta, Depth depth) {
< 
< 		const bool PvNode   = (NT == PV || NT == Root || NT == SplitPointPV || NT == SplitPointRoot);
< 		const bool SpNode   = (NT == SplitPointPV || NT == SplitPointNonPV || NT == SplitPointRoot);
< 		const bool RootNode = (NT == Root || NT == SplitPointRoot);
< 
< 		assert(alpha >= -VALUE_INFINITE && alpha <= VALUE_INFINITE);
< 		assert(beta > alpha && beta <= VALUE_INFINITE);
< 		assert(PvNode || alpha == beta - 1);
< 		assert(pos.thread() >= 0 && pos.thread() < Threads.size());
< 
< 		Move movesSearched[MAX_MOVES];
< 		int64_t nodes;
< 		StateInfo st;
< 		const TTEntry *tte;
< 		Key posKey;
< 		Move ttMove, move, excludedMove, threatMove;
< 		Depth ext, newDepth;
< 		ValueType vt;
< 		Value bestValue, value, oldAlpha;
< 		Value refinedValue, nullValue, futilityBase, futilityValue;
< 		bool isPvMove, inCheck, singularExtensionNode, givesCheck, captureOrPromotion, dangerous;
< 		int moveCount = 0, playedMoveCount = 0;
< 		Thread& thread = Threads[pos.thread()];
< 		SplitPoint* sp = NULL;
< #if defined(NANOHA)
< 		int repeat_check=0;
< #endif
< 
< #if defined(NANOHA)
< // 手番のときに王手をかけている状態は本来ありえない(前の手で王手回避していないか、自殺手を指していることになる)
< 		if(pos.at_checking()){
< 			return value_mate_in(0);
< 		}
< #endif
< 		refinedValue = bestValue = value = -VALUE_INFINITE;
< 		oldAlpha = alpha;
< 		inCheck = pos.in_check();
< 		ss->ply = (ss-1)->ply + 1;
< 
< 		// Used to send selDepth info to GUI
< 		if (PvNode && thread.maxPly < ss->ply)
< 			thread.maxPly = ss->ply;
< 
< 		// Step 1. Initialize node and poll. Polling can abort search
< 		if (!SpNode)
< 		{
< 			ss->currentMove = ss->bestMove = threatMove = (ss+1)->excludedMove = MOVE_NONE;
< 			(ss+1)->skipNullMove = false; (ss+1)->reduction = DEPTH_ZERO;
< 			(ss+2)->killers[0] = (ss+2)->killers[1] = MOVE_NONE;
< 		}
< 		else
< 		{
< 			sp = ss->sp;
< 			tte = NULL;
< 			ttMove = excludedMove = MOVE_NONE;
< 			threatMove = sp->threatMove;
< 			goto split_point_start;
< 		}
< 
< 		if (pos.thread() == 0 && ++NodesSincePoll > NodesBetweenPolls)
< 		{
< 			NodesSincePoll = 0;
< 			poll(pos);
< 		}
< 
< 		// Step 2. Check for aborted search and immediate draw
< 		if ((   StopRequest
< #if defined(NANOHA)
< 		   || pos.is_draw(repeat_check)
< #else
< 		   || pos.is_draw<false>()
< #endif
< 		   || ss->ply > PLY_MAX) && !RootNode)
< #if defined(NANOHA)
< 			return value_draw(pos);
< #else
< 			return VALUE_DRAW;
< #endif
< #if defined(NANOHA)
< 
< 		if ( !Root ){
< 			if(repeat_check<0) {
< 				return value_mated_in(ss->ply);
< 			} else if(repeat_check>0) {
< 				return value_mate_in(ss->ply);
< 			}
< 			// 入玉宣言
< 			if (pos.IsKachi(pos.side_to_move()) != false) {
< 				return value_mate_in(ss->ply+1);
< 			}
< 		}
< 		// 3手詰めルーチンコール
< 		if (!ss->checkmateTested) {
< 			ss->checkmateTested = true;
< 			uint32_t info;
< 			Move m;
< 			int val = (pos.side_to_move() == BLACK)
< 			        ? pos.Mate1ply<BLACK>(m, info)
< 			        : pos.Mate1ply<WHITE>(m, info);
< 			if (val == VALUE_MATE) {
< 				return value_mate_in(ss->ply);
< 			}
< 			val = pos.Mate3(pos.side_to_move(), m);
< 			if (val == VALUE_MATE) {
< 				return value_mate_in(ss->ply+2);
< 			}
< 		}
< #endif
< 
< 		// Step 3. Mate distance pruning
< 		if (!RootNode)
< 		{
< 			alpha = Max(value_mated_in(ss->ply), alpha);
< 			beta = Min(value_mate_in(ss->ply+1), beta);
< 			if (alpha >= beta)
< 				return alpha;
< 		}
< 
< 		// Step 4. Transposition table lookup
< 		// We don't want the score of a partial search to overwrite a previous full search
< 		// TT value, so we use a different position key in case of an excluded move.
< 		excludedMove = ss->excludedMove;
< #if defined(NANOHA)
< 		posKey = excludedMove != MOVE_NONE ? pos.get_exclusion_key() : pos.get_key();
< 		tte = TT.probe(posKey, pos.handValue_of_side());
< #else
< 		posKey = excludedMove ? pos.get_exclusion_key() : pos.get_key();
< 		tte = TT.probe(posKey);
< #endif
< 		ttMove = RootNode ? Rml[MultiPVIteration].pv[0] : tte ? tte->move() : MOVE_NONE;
< 
< 		// At PV nodes we check for exact scores, while at non-PV nodes we check for
< 		// a fail high/low. Biggest advantage at probing at PV nodes is to have a
< 		// smooth experience in analysis mode. We don't probe at Root nodes otherwise
< 		// we should also update RootMoveList to avoid bogus output.
< 		if (!RootNode && tte && (PvNode ? tte->depth() >= depth && tte->type() == VALUE_TYPE_EXACT
< 		                                : can_return_tt(tte, depth, beta, ss->ply)))
< 		{
< 			TT.refresh(tte);
< 			ss->bestMove = move = ttMove; // Can be MOVE_NONE
< 			value = value_from_tt(tte->value(), ss->ply);
< 
< 			if (   value >= beta
< 			    && move
< #if defined(NANOHA)
< 			    && !pos.is_capture(move)
< #else
< 			    && !pos.is_capture_or_promotion(move)
< #endif
< 			    && move != ss->killers[0])
< 			{
< 				ss->killers[1] = ss->killers[0];
< 				ss->killers[0] = move;
< 			}
< 			return value;
< 		}
< 
< 		// Step 5. Evaluate the position statically and update parent's gain statistics
< 		if (inCheck)
< 			ss->eval = ss->evalMargin = VALUE_NONE;
< 		else if (tte)
< 		{
< 			assert(tte->static_value() != VALUE_NONE);
< 
< 			ss->eval = tte->static_value();
< 			ss->evalMargin = tte->static_value_margin();
< 			refinedValue = refine_eval(tte, ss->eval, ss->ply);
< 		}
< 		else
< 		{
< 			refinedValue = ss->eval = evaluate(pos, ss->evalMargin);
< #if defined(NANOHA)
< 			TT.store(posKey, pos.handValue_of_side(), VALUE_NONE, VALUE_TYPE_NONE, DEPTH_NONE, MOVE_NONE, ss->eval, ss->evalMargin);
< #else
< 			TT.store(posKey, VALUE_NONE, VALUE_TYPE_NONE, DEPTH_NONE, MOVE_NONE, ss->eval, ss->evalMargin);
< #endif
< 		}
< 
< 		// Save gain for the parent non-capture move
< 		update_gains(pos, (ss-1)->currentMove, (ss-1)->eval, ss->eval);
< 
< 		// Step 6. Razoring (is omitted in PV nodes)
< 		if (   !PvNode
< 		    &&  depth < RazorDepth
< 		    && !inCheck
< 		    &&  refinedValue + razor_margin(depth) < beta
< 		    &&  ttMove == MOVE_NONE
< 		    &&  abs(beta) < VALUE_MATE_IN_PLY_MAX
< #if defined(NANOHA)
< 		)
< #else
< 		    && !pos.has_pawn_on_7th(pos.side_to_move()))
< #endif
< 		{
< 			Value rbeta = beta - razor_margin(depth);
< 			Value v = qsearch<NonPV>(pos, ss, rbeta-1, rbeta, DEPTH_ZERO);
< 			if (v < rbeta)
< 				// Logically we should return (v + razor_margin(depth)), but
< 				// surprisingly this did slightly weaker in tests.
< 				return v;
< 		}
< 
< 		// Step 7. Static null move pruning (is omitted in PV nodes)
< 		// We're betting that the opponent doesn't have a move that will reduce
< 		// the score by more than futility_margin(depth) if we do a null move.
< 		if (   !PvNode
< 		    && !ss->skipNullMove
< 		    &&  depth < RazorDepth
< 		    && !inCheck
< 		    &&  refinedValue - futility_margin(depth, 0) >= beta
< 		    &&  abs(beta) < VALUE_MATE_IN_PLY_MAX
< #if defined(NANOHA)
< 		 )
< #else
< 		    &&  pos.non_pawn_material(pos.side_to_move()))
< #endif
< 			return refinedValue - futility_margin(depth, 0);
< 
< 		// Step 8. Null move search with verification search (is omitted in PV nodes)
< 		if (   !PvNode
< 		    && !ss->skipNullMove
< 		    &&  depth > ONE_PLY
< 		    && !inCheck
< 		    &&  refinedValue >= beta
< 		    &&  abs(beta) < VALUE_MATE_IN_PLY_MAX
< #if defined(NANOHA)
< 		  )
< #else
< 		    &&  pos.non_pawn_material(pos.side_to_move()))
< #endif
< 		{
< 			ss->currentMove = MOVE_NULL;
< 
< 			// Null move dynamic reduction based on depth
< 			int R = 3 + (depth >= 5 * ONE_PLY ? depth / 8 : 0);
< 
< 			// Null move dynamic reduction based on value
< 			if (refinedValue - PawnValueMidgame > beta)
< 				R++;
< 
< 			pos.do_null_move(st);
< 			(ss+1)->skipNullMove = true;
< 			nullValue = depth-R*ONE_PLY < ONE_PLY ? -qsearch<NonPV>(pos, ss+1, -beta, -alpha, DEPTH_ZERO)
< 			                                      : - search<NonPV>(pos, ss+1, -beta, -alpha, depth-R*ONE_PLY);
< 			(ss+1)->skipNullMove = false;
< 			pos.undo_null_move();
< 
< 			if (nullValue >= beta)
< 			{
< 				// Do not return unproven mate scores
< 				if (nullValue >= VALUE_MATE_IN_PLY_MAX)
< 					nullValue = beta;
< 
< 				if (depth < 6 * ONE_PLY)
< 					return nullValue;
< 
< 				// Do verification search at high depths
< 				ss->skipNullMove = true;
< 				Value v = search<NonPV>(pos, ss, alpha, beta, depth-R*ONE_PLY);
< 				ss->skipNullMove = false;
< 
< 				if (v >= beta)
< 					return nullValue;
< 			}
< 			else
< 			{
< 				// The null move failed low, which means that we may be faced with
< 				// some kind of threat. If the previous move was reduced, check if
< 				// the move that refuted the null move was somehow connected to the
< 				// move which was reduced. If a connection is found, return a fail
< 				// low score (which will cause the reduced move to fail high in the
< 				// parent node, which will trigger a re-search with full depth).
< 				threatMove = (ss+1)->bestMove;
< 
< 				if (   depth < ThreatDepth
< 				    && (ss-1)->reduction
< 				    && threatMove != MOVE_NONE
< 				    && connected_moves(pos, (ss-1)->currentMove, threatMove))
< 					return beta - 1;
< 			}
< 		}
< 
< 		// Step 9. ProbCut (is omitted in PV nodes)
< 		// If we have a very good capture (i.e. SEE > seeValues[captured_piece_type])
< 		// and a reduced search returns a value much above beta, we can (almost) safely
< 		// prune the previous move.
< 		if (   !PvNode
< 		    &&  depth >= RazorDepth + ONE_PLY
< 		    && !inCheck
< 		    && !ss->skipNullMove
< 		    &&  excludedMove == MOVE_NONE
< 		    &&  abs(beta) < VALUE_MATE_IN_PLY_MAX)
< 		{
< 			Value rbeta = beta + 200;
< 			Depth rdepth = depth - ONE_PLY - 3 * ONE_PLY;
< 
< 			assert(rdepth >= ONE_PLY);
< 
< 			MovePicker mp(pos, ttMove, H, pos.captured_piece_type());
< #if !defined(NANOHA)
< 			CheckInfo ci(pos);
< #endif
< 
< 			while ((move = mp.get_next_move()) != MOVE_NONE)
< #if defined(NANOHA)
< 				if (pos.pl_move_is_legal(move))
< #else
< 				if (pos.pl_move_is_legal(move, ci.pinned))
< #endif
< 				{
< #if defined(NANOHA)
< 					pos.do_move(move, st);
< #else
< 					pos.do_move(move, st, ci, pos.move_gives_check(move, ci));
< #endif
< 					value = -search<NonPV>(pos, ss+1, -rbeta, -rbeta+1, rdepth);
< 					pos.undo_move(move);
< 					if (value >= rbeta)
< 						return value;
< 				}
< 		}
< 
< 		// Step 10. Internal iterative deepening
< 		if (   depth >= IIDDepth[PvNode]
< 		    && ttMove == MOVE_NONE
< 		    && (PvNode || (!inCheck && ss->eval + IIDMargin >= beta)))
< 		{
< 			Depth d = (PvNode ? depth - 2 * ONE_PLY : depth / 2);
< 
< 			ss->skipNullMove = true;
< 			search<PvNode ? PV : NonPV>(pos, ss, alpha, beta, d);
< 			ss->skipNullMove = false;
< 
< #if defined(NANOHA)
< 			tte = TT.probe(posKey, pos.handValue_of_side());
< #else
< 			tte = TT.probe(posKey);
< #endif
< 		}
---
>   // id_loop() is the main iterative deepening loop. It calls search() repeatedly
>   // with increasing depth until the allocated thinking time has been consumed,
>   // user stops the search, or the maximum search depth is reached.
> 
>   Move id_loop(Position& pos, Move searchMoves[], Move* ponderMove) {
> 
>     SearchStack ss[PLY_MAX_PLUS_2];
>     Value bestValues[PLY_MAX_PLUS_2];
>     int bestMoveChanges[PLY_MAX_PLUS_2];
>     int depth, selDepth, aspirationDelta;
>     Value value, alpha, beta;
>     Move bestMove, easyMove, skillBest, skillPonder;
> 
>     // Initialize stuff before a new search
>     memset(ss, 0, 4 * sizeof(SearchStack));
>     TT.new_search();
>     H.clear();
>     *ponderMove = bestMove = easyMove = skillBest = skillPonder = MOVE_NONE;
>     depth = aspirationDelta = 0;
>     alpha = -VALUE_INFINITE, beta = VALUE_INFINITE;
>     ss->currentMove = MOVE_NULL; // Hack to skip update_gains()
> 
>     // Moves to search are verified and copied
>     Rml.init(pos, searchMoves);
> 
>     // Handle special case of searching on a mate/stalemate position
>     if (Rml.size() == 0)
>     {
>         cout << "info depth 0 score "
>              << value_to_uci(pos.in_check() ? -VALUE_MATE : VALUE_DRAW)
>              << endl;
> 
>         return MOVE_NONE;
>     }
> 
>     // Iterative deepening loop until requested to stop or target depth reached
>     while (!StopRequest && ++depth <= PLY_MAX && (!Limits.maxDepth || depth <= Limits.maxDepth))
>     {
>         Rml.bestMoveChanges = 0;
>         cout << set960(pos.is_chess960()) << "info depth " << depth << endl;
> 
>         // Calculate dynamic aspiration window based on previous iterations
>         if (MultiPV == 1 && depth >= 5 && abs(bestValues[depth - 1]) < VALUE_KNOWN_WIN)
>         {
>             int prevDelta1 = bestValues[depth - 1] - bestValues[depth - 2];
>             int prevDelta2 = bestValues[depth - 2] - bestValues[depth - 3];
> 
>             aspirationDelta = Min(Max(abs(prevDelta1) + abs(prevDelta2) / 2, 16), 24);
>             aspirationDelta = (aspirationDelta + 7) / 8 * 8; // Round to match grainSize
> 
>             alpha = Max(bestValues[depth - 1] - aspirationDelta, -VALUE_INFINITE);
>             beta  = Min(bestValues[depth - 1] + aspirationDelta,  VALUE_INFINITE);
>         }
> 
>         // Start with a small aspiration window and, in case of fail high/low,
>         // research with bigger window until not failing high/low anymore.
>         do {
>             // Search starting from ss+1 to allow calling update_gains()
>             value = search<PV, false, true>(pos, ss+1, alpha, beta, depth * ONE_PLY);
> 
>             // Write PV back to transposition table in case the relevant entries
>             // have been overwritten during the search.
>             for (int i = 0; i < Min(MultiPV, (int)Rml.size()); i++)
>                 Rml[i].insert_pv_in_tt(pos);
> 
>             // Value cannot be trusted. Break out immediately!
>             if (StopRequest)
>                 break;
> 
>             assert(value >= alpha);
> 
>             // In case of failing high/low increase aspiration window and research,
>             // otherwise exit the fail high/low loop.
>             if (value >= beta)
>             {
>                 beta = Min(beta + aspirationDelta, VALUE_INFINITE);
>                 aspirationDelta += aspirationDelta / 2;
>             }
>             else if (value <= alpha)
>             {
>                 AspirationFailLow = true;
>                 StopOnPonderhit = false;
> 
>                 alpha = Max(alpha - aspirationDelta, -VALUE_INFINITE);
>                 aspirationDelta += aspirationDelta / 2;
>             }
>             else
>                 break;
> 
>         } while (abs(value) < VALUE_KNOWN_WIN);
> 
>         // Collect info about search result
>         bestMove = Rml[0].pv[0];
>         *ponderMove = Rml[0].pv[1];
>         bestValues[depth] = value;
>         bestMoveChanges[depth] = Rml.bestMoveChanges;
> 
>         // Do we need to pick now the best and the ponder moves ?
>         if (SkillLevelEnabled && depth == 1 + SkillLevel)
>             do_skill_level(&skillBest, &skillPonder);
> 
>         // Retrieve max searched depth among threads
>         selDepth = 0;
>         for (int i = 0; i < Threads.size(); i++)
>             if (Threads[i].maxPly > selDepth)
>                 selDepth = Threads[i].maxPly;
> 
>         // Send PV line to GUI and to log file
>         for (int i = 0; i < Min(UCIMultiPV, (int)Rml.size()); i++)
>             cout << Rml[i].pv_info_to_uci(pos, depth, selDepth, alpha, beta, i) << endl;
> 
>         if (LogFile.is_open())
>             LogFile << pretty_pv(pos, depth, value, current_search_time(), Rml[0].pv) << endl;
> 
>         // Init easyMove after first iteration or drop if differs from the best move
>         if (depth == 1 && (Rml.size() == 1 || Rml[0].pv_score > Rml[1].pv_score + EasyMoveMargin))
>             easyMove = bestMove;
>         else if (bestMove != easyMove)
>             easyMove = MOVE_NONE;
> 
>         // Check for some early stop condition
>         if (!StopRequest && Limits.useTimeManagement())
>         {
>             // Stop search early when the last two iterations returned a mate score
>             if (   depth >= 5
>                 && abs(bestValues[depth])     >= VALUE_MATE_IN_PLY_MAX
>                 && abs(bestValues[depth - 1]) >= VALUE_MATE_IN_PLY_MAX)
>                 StopRequest = true;
> 
>             // Stop search early if one move seems to be much better than the
>             // others or if there is only a single legal move. Also in the latter
>             // case we search up to some depth anyway to get a proper score.
>             if (   depth >= 7
>                 && easyMove == bestMove
>                 && (   Rml.size() == 1
>                     ||(   Rml[0].nodes > (pos.nodes_searched() * 85) / 100
>                        && current_search_time() > TimeMgr.available_time() / 16)
>                     ||(   Rml[0].nodes > (pos.nodes_searched() * 98) / 100
>                        && current_search_time() > TimeMgr.available_time() / 32)))
>                 StopRequest = true;
> 
>             // Take in account some extra time if the best move has changed
>             if (depth > 4 && depth < 50)
>                 TimeMgr.pv_instability(bestMoveChanges[depth], bestMoveChanges[depth - 1]);
> 
>             // Stop search if most of available time is already consumed. We probably don't
>             // have enough time to search the first move at the next iteration anyway.
>             if (current_search_time() > (TimeMgr.available_time() * 62) / 100)
>                 StopRequest = true;
> 
>             // If we are allowed to ponder do not stop the search now but keep pondering
>             if (StopRequest && Limits.ponder)
>             {
>                 StopRequest = false;
>                 StopOnPonderhit = true;
>             }
>         }
>     }
> 
>     // When using skills overwrite best and ponder moves with the sub-optimal ones
>     if (SkillLevelEnabled)
>     {
>         if (skillBest == MOVE_NONE) // Still unassigned ?
>             do_skill_level(&skillBest, &skillPonder);
> 
>         bestMove = skillBest;
>         *ponderMove = skillPonder;
>     }
> 
>     return bestMove;
>   }
> 
> 
>   // search<>() is the main search function for both PV and non-PV nodes and for
>   // normal and SplitPoint nodes. When called just after a split point the search
>   // is simpler because we have already probed the hash table, done a null move
>   // search, and searched the first move before splitting, we don't have to repeat
>   // all this work again. We also don't need to store anything to the hash table
>   // here: This is taken care of after we return from the split point.
> 
>   template <NodeType PvNode, bool SpNode, bool Root>
>   Value search(Position& pos, SearchStack* ss, Value alpha, Value beta, Depth depth) {
> 
>     assert(alpha >= -VALUE_INFINITE && alpha <= VALUE_INFINITE);
>     assert(beta > alpha && beta <= VALUE_INFINITE);
>     assert(PvNode || alpha == beta - 1);
>     assert(pos.thread() >= 0 && pos.thread() < Threads.size());
> 
>     Move movesSearched[MAX_MOVES];
>     int64_t nodes;
>     StateInfo st;
>     const TTEntry *tte;
>     Key posKey;
>     Move ttMove, move, excludedMove, threatMove;
>     Depth ext, newDepth;
>     ValueType vt;
>     Value bestValue, value, oldAlpha;
>     Value refinedValue, nullValue, futilityBase, futilityValueScaled; // Non-PV specific
>     bool isPvMove, inCheck, singularExtensionNode, givesCheck, captureOrPromotion, dangerous, isBadCap;
>     int moveCount = 0, playedMoveCount = 0;
>     int threadID = pos.thread();
>     SplitPoint* sp = NULL;
> 
>     refinedValue = bestValue = value = -VALUE_INFINITE;
>     oldAlpha = alpha;
>     inCheck = pos.in_check();
>     ss->ply = (ss-1)->ply + 1;
> 
>     // Used to send selDepth info to GUI
>     if (PvNode && Threads[threadID].maxPly < ss->ply)
>         Threads[threadID].maxPly = ss->ply;
> 
>     if (SpNode)
>     {
>         sp = ss->sp;
>         tte = NULL;
>         ttMove = excludedMove = MOVE_NONE;
>         threatMove = sp->threatMove;
>         goto split_point_start;
>     }
>     else if (Root)
>         bestValue = alpha;
> 
>     // Step 1. Initialize node and poll. Polling can abort search
>     ss->currentMove = ss->bestMove = threatMove = (ss+1)->excludedMove = MOVE_NONE;
>     (ss+1)->skipNullMove = false; (ss+1)->reduction = DEPTH_ZERO;
>     (ss+2)->killers[0] = (ss+2)->killers[1] = (ss+2)->mateKiller = MOVE_NONE;
> 
>     if (threadID == 0 && ++NodesSincePoll > NodesBetweenPolls)
>     {
>         NodesSincePoll = 0;
>         poll(pos);
>     }
> 
>     // Step 2. Check for aborted search and immediate draw
>     if ((   StopRequest
>          || Threads[threadID].cutoff_occurred()
>          || pos.is_draw()
>          || ss->ply > PLY_MAX) && !Root)
>         return VALUE_DRAW;
> 
>     // Step 3. Mate distance pruning
>     alpha = Max(value_mated_in(ss->ply), alpha);
>     beta = Min(value_mate_in(ss->ply+1), beta);
>     if (alpha >= beta)
>         return alpha;
> 
>     // Step 4. Transposition table lookup
>     // We don't want the score of a partial search to overwrite a previous full search
>     // TT value, so we use a different position key in case of an excluded move.
>     excludedMove = ss->excludedMove;
>     posKey = excludedMove ? pos.get_exclusion_key() : pos.get_key();
> 
>     tte = TT.probe(posKey);
>     ttMove = tte ? tte->move() : MOVE_NONE;
> 
>     // At PV nodes we check for exact scores, while at non-PV nodes we check for
>     // a fail high/low. Biggest advantage at probing at PV nodes is to have a
>     // smooth experience in analysis mode.
>     if (   !Root
>         && tte
>         && (PvNode ? tte->depth() >= depth && tte->type() == VALUE_TYPE_EXACT
>                    : ok_to_use_TT(tte, depth, beta, ss->ply)))
>     {
>         TT.refresh(tte);
>         ss->bestMove = ttMove; // Can be MOVE_NONE
>         return value_from_tt(tte->value(), ss->ply);
>     }
> 
>     // Step 5. Evaluate the position statically and update parent's gain statistics
>     if (inCheck)
>         ss->eval = ss->evalMargin = VALUE_NONE;
>     else if (tte)
>     {
>         assert(tte->static_value() != VALUE_NONE);
> 
>         ss->eval = tte->static_value();
>         ss->evalMargin = tte->static_value_margin();
>         refinedValue = refine_eval(tte, ss->eval, ss->ply);
>     }
>     else
>     {
>         refinedValue = ss->eval = evaluate(pos, ss->evalMargin);
>         TT.store(posKey, VALUE_NONE, VALUE_TYPE_NONE, DEPTH_NONE, MOVE_NONE, ss->eval, ss->evalMargin);
>     }
> 
>     // Save gain for the parent non-capture move
>     update_gains(pos, (ss-1)->currentMove, (ss-1)->eval, ss->eval);
> 
>     // Step 6. Razoring (is omitted in PV nodes)
>     if (   !PvNode
>         &&  depth < RazorDepth
>         && !inCheck
>         &&  refinedValue + razor_margin(depth) < beta
>         &&  ttMove == MOVE_NONE
>         &&  abs(beta) < VALUE_MATE_IN_PLY_MAX
>         && !pos.has_pawn_on_7th(pos.side_to_move()))
>     {
>         Value rbeta = beta - razor_margin(depth);
>         Value v = qsearch<NonPV>(pos, ss, rbeta-1, rbeta, DEPTH_ZERO);
>         if (v < rbeta)
>             // Logically we should return (v + razor_margin(depth)), but
>             // surprisingly this did slightly weaker in tests.
>             return v;
>     }
> 
>     // Step 7. Static null move pruning (is omitted in PV nodes)
>     // We're betting that the opponent doesn't have a move that will reduce
>     // the score by more than futility_margin(depth) if we do a null move.
>     if (   !PvNode
>         && !ss->skipNullMove
>         &&  depth < RazorDepth
>         && !inCheck
>         &&  refinedValue - futility_margin(depth, 0) >= beta
>         &&  abs(beta) < VALUE_MATE_IN_PLY_MAX
>         &&  pos.non_pawn_material(pos.side_to_move()))
>         return refinedValue - futility_margin(depth, 0);
> 
>     // Step 8. Null move search with verification search (is omitted in PV nodes)
>     if (   !PvNode
>         && !ss->skipNullMove
>         &&  depth > ONE_PLY
>         && !inCheck
>         &&  refinedValue >= beta
>         &&  abs(beta) < VALUE_MATE_IN_PLY_MAX
>         &&  pos.non_pawn_material(pos.side_to_move()))
>     {
>         ss->currentMove = MOVE_NULL;
> 
>         // Null move dynamic reduction based on depth
>         int R = 3 + (depth >= 5 * ONE_PLY ? depth / 8 : 0);
> 
>         // Null move dynamic reduction based on value
>         if (refinedValue - PawnValueMidgame > beta)
>             R++;
> 
>         pos.do_null_move(st);
>         (ss+1)->skipNullMove = true;
>         nullValue = -search<NonPV>(pos, ss+1, -beta, -alpha, depth-R*ONE_PLY);
>         (ss+1)->skipNullMove = false;
>         pos.undo_null_move();
> 
>         if (nullValue >= beta)
>         {
>             // Do not return unproven mate scores
>             if (nullValue >= VALUE_MATE_IN_PLY_MAX)
>                 nullValue = beta;
> 
>             if (depth < 6 * ONE_PLY)
>                 return nullValue;
> 
>             // Do verification search at high depths
>             ss->skipNullMove = true;
>             Value v = search<NonPV>(pos, ss, alpha, beta, depth-R*ONE_PLY);
>             ss->skipNullMove = false;
> 
>             if (v >= beta)
>                 return nullValue;
>         }
>         else
>         {
>             // The null move failed low, which means that we may be faced with
>             // some kind of threat. If the previous move was reduced, check if
>             // the move that refuted the null move was somehow connected to the
>             // move which was reduced. If a connection is found, return a fail
>             // low score (which will cause the reduced move to fail high in the
>             // parent node, which will trigger a re-search with full depth).
>             threatMove = (ss+1)->bestMove;
> 
>             if (   depth < ThreatDepth
>                 && (ss-1)->reduction
>                 && threatMove != MOVE_NONE
>                 && connected_moves(pos, (ss-1)->currentMove, threatMove))
>                 return beta - 1;
>         }
>     }
> 
>     // Step 9. Internal iterative deepening
>     if (   depth >= IIDDepth[PvNode]
>         && ttMove == MOVE_NONE
>         && (PvNode || (!inCheck && ss->eval + IIDMargin >= beta)))
>     {
>         Depth d = (PvNode ? depth - 2 * ONE_PLY : depth / 2);
> 
>         ss->skipNullMove = true;
>         search<PvNode>(pos, ss, alpha, beta, d);
>         ss->skipNullMove = false;
> 
>         ttMove = ss->bestMove;
>         tte = TT.probe(posKey);
>     }
1158,2610c880,2083
< 		// Initialize a MovePicker object for the current position
< 		MovePickerExt<SpNode> mp(pos, ttMove, depth, H, ss, PvNode ? -VALUE_INFINITE : beta);
< #if !defined(NANOHA)
< 		CheckInfo ci(pos);
< #endif
< 		ss->bestMove = MOVE_NONE;
< 		futilityBase = ss->eval + ss->evalMargin;
< 		singularExtensionNode =   !RootNode
< 		                       && !SpNode
< 		                       && depth >= SingularExtensionDepth[PvNode]
< 		                       && ttMove != MOVE_NONE
< #if defined(NANOHA)
< 		                       && excludedMove==MOVE_NONE // Do not allow recursive singular extension search
< #else
< 		                       && !excludedMove // Do not allow recursive singular extension search
< #endif
< 		                       && (tte->type() & VALUE_TYPE_LOWER)
< 		                       && tte->depth() >= depth - 3 * ONE_PLY;
< 		if (SpNode)
< 		{
< 			lock_grab(&(sp->lock));
< 			bestValue = sp->bestValue;
< 		}
< 
< 		// Step 11. Loop through moves
< 		// Loop through all pseudo-legal moves until no moves remain or a beta cutoff occurs
< 		while (   bestValue < beta
< 		       && (move = mp.get_next_move()) != MOVE_NONE
< 		       && !thread.cutoff_occurred())
< 		{
< 			assert(is_ok(move));
< 
< 			if (move == excludedMove)
< 				continue;
< 
< 			// At root obey the "searchmoves" option and skip moves not listed in Root Move List.
< 			// Also in MultiPV mode we skip moves which already have got an exact score
< 			// in previous MultiPV Iteration. Finally any illegal move is skipped here.
< 			if (RootNode && !Rml.find(move, MultiPVIteration))
< 				continue;
< 
< 			// At PV and SpNode nodes we want all moves to be legal since the beginning
< #if defined(NANOHA)
< 			if ((PvNode || SpNode) && !pos.pl_move_is_legal(move))
< #else
< 			if ((PvNode || SpNode) && !pos.pl_move_is_legal(move, ci.pinned))
< #endif
< 				continue;
< 
< 			if (SpNode)
< 			{
< 				moveCount = ++sp->moveCount;
< 				lock_release(&(sp->lock));
< 			}
< 			else
< 				moveCount++;
< 
< 			if (RootNode)
< 			{
< 				// This is used by time management
< 				FirstRootMove = (moveCount == 1);
< 
< 				// Save the current node count before the move is searched
< 				nodes = pos.nodes_searched();
< 
< 				// For long searches send current move info to GUI
< 				if (pos.thread() == 0 && current_search_time() > 2000)
< #if defined(NANOHA)
< 				{}
< #else 
< 					cout << "info" << depth_to_uci(depth)
< 					     << " currmove " << move
< 					     << " currmovenumber " << moveCount + MultiPVIteration << endl;
< #endif
< 			}
< 
< 			// At Root and at first iteration do a PV search on all the moves to score root moves
< 			isPvMove = (PvNode && moveCount <= (RootNode && depth <= ONE_PLY ? MAX_MOVES : 1));
< #if defined(NANOHA)
< 			givesCheck = pos.move_gives_check(move);
< #else
< 			givesCheck = pos.move_gives_check(move, ci);
< #endif
< 			captureOrPromotion = pos.is_capture_or_promotion(move);
< 
< 			// Step 12. Decide the new search depth
< 			ext = extension<PvNode>(pos, move, captureOrPromotion, givesCheck, &dangerous);
< 
< 			// Singular extension search. If all moves but one fail low on a search of
< 			// (alpha-s, beta-s), and just one fails high on (alpha, beta), then that move
< 			// is singular and should be extended. To verify this we do a reduced search
< 			// on all the other moves but the ttMove, if result is lower than ttValue minus
< 			// a margin then we extend ttMove.
< 			if (   singularExtensionNode
< 			    && move == ttMove
< #if defined(NANOHA)
< 			    && pos.pl_move_is_legal(move)
< #else
< 			    && pos.pl_move_is_legal(move, ci.pinned)
< #endif
< 			    && ext < ONE_PLY)
< 			{
< 				Value ttValue = value_from_tt(tte->value(), ss->ply);
< 
< 				if (abs(ttValue) < VALUE_KNOWN_WIN)
< 				{
< 					Value rBeta = ttValue - int(depth);
< 					ss->excludedMove = move;
< 					ss->skipNullMove = true;
< 					Value v = search<NonPV>(pos, ss, rBeta - 1, rBeta, depth / 2);
< 					ss->skipNullMove = false;
< 					ss->excludedMove = MOVE_NONE;
< 					ss->bestMove = MOVE_NONE;
< 					if (v < rBeta)
< 						ext = ONE_PLY;
< 				}
< 			}
< 
< 			// Update current move (this must be done after singular extension search)
< 			newDepth = depth - ONE_PLY + ext;
< 
< 			// Step 13. Futility pruning (is omitted in PV nodes)
< 			if (   !PvNode
< 			    && !captureOrPromotion
< 			    && !inCheck
< 			    && !dangerous
< 			    &&  move != ttMove
< 			    && !is_castle(move))
< 			{
< 				// Move count based pruning
< 				if (   moveCount >= futility_move_count(depth)
< #if defined(NANOHA)
< 				    && (threatMove==MOVE_NONE || !connected_threat(pos, move, threatMove))
< #else
< 				    && (!threatMove || !connected_threat(pos, move, threatMove))
< #endif
< 				    && bestValue > VALUE_MATED_IN_PLY_MAX) // FIXME bestValue is racy
< 				{
< 					if (SpNode)
< 						lock_grab(&(sp->lock));
< 
< 					continue;
< 				}
< 
< 				// Value based pruning
< 				// We illogically ignore reduction condition depth >= 3*ONE_PLY for predicted depth,
< 				// but fixing this made program slightly weaker.
< 				Depth predictedDepth = newDepth - reduction<PvNode>(depth, moveCount);
< #if defined(NANOHA)
< 				{
< 				Piece piece = is_promotion(move) ? Piece(move_piece(move) | PROMOTED) : move_piece(move);
< 				futilityValue =  futilityBase + futility_margin(predictedDepth, moveCount)
< 				               + H.gain(piece, move_to(move));
< 				}
< #else
< 				futilityValue =  futilityBase + futility_margin(predictedDepth, moveCount)
< 				               + H.gain(pos.piece_on(move_from(move)), move_to(move));
< #endif
< 
< 				if (futilityValue < beta)
< 				{
< 					if (SpNode)
< 					{
< 						lock_grab(&(sp->lock));
< 						if (futilityValue > sp->bestValue)
< 							sp->bestValue = bestValue = futilityValue;
< 					}
< 					else if (futilityValue > bestValue)
< 						bestValue = futilityValue;
< 
< 					continue;
< 				}
< 
< 				// Prune moves with negative SEE at low depths
< 				if (   predictedDepth < 2 * ONE_PLY
< 				    && bestValue > VALUE_MATED_IN_PLY_MAX
< 				    && pos.see_sign(move) < 0)
< 				{
< 					if (SpNode)
< 						lock_grab(&(sp->lock));
< 
< 					continue;
< 				}
< 			}
< 
< 			// Check for legality only before to do the move
< #if defined(NANOHA)
< 			if (!pos.pl_move_is_legal(move))
< #else
< 			if (!pos.pl_move_is_legal(move, ci.pinned))
< #endif
< 			{
< 				moveCount--;
< 				continue;
< 			}
< 
< 			ss->currentMove = move;
< 			if (!SpNode && !captureOrPromotion)
< 				movesSearched[playedMoveCount++] = move;
< 
< 			// Step 14. Make the move
< #if defined(NANOHA)
< 			pos.do_move(move, st);
< #else
< 			pos.do_move(move, st, ci, givesCheck);
< #endif
< 
< 			// Step extra. pv search (only in PV nodes)
< 			// The first move in list is the expected PV
< 			if (isPvMove)
< 				value = newDepth < ONE_PLY ? -qsearch<PV>(pos, ss+1, -beta, -alpha, DEPTH_ZERO)
< 				                           : - search<PV>(pos, ss+1, -beta, -alpha, newDepth);
< 			else
< 			{
< 				// Step 15. Reduced depth search
< 				// If the move fails high will be re-searched at full depth.
< 				bool doFullDepthSearch = true;
< 
< 				if (    depth > 3 * ONE_PLY
< 				    && !captureOrPromotion
< 				    && !dangerous
< 				    && !is_castle(move)
< 				    &&  ss->killers[0] != move
< 				    &&  ss->killers[1] != move
< 				    && (ss->reduction = reduction<PvNode>(depth, moveCount)) != DEPTH_ZERO)
< 				{
< 					Depth d = newDepth - ss->reduction;
< 					alpha = SpNode ? sp->alpha : alpha;
< 
< 					value = d < ONE_PLY ? -qsearch<NonPV>(pos, ss+1, -(alpha+1), -alpha, DEPTH_ZERO)
< 					                    : - search<NonPV>(pos, ss+1, -(alpha+1), -alpha, d);
< 
< 					ss->reduction = DEPTH_ZERO;
< 					doFullDepthSearch = (value > alpha);
< 				}
< 
< 				// Step 16. Full depth search
< 				if (doFullDepthSearch)
< 				{
< 					alpha = SpNode ? sp->alpha : alpha;
< 					value = newDepth < ONE_PLY ? -qsearch<NonPV>(pos, ss+1, -(alpha+1), -alpha, DEPTH_ZERO)
< 					                           : - search<NonPV>(pos, ss+1, -(alpha+1), -alpha, newDepth);
< 
< 					// Step extra. pv search (only in PV nodes)
< 					// Search only for possible new PV nodes, if instead value >= beta then
< 					// parent node fails low with value <= alpha and tries another move.
< 					if (PvNode && value > alpha && (RootNode || value < beta))
< 						value = newDepth < ONE_PLY ? -qsearch<PV>(pos, ss+1, -beta, -alpha, DEPTH_ZERO)
< 						                           : - search<PV>(pos, ss+1, -beta, -alpha, newDepth);
< 				}
< 			}
< 
< 			// Step 17. Undo move
< 			pos.undo_move(move);
< 
< 			assert(value > -VALUE_INFINITE && value < VALUE_INFINITE);
< 
< 			// Step 18. Check for new best move
< 			if (SpNode)
< 			{
< 				lock_grab(&(sp->lock));
< 				bestValue = sp->bestValue;
< 				alpha = sp->alpha;
< 			}
< 
< 			// Finished searching the move. If StopRequest is true, the search
< 			// was aborted because the user interrupted the search or because we
< 			// ran out of time. In this case, the return value of the search cannot
< 			// be trusted, and we don't update the best move and/or PV.
< 			if (RootNode && !StopRequest)
< 			{
< 				// Remember searched nodes counts for this move
< 				RootMove* rm = Rml.find(move);
< 				rm->nodes += pos.nodes_searched() - nodes;
< 
< 				// PV move or new best move ?
< 				if (isPvMove || value > alpha)
< 				{
< 					// Update PV
< 					rm->score = value;
< 					rm->extract_pv_from_tt(pos);
< 
< 					// We record how often the best move has been changed in each
< 					// iteration. This information is used for time management: When
< 					// the best move changes frequently, we allocate some more time.
< 					if (!isPvMove && MultiPV == 1)
< 						Rml.bestMoveChanges++;
< 				}
< 				else
< 					// All other moves but the PV are set to the lowest value, this
< 					// is not a problem when sorting becuase sort is stable and move
< 					// position in the list is preserved, just the PV is pushed up.
< 					rm->score = -VALUE_INFINITE;
< 
< 			} // RootNode
< 
< 			if (value > bestValue)
< 			{
< 				bestValue = value;
< 				ss->bestMove = move;
< 
< 				if (   PvNode
< 				    && value > alpha
< 				    && value < beta) // We want always alpha < beta
< 					alpha = value;
< 
< 				if (SpNode && !thread.cutoff_occurred())
< 				{
< 					sp->bestValue = value;
< 					sp->ss->bestMove = move;
< 					sp->alpha = alpha;
< 					sp->is_betaCutoff = (value >= beta);
< 				}
< 			}
< 
< 			// Step 19. Check for split
< 			if (   !SpNode
< 			    && depth >= Threads.min_split_depth()
< 			    && bestValue < beta
< 			    && Threads.available_slave_exists(pos.thread())
< 			    && !StopRequest
< 			    && !thread.cutoff_occurred())
< 				bestValue = Threads.split<FakeSplit>(pos, ss, alpha, beta, bestValue, depth,
< 				                                     threatMove, moveCount, &mp, NT);
< 		}
< 
< 		// Step 20. Check for mate and stalemate
< 		// All legal moves have been searched and if there are
< 		// no legal moves, it must be mate or stalemate.
< 		// If one move was excluded return fail low score.
< 		if (!SpNode && !moveCount)
< #if defined(NANOHA)
< 			return excludedMove!=MOVE_NONE ? oldAlpha : (inCheck ? (move_is_pawn_drop((ss-1)->currentMove) ? value_mate_in(ss->ply) : value_mated_in(ss->ply) ): VALUE_DRAW);
< #else
< 			return excludedMove ? oldAlpha : inCheck ? value_mated_in(ss->ply) : VALUE_DRAW;
< #endif
< 
< 		// Step 21. Update tables
< 		// If the search is not aborted, update the transposition table,
< 		// history counters, and killer moves.
< 		if (!SpNode && !StopRequest && !thread.cutoff_occurred())
< 		{
< 			move = bestValue <= oldAlpha ? MOVE_NONE : ss->bestMove;
< 			vt   = bestValue <= oldAlpha ? VALUE_TYPE_UPPER
< 			     : bestValue >= beta ? VALUE_TYPE_LOWER : VALUE_TYPE_EXACT;
< 
< #if defined(NANOHA)
< 			TT.store(posKey, pos.handValue_of_side(), value_to_tt(bestValue, ss->ply), vt, depth, move, ss->eval, ss->evalMargin);
< #else
< 			TT.store(posKey, value_to_tt(bestValue, ss->ply), vt, depth, move, ss->eval, ss->evalMargin);
< #endif
< 
< 			// Update killers and history only for non capture moves that fails high
< 			if (    bestValue >= beta
< #if defined(NANOHA)
< 			    && !pos.is_capture(move)
< #else
< 			    && !pos.is_capture_or_promotion(move)
< #endif
< 			    )
< 			{
< 				if (move != ss->killers[0])
< 				{
< 					ss->killers[1] = ss->killers[0];
< 					ss->killers[0] = move;
< 				}
< 				update_history(pos, move, depth, movesSearched, playedMoveCount);
< 			}
< 		}
< 
< 		if (SpNode)
< 		{
< 			// Here we have the lock still grabbed
< 			sp->is_slave[pos.thread()] = false;
< 			sp->nodes += pos.nodes_searched();
< 			lock_release(&(sp->lock));
< 		}
< 
< 		assert(bestValue > -VALUE_INFINITE && bestValue < VALUE_INFINITE);
< 
< 		return bestValue;
< 	}
< 
< 	// qsearch() is the quiescence search function, which is called by the main
< 	// search function when the remaining depth is zero (or, to be more precise,
< 	// less than ONE_PLY).
< 
< 	template <NodeType NT>
< 	Value qsearch(Position& pos, SearchStack* ss, Value alpha, Value beta, Depth depth) {
< 
< 		const bool PvNode = (NT == PV);
< 
< 		assert(NT == PV || NT == NonPV);
< 		assert(alpha >= -VALUE_INFINITE && alpha <= VALUE_INFINITE);
< 		assert(beta >= -VALUE_INFINITE && beta <= VALUE_INFINITE);
< 		assert(PvNode || alpha == beta - 1);
< 		assert(depth <= 0);
< 		assert(pos.thread() >= 0 && pos.thread() < Threads.size());
< 
< 		StateInfo st;
< 		Move ttMove, move;
< 		Value bestValue, value, evalMargin, futilityValue, futilityBase;
< #if defined(NANOHA)
< 		bool inCheck, givesCheck, evasionPrunable;
< 		MYASSERT(ss);
< #else
< 		bool inCheck, enoughMaterial, givesCheck, evasionPrunable;
< #endif
< 		const TTEntry* tte;
< 		Depth ttDepth;
< 		ValueType vt;
< 		Value oldAlpha = alpha;
< 
< 		ss->bestMove = ss->currentMove = MOVE_NONE;
< 		ss->ply = (ss-1)->ply + 1;
< 
< #if defined(NANOHA)
< 		// 手番のときに王手をかけている状態は本来ありえない(前の手で王手回避していないか、自殺手を指していることになる)
< 		if(pos.at_checking()){
< 			return value_mate_in(0);
< 		}
< 		// 即詰めチェック？.
< 		{
< 			uint32_t info;
< 			Move m;
< 			int val = (pos.side_to_move() == BLACK)
< 			   ? pos.Mate1ply<BLACK>(m, info)
< 			   : pos.Mate1ply<WHITE>(m, info);
< 
< 			if (val == VALUE_MATE) {
< 				return value_mate_in(ss->ply);
< 			}
< 		}
< #endif
< 
< 		// Check for an instant draw or maximum ply reached
< #if defined(NANOHA)
< 		int repeat_check=0;
< 		if (StopRequest || ss->ply > PLY_MAX || pos.is_draw(repeat_check))
< 			return value_draw(pos);
< 		if(repeat_check<0) 
< 			return value_mated_in(ss->ply+1);
< 		else if(repeat_check>0) 
< 			return value_mate_in(ss->ply);
< #else
< 		if (pos.is_draw<true>() || ss->ply > PLY_MAX)
< 			return VALUE_DRAW;
< #endif
< 
< 		// Decide whether or not to include checks, this fixes also the type of
< 		// TT entry depth that we are going to use. Note that in qsearch we use
< 		// only two types of depth in TT: DEPTH_QS_CHECKS or DEPTH_QS_NO_CHECKS.
< 		inCheck = pos.in_check();
< 		ttDepth = (inCheck || depth >= DEPTH_QS_CHECKS ? DEPTH_QS_CHECKS : DEPTH_QS_NO_CHECKS);
< 
< 		// Transposition table lookup. At PV nodes, we don't use the TT for
< 		// pruning, but only for move ordering.
< #if defined(NANOHA)
< 		tte = TT.probe(pos.get_key(), pos.handValue_of_side());
< #else
< 		tte = TT.probe(pos.get_key());
< #endif
< 		ttMove = (tte ? tte->move() : MOVE_NONE);
< 
< 		if (!PvNode && tte && can_return_tt(tte, ttDepth, beta, ss->ply))
< 		{
< 			ss->bestMove = ttMove; // Can be MOVE_NONE
< 			return value_from_tt(tte->value(), ss->ply);
< 		}
< 
< 		// Evaluate the position statically
< 		if (inCheck)
< 		{
< 			bestValue = futilityBase = -VALUE_INFINITE;
< 			ss->eval = evalMargin = VALUE_NONE;
< #if !defined(NANOHA)
< 			enoughMaterial = false;
< #endif
< 		}
< 		else
< 		{
< 			if (tte)
< 			{
< 				assert(tte->static_value() != VALUE_NONE);
< 
< 				evalMargin = tte->static_value_margin();
< 				ss->eval = bestValue = tte->static_value();
< 			}
< 			else
< 				ss->eval = bestValue = evaluate(pos, evalMargin);
< 
< 			// Stand pat. Return immediately if static value is at least beta
< 			if (bestValue >= beta)
< 			{
< 				if (!tte)
< #if defined(NANOHA)
< 					TT.store(pos.get_key(), pos.handValue_of_side(), value_to_tt(bestValue, ss->ply), VALUE_TYPE_LOWER, DEPTH_NONE, MOVE_NONE, ss->eval, evalMargin);
< #else
< 					TT.store(pos.get_key(), value_to_tt(bestValue, ss->ply), VALUE_TYPE_LOWER, DEPTH_NONE, MOVE_NONE, ss->eval, evalMargin);
< #endif
< 
< 				return bestValue;
< 			}
< 
< 			if (PvNode && bestValue > alpha)
< 				alpha = bestValue;
< 
< 			// Futility pruning parameters, not needed when in check
< 			futilityBase = ss->eval + evalMargin + FutilityMarginQS;
< #if !defined(NANOHA)
< 			enoughMaterial = pos.non_pawn_material(pos.side_to_move()) > RookValueMidgame;
< #endif
< 		}
< 
< 		// Initialize a MovePicker object for the current position, and prepare
< 		// to search the moves. Because the depth is <= 0 here, only captures,
< 		// queen promotions and checks (only if depth >= DEPTH_QS_CHECKS) will
< 		// be generated.
< 		MovePicker mp(pos, ttMove, depth, H, move_to((ss-1)->currentMove));
< #if !defined(NANOHA)
< 		CheckInfo ci(pos);
< #endif
< 
< 		// Loop through the moves until no moves remain or a beta cutoff occurs
< 		while (   bestValue < beta
< 		       && (move = mp.get_next_move()) != MOVE_NONE)
< 		{
< 			assert(is_ok(move));
< 
< #if defined(NANOHA)
< 			givesCheck = pos.move_gives_check(move);
< #else
< 			givesCheck = pos.move_gives_check(move, ci);
< #endif
< 
< 			// Futility pruning
< 			if (   !PvNode
< 			    && !inCheck
< 			    && !givesCheck
< 			    &&  move != ttMove
< #if defined(NANOHA)
< 			   )
< #else
< 			    &&  enoughMaterial
< 			    && !is_promotion(move)
< 			    && !pos.is_passed_pawn_push(move))
< #endif
< 			{
< #if defined(NANOHA)
< 				futilityValue =  futilityBase
< 				               + piece_value_endgame(pos.piece_on(move_to(move)))
< 				               + (is_promotion(move) ? pos.promote_value_of_piece_on(move_from(move)) : VALUE_ZERO);
< #else
< 				futilityValue =  futilityBase
< 				               + piece_value_endgame(pos.piece_on(move_to(move)))
< 				               + (is_enpassant(move) ? PawnValueEndgame : VALUE_ZERO);
< #endif
< 
< 				if (futilityValue < beta)
< 				{
< 					if (futilityValue > bestValue)
< 						bestValue = futilityValue;
< 
< 					continue;
< 				}
< 
< 				// Prune moves with negative or equal SEE
< 				if (   futilityBase < beta
< 				    && depth < DEPTH_ZERO
< 				    && pos.see(move) <= 0)
< 					continue;
< 			}
< 
< 			// Detect non-capture evasions that are candidate to be pruned
< 			evasionPrunable =   !PvNode
< 			                 && inCheck
< 			                 && bestValue > VALUE_MATED_IN_PLY_MAX
< 			                 && !pos.is_capture(move)
< #if !defined(NANOHA)
< 			                 && !pos.can_castle(pos.side_to_move());
< #else
< 			                    ;
< #endif
< 
< 			// Don't search moves with negative SEE values
< 			if (   !PvNode
< 			    && (!inCheck || evasionPrunable)
< 			    &&  move != ttMove
< #if !defined(NANOHA)
< 			    && !is_promotion(move)
< #endif
< 			    &&  pos.see_sign(move) < 0)
< 				continue;
< 
< 			// Don't search useless checks
< 			if (   !PvNode
< 			    && !inCheck
< 			    &&  givesCheck
< 			    &&  move != ttMove
< 			    && !pos.is_capture_or_promotion(move)
< 			    &&  ss->eval + PawnValueMidgame / 4 < beta
< 			    && !check_is_dangerous(pos, move, futilityBase, beta, &bestValue))
< 			{
< 				if (ss->eval + PawnValueMidgame / 4 > bestValue)
< 					bestValue = ss->eval + PawnValueMidgame / 4;
< 
< 				continue;
< 			}
< 
< 			// Check for legality only before to do the move
< #if defined(NANOHA)
< 			if (!pos.pl_move_is_legal(move))
< #else
< 			if (!pos.pl_move_is_legal(move, ci.pinned))
< #endif
< 				continue;
< 
< 			// Update current move
< 			ss->currentMove = move;
< 
< 			// Make and search the move
< #if defined(NANOHA)
< 			pos.do_move(move, st);
< #else
< 			pos.do_move(move, st, ci, givesCheck);
< #endif
< 			value = -qsearch<NT>(pos, ss+1, -beta, -alpha, depth-ONE_PLY);
< 			pos.undo_move(move);
< 
< 			assert(value > -VALUE_INFINITE && value < VALUE_INFINITE);
< 
< 			// New best move?
< 			if (value > bestValue)
< 			{
< 				bestValue = value;
< 				ss->bestMove = move;
< 
< 				if (   PvNode
< 				    && value > alpha
< 				    && value < beta) // We want always alpha < beta
< 					alpha = value;
< 			}
< 		}
< 
< #if defined(NANOHA_CHECKMATE3_QUIESCE)
< 		// 3手詰めコール.
< 		if (bestValue < beta && depth >= DEPTH_QS_CHECKS)
< 		{
< 			int val = pos.Mate3(pos.side_to_move(), ss->bestMove);
< 			if (val == VALUE_MATE) {
< 				return value_mate_in(ss->ply+2);
< 			}
< 		}
< #endif
< 		// All legal moves have been searched. A special case: If we're in check
< 		// and no legal moves were found, it is checkmate.
< 		if (inCheck && bestValue == -VALUE_INFINITE)
< #if defined(NANOHA)
< 			return (move_is_pawn_drop((ss-1)->currentMove) ? value_mate_in(ss->ply) : value_mated_in(ss->ply));
< #else
< 			return value_mated_in(ss->ply);
< #endif
< 
< 		// Update transposition table
< 		move = bestValue <= oldAlpha ? MOVE_NONE : ss->bestMove;
< 		vt   = bestValue <= oldAlpha ? VALUE_TYPE_UPPER
< 		     : bestValue >= beta ? VALUE_TYPE_LOWER : VALUE_TYPE_EXACT;
< 
< #if defined(NANOHA)
< 		TT.store(pos.get_key(), pos.handValue_of_side(), value_to_tt(bestValue, ss->ply), vt, ttDepth, move, ss->eval, evalMargin);
< #else
< 		TT.store(pos.get_key(), value_to_tt(bestValue, ss->ply), vt, ttDepth, move, ss->eval, evalMargin);
< #endif
< 
< 		assert(bestValue > -VALUE_INFINITE && bestValue < VALUE_INFINITE);
< 
< 		return bestValue;
< 	}
< 
< 
< 	// check_is_dangerous() tests if a checking move can be pruned in qsearch().
< 	// bestValue is updated only when returning false because in that case move
< 	// will be pruned.
< 
< 	bool check_is_dangerous(Position &pos, Move move, Value futilityBase, Value beta, Value *bestValue)
< 	{
< #if defined(NANOHA)
< 		// TODO:将棋に合わせた危険度の高い状態を検討…
< 		return false;
< #else
< 		Bitboard b, occ, oldAtt, newAtt, kingAtt;
< 		Square from, to, ksq, victimSq;
< 		Piece pc;
< 		Color them;
< 		Value futilityValue, bv = *bestValue;
< 
< 		from = move_from(move);
< 		to = move_to(move);
< 		them = flip(pos.side_to_move());
< 		ksq = pos.king_square(them);
< 		kingAtt = pos.attacks_from<KING>(ksq);
< 		pc = pos.piece_on(from);
< 
< 		occ = pos.occupied_squares() & ~(1ULL << from) & ~(1ULL << ksq);
< 		oldAtt = pos.attacks_from(pc, from, occ);
< 		newAtt = pos.attacks_from(pc,   to, occ);
< 
< 		// Rule 1. Checks which give opponent's king at most one escape square are dangerous
< 		b = kingAtt & ~pos.pieces(them) & ~newAtt & ~(1ULL << to);
< 
< 		if (!(b && (b & (b - 1))))
< 			return true;
< 
< 		// Rule 2. Queen contact check is very dangerous
< 		if (   type_of(pc) == QUEEN
< 		    && bit_is_set(kingAtt, to))
< 			return true;
< 
< 		// Rule 3. Creating new double threats with checks
< 		b = pos.pieces(them) & newAtt & ~oldAtt & ~(1ULL << ksq);
< 
< 		while (b)
< 		{
< 			victimSq = pop_1st_bit(&b);
< 			futilityValue = futilityBase + piece_value_endgame(pos.piece_on(victimSq));
< 
< 			// Note that here we generate illegal "double move"!
< 			if (   futilityValue >= beta
< 			    && pos.see_sign(make_move(from, victimSq)) >= 0)
< 				return true;
< 
< 			if (futilityValue > bv)
< 				bv = futilityValue;
< 		}
< 
< 		// Update bestValue only if check is not dangerous (because we will prune the move)
< 		*bestValue = bv;
< 		return false;
< #endif
< 	}
< 
< 
< 	// connected_moves() tests whether two moves are 'connected' in the sense
< 	// that the first move somehow made the second move possible (for instance
< 	// if the moving piece is the same in both moves). The first move is assumed
< 	// to be the move that was made to reach the current position, while the
< 	// second move is assumed to be a move from the current position.
< 
< 	bool connected_moves(const Position& pos, Move m1, Move m2) {
< 
< 		Square f1, t1, f2, t2;
< 		Piece p1, p2;
< 		Square ksq;
< 
< 		assert(is_ok(m1));
< 		assert(is_ok(m2));
< 
< 		// Case 1: The moving piece is the same in both moves
< 		f2 = move_from(m2);
< 		t1 = move_to(m1);
< 		if (f2 == t1)
< 			return true;
< 
< 		// Case 2: The destination square for m2 was vacated by m1
< 		t2 = move_to(m2);
< 		f1 = move_from(m1);
< 		if (t2 == f1)
< 			return true;
< 
< 		// Case 3: Moving through the vacated square
< #if defined(NANOHA)
< 		// TODO:要検討...
< #else
< 		p2 = pos.piece_on(f2);
< 		if (   piece_is_slider(p2)
< 		    && bit_is_set(squares_between(f2, t2), f1))
< 			return true;
< #endif
< 
< 		// Case 4: The destination square for m2 is defended by the moving piece in m1
< #if defined(NANOHA)
< 		// TODO:要検討...
< #else
< 		p1 = pos.piece_on(t1);
< 		if (bit_is_set(pos.attacks_from(p1, t1), t2))
< 			return true;
< #endif
< 
< 		// Case 5: Discovered check, checking piece is the piece moved in m1
< #if defined(NANOHA)
< 		// TODO:要検討...
< #else
< 		ksq = pos.king_square(pos.side_to_move());
< 		if (    piece_is_slider(p1)
< 		    &&  bit_is_set(squares_between(t1, ksq), f2))
< 		{
< 			Bitboard occ = pos.occupied_squares();
< 			clear_bit(&occ, f2);
< 			if (bit_is_set(pos.attacks_from(p1, t1, occ), ksq))
< 				return true;
< 		}
< #endif
< 		return false;
< 	}
< 
< 
< 	// value_to_tt() adjusts a mate score from "plies to mate from the root" to
< 	// "plies to mate from the current ply".  Non-mate scores are unchanged.
< 	// The function is called before storing a value to the transposition table.
< 
< 	Value value_to_tt(Value v, int ply) {
< 
< 		if (v >= VALUE_MATE_IN_PLY_MAX)
< 			return v + ply;
< 
< 		if (v <= VALUE_MATED_IN_PLY_MAX)
< 			return v - ply;
< 
< 		return v;
< 	}
< 
< 
< 	// value_from_tt() is the inverse of value_to_tt(): It adjusts a mate score from
< 	// the transposition table to a mate score corrected for the current ply.
< 
< 	Value value_from_tt(Value v, int ply) {
< 
< 		if (v >= VALUE_MATE_IN_PLY_MAX)
< 			return v - ply;
< 
< 		if (v <= VALUE_MATED_IN_PLY_MAX)
< 			return v + ply;
< 
< 		return v;
< 	}
< 
< 
< 	// connected_threat() tests whether it is safe to forward prune a move or if
< 	// is somehow connected to the threat move returned by null search.
< 
< 	bool connected_threat(const Position& pos, Move m, Move threat) {
< 
< 		assert(is_ok(m));
< 		assert(is_ok(threat));
< 		assert(!pos.is_capture_or_promotion(m));
< #if !defined(NANOHA)
< 		assert(!pos.is_passed_pawn_push(m));
< #endif
< 
< 		Square mfrom, mto, tfrom, tto;
< #if defined(NANOHA)
< 		bool mdrop = move_is_drop(m);
< #endif
< 
< 		mfrom = move_from(m);
< 		mto = move_to(m);
< 		tfrom = move_from(threat);
< 		tto = move_to(threat);
< 
< 		// Case 1: Don't prune moves which move the threatened piece
< #if defined(NANOHA)
< 		if (mdrop == false && mfrom == tto)
< 			return true;
< #else
< 		if (mfrom == tto)
< 			return true;
< #endif
< 
< 		// Case 2: If the threatened piece has value less than or equal to the
< 		// value of the threatening piece, don't prune moves which defend it.
< 		if (   pos.is_capture(threat)
< #if defined(NANOHA)
< 		    && (   piece_value_midgame(move_piece(m)) >= piece_value_midgame(pos.piece_on(tto))
< 		        || type_of(move_piece(m)) == OU)
< #else
< 		    && (   piece_value_midgame(pos.piece_on(tfrom)) >= piece_value_midgame(pos.piece_on(tto))
< 		        || type_of(pos.piece_on(tfrom)) == KING)
< #endif
< 		    && pos.move_attacks_square(m, tto))
< 			return true;
< 
< 		// Case 3: If the moving piece in the threatened move is a slider, don't
< 		// prune safe moves which block its ray.
< #if defined(NANOHA)
< 		// TODO:要検討...
< #else
< 		if (   piece_is_slider(pos.piece_on(tfrom))
< 		    && bit_is_set(squares_between(tfrom, tto), mto)
< 		    && pos.see_sign(m) >= 0)
< 			return true;
< #endif
< 
< 		return false;
< 	}
< 
< 
< 	// can_return_tt() returns true if a transposition table score
< 	// can be used to cut-off at a given point in search.
< 
< 	bool can_return_tt(const TTEntry* tte, Depth depth, Value beta, int ply) {
< 
< 		Value v = value_from_tt(tte->value(), ply);
< 
< 		return   (   tte->depth() >= depth
< 		          || v >= Max(VALUE_MATE_IN_PLY_MAX, beta)
< 		          || v < Min(VALUE_MATED_IN_PLY_MAX, beta))
< 
< 		      && (   ((tte->type() & VALUE_TYPE_LOWER) && v >= beta)
< 		          || ((tte->type() & VALUE_TYPE_UPPER) && v < beta));
< 	}
< 
< 
< 	// refine_eval() returns the transposition table score if
< 	// possible otherwise falls back on static position evaluation.
< 
< 	Value refine_eval(const TTEntry* tte, Value defaultEval, int ply) {
< 
< 		assert(tte);
< 
< 		Value v = value_from_tt(tte->value(), ply);
< 
< 		if (   ((tte->type() & VALUE_TYPE_LOWER) && v >= defaultEval)
< 		    || ((tte->type() & VALUE_TYPE_UPPER) && v < defaultEval))
< 			return v;
< 
< 		return defaultEval;
< 	}
< 
< 
< 	// update_history() registers a good move that produced a beta-cutoff
< 	// in history and marks as failures all the other moves of that ply.
< 
< 	void update_history(const Position& pos, Move move, Depth depth,
< 	                    Move movesSearched[], int moveCount) {
< 		Move m;
< 		Value bonus = Value(int(depth) * int(depth));
< 
< #if defined(NANOHA)
< 		Piece piece = is_promotion(move) ? Piece(move_piece(move) | PROMOTED) : move_piece(move);
< 		H.update(piece, move_to(move), bonus);
< #else
< 		H.update(pos.piece_on(move_from(move)), move_to(move), bonus);
< #endif
< 
< 		for (int i = 0; i < moveCount - 1; i++)
< 		{
< 			m = movesSearched[i];
< 
< 			assert(m != move);
< 
< #if defined(NANOHA)
< 			piece = is_promotion(m) ? Piece(move_piece(m) | PROMOTED) : move_piece(m);
< 			H.update(piece, move_to(m), -bonus);
< #else
< 			H.update(pos.piece_on(move_from(m)), move_to(m), -bonus);
< #endif
< 		}
< 	}
< 
< 
< 	// update_gains() updates the gains table of a non-capture move given
< 	// the static position evaluation before and after the move.
< 
< 	void update_gains(const Position& pos, Move m, Value before, Value after) {
< 
< 		if (   m != MOVE_NULL
< 		    && before != VALUE_NONE
< 		    && after != VALUE_NONE
< 		    && pos.captured_piece_type() == PIECE_TYPE_NONE
< 		    && !is_special(m)) {
< #if defined(NANOHA)
< 				Piece piece = is_promotion(m) ? Piece(move_piece(m) | PROMOTED) : move_piece(m);
< 				H.update_gain(piece, move_to(m), -(before + after));
< #else
< 				H.update_gain(pos.piece_on(move_to(m)), move_to(m), -(before + after));
< #endif
< 			}
< 	}
< 
< 
< 	// current_search_time() returns the number of milliseconds which have passed
< 	// since the beginning of the current search.
< 
< 	int current_search_time(int set) {
< 
< 		static int searchStartTime;
< 
< 		if (set)
< 			searchStartTime = set;
< 
< 		return get_system_time() - searchStartTime;
< 	}
< 
< 
< 	// score_to_uci() converts a value to a string suitable for use with the UCI
< 	// protocol specifications:
< 	//
< 	// cp <x>     The score from the engine's point of view in centipawns.
< 	// mate <y>   Mate in y moves, not plies. If the engine is getting mated
< 	//            use negative values for y.
< 
< 	string score_to_uci(Value v, Value alpha, Value beta) {
< 
< 		std::stringstream s;
< 
< #if defined(NANOHA)
< 		if (abs(v) < VALUE_MATE - PLY_MAX * ONE_PLY)
< 			s << " score cp " << int(v);
< 		else
< 			s << " score mate " << (v > 0 ? VALUE_MATE - v + 1 : -VALUE_MATE - v) / 2;
< #else
< 		if (abs(v) < VALUE_MATE - PLY_MAX * ONE_PLY)
< 			s << " score cp " << int(v) * 100 / int(PawnValueMidgame); // Scale to centipawns
< 		else
< 			s << " score mate " << (v > 0 ? VALUE_MATE - v + 1 : -VALUE_MATE - v) / 2;
< #endif
< 
< 		s << (v >= beta ? " lowerbound" : v <= alpha ? " upperbound" : "");
< 
< 		return s.str();
< 	}
< 
< 
< 	// speed_to_uci() returns a string with time stats of current search suitable
< 	// to be sent to UCI gui.
< 
< 	string speed_to_uci(int64_t nodes) {
< 
< 		std::stringstream s;
< 		int t = current_search_time();
< 
< 		s << " nodes " << nodes
< 		  << " nps "   << (t > 0 ? int(nodes * 1000 / t) : 0)
< #if defined(NANOHA)
< 		  << " time "  << (t > 0 ? t : 1);
< #else
< 		  << " time "  << t;
< #endif
< 
< 		return s.str();
< 	}
< 
< 
< 	// pv_to_uci() returns a string with information on the current PV line
< 	// formatted according to UCI specification.
< 
< 	string pv_to_uci(const Move pv[], int pvNum, bool chess960) {
< 
< 		std::stringstream s;
< 
< #if defined(NANOHA)
< 		s << " pv ";
< #else
< 		s << " multipv " << pvNum << " pv " << set960(chess960);
< #endif
< 
< 		for ( ; *pv != MOVE_NONE; pv++)
< 			s << *pv << " ";
< 
< 		return s.str();
< 	}
< 
< 	// depth_to_uci() returns a string with information on the current depth and
< 	// seldepth formatted according to UCI specification.
< 
< 	string depth_to_uci(Depth depth) {
< 
< 		std::stringstream s;
< 
< 		// Retrieve max searched depth among threads
< 		int selDepth = 0;
< 		for (int i = 0; i < Threads.size(); i++)
< 			if (Threads[i].maxPly > selDepth)
< 				selDepth = Threads[i].maxPly;
< 
< 		s << " depth " << depth / ONE_PLY << " seldepth " << selDepth;
< 
< 		return s.str();
< 	}
< 
< 	string time_to_string(int millisecs) {
< 
< 		const int MSecMinute = 1000 * 60;
< 		const int MSecHour   = 1000 * 60 * 60;
< 
< 		int hours = millisecs / MSecHour;
< 		int minutes =  (millisecs % MSecHour) / MSecMinute;
< 		int seconds = ((millisecs % MSecHour) % MSecMinute) / 1000;
< 
< 		std::stringstream s;
< 
< 		if (hours)
< 			s << hours << ':';
< 
< 		s << std::setfill('0') << std::setw(2) << minutes << ':' << std::setw(2) << seconds;
< 		return s.str();
< 	}
< 
< 	string score_to_string(Value v) {
< 
< 		std::stringstream s;
< 
< 		if (v >= VALUE_MATE_IN_PLY_MAX)
< 			s << "#" << (VALUE_MATE - v + 1) / 2;
< 		else if (v <= VALUE_MATED_IN_PLY_MAX)
< 			s << "-#" << (VALUE_MATE + v) / 2;
< 		else
< 			s << std::setprecision(2) << std::fixed << std::showpos << float(v) / PawnValueMidgame;
< 
< 		return s.str();
< 	}
< 
< 	// pretty_pv() creates a human-readable string from a position and a PV.
< 	// It is used to write search information to the log file (which is created
< 	// when the UCI parameter "Use Search Log" is "true").
< 
< 	string pretty_pv(Position& pos, int depth, Value value, int time, Move pv[]) {
< 
< 		const int64_t K = 1000;
< 		const int64_t M = 1000000;
< 		const int startColumn = 28;
< 		const size_t maxLength = 80 - startColumn;
< 
< 		StateInfo state[PLY_MAX_PLUS_2], *st = state;
< 		Move* m = pv;
< 		string san;
< 		std::stringstream s;
< 		size_t length = 0;
< 
< 		// First print depth, score, time and searched nodes...
< #if defined(NANOHA)
< 		s
< #else
< 		s << set960(pos.is_chess960())
< #endif
< 		  << std::setw(2) << depth
< 		  << std::setw(8) << score_to_string(value)
< 		  << std::setw(8) << time_to_string(time);
< 
< 		if (pos.nodes_searched() < M)
< 			s << std::setw(8) << pos.nodes_searched() / 1 << "  ";
< 		else if (pos.nodes_searched() < K * M)
< 			s << std::setw(7) << pos.nodes_searched() / K << "K  ";
< 		else
< 			s << std::setw(7) << pos.nodes_searched() / M << "M  ";
< 
< 		// ...then print the full PV line in short algebraic notation
< 		while (*m != MOVE_NONE)
< 		{
< 			san = move_to_san(pos, *m);
< 			length += san.length() + 1;
< 
< 			if (length > maxLength)
< 			{
< 				length = san.length() + 1;
< 				s << "\n" + string(startColumn, ' ');
< 			}
< 			s << san << ' ';
< 
< 			pos.do_move(*m++, *st++);
< 		}
< 
< 		// Restore original position before to leave
< 		while (m != pv) pos.undo_move(*--m);
< 
< 		return s.str();
< 	}
< 
< 	// poll() performs two different functions: It polls for user input, and it
< 	// looks at the time consumed so far and decides if it's time to abort the
< 	// search.
< 
< 	void poll(const Position& pos) {
< 
< 		static int lastInfoTime;
< 		int t = current_search_time();
< 
< 		//  Poll for input
< 		if (input_available())
< 		{
< 			// We are line oriented, don't read single chars
< 			string command;
< 
< 			if (!std::getline(std::cin, command) || command == "quit")
< 			{
< 				// Quit the program as soon as possible
< 				Limits.ponder = false;
< 				QuitRequest = StopRequest = true;
< 				return;
< 			}
< #if defined(NANOHA)
< 			else if (command == "stop" || command.find("gameover")==0)
< #else
< 			else if (command == "stop")
< #endif
< 			{
< 				// Stop calculating as soon as possible, but still send the "bestmove"
< 				// and possibly the "ponder" token when finishing the search.
< 				Limits.ponder = false;
< 				StopRequest = true;
< 			}
< 			else if (command == "ponderhit")
< 			{
< 				// The opponent has played the expected move. GUI sends "ponderhit" if
< 				// we were told to ponder on the same move the opponent has played. We
< 				// should continue searching but switching from pondering to normal search.
< 				Limits.ponder = false;
< 
< 				if (StopOnPonderhit)
< 					StopRequest = true;
< 			}
< 		}
< 
< 		// Print search information
< 		if (t < 1000)
< 			lastInfoTime = 0;
< 
< 		else if (lastInfoTime > t)
< 			// HACK: Must be a new search where we searched less than
< 			// NodesBetweenPolls nodes during the first second of search.
< 			lastInfoTime = 0;
< 
< 		else if (t - lastInfoTime >= 1000)
< 		{
< 			lastInfoTime = t;
< 
< 			dbg_print_mean();
< 			dbg_print_hit_rate();
< 		}
< 
< 		// Should we stop the search?
< 		if (Limits.ponder)
< 			return;
< 
< 		bool stillAtFirstMove =    FirstRootMove
< 		                       && !AspirationFailLow
< 		                       &&  t > TimeMgr.available_time();
< 
< 		bool noMoreTime =   t > TimeMgr.maximum_time()
< 		                 || stillAtFirstMove;
< 
< #if defined(NANOHA)
< 		if (!Limits.maxDepth) {
< 			if ((   noMoreTime
< 			    && (!Limits.maxTime || t >= Limits.maxTime))
< 			    || (Limits.maxNodes && pos.nodes_searched() >= Limits.maxNodes))
< 				StopRequest = true;
< 		}
< #else
< 		if (   (Limits.useTimeManagement() && noMoreTime)
< 		    || (Limits.maxTime && t >= Limits.maxTime)
< 		    || (Limits.maxNodes && pos.nodes_searched() >= Limits.maxNodes)) // FIXME
< 			StopRequest = true;
< #endif
< 	}
< 
< 
< 	// wait_for_stop_or_ponderhit() is called when the maximum depth is reached
< 	// while the program is pondering. The point is to work around a wrinkle in
< 	// the UCI protocol: When pondering, the engine is not allowed to give a
< 	// "bestmove" before the GUI sends it a "stop" or "ponderhit" command.
< 	// We simply wait here until one of these commands is sent, and return,
< 	// after which the bestmove and pondermove will be printed.
< 
< 	void wait_for_stop_or_ponderhit() {
< 
< 		string command;
< 
< 		// Wait for a command from stdin
< 		while (   std::getline(std::cin, command)
< #if defined(NANOHA)
< 		       && command.find("gameover") != 0
< #endif
< 		       && command != "ponderhit" && command != "stop" && command != "quit") {};
< 
< #if defined(NANOHA)
< 		if (command != "ponderhit" && command != "stop" && command.find("gameover") != 0)
< #else
< 		if (command != "ponderhit" && command != "stop")
< #endif
< 			QuitRequest = true; // Must be "quit" or getline() returned false
< 	}
< 
< 
< 	// When playing with strength handicap choose best move among the MultiPV set
< 	// using a statistical rule dependent on SkillLevel. Idea by Heinz van Saanen.
< 	void do_skill_level(Move* best, Move* ponder) {
< 
< 		assert(MultiPV > 1);
< 
< 		static RKISS rk;
< 
< 		// Rml list is already sorted by score in descending order
< 		int s;
< 		int max_s = -VALUE_INFINITE;
< 		int size = Min(MultiPV, (int)Rml.size());
< 		int max = Rml[0].score;
< 		int var = Min(max - Rml[size - 1].score, PawnValueMidgame);
< 		int wk = 120 - 2 * SkillLevel;
< 
< 		// PRNG sequence should be non deterministic
< 		for (int i = abs(get_system_time() % 50); i > 0; i--)
< 			rk.rand<unsigned>();
< 
< 		// Choose best move. For each move's score we add two terms both dependent
< 		// on wk, one deterministic and bigger for weaker moves, and one random,
< 		// then we choose the move with the resulting highest score.
< 		for (int i = 0; i < size; i++)
< 		{
< 			s = Rml[i].score;
< 
< 			// Don't allow crazy blunders even at very low skills
< 			if (i > 0 && Rml[i-1].score > s + EasyMoveMargin)
< 				break;
< 
< 			// This is our magical formula
< 			s += ((max - s) * wk + var * (rk.rand<unsigned>() % wk)) / 128;
< 
< 			if (s > max_s)
< 			{
< 				max_s = s;
< 				*best = Rml[i].pv[0];
< 				*ponder = Rml[i].pv[1];
< 			}
< 		}
< 	}
< 
< 
< 	/// RootMove and RootMoveList method's definitions
< 
< 	void RootMoveList::init(Position& pos, Move searchMoves[]) {
< 
< 		Move* sm;
< 		bestMoveChanges = 0;
< 		clear();
< 
< 		// Generate all legal moves and add them to RootMoveList
< 		for (MoveList<MV_LEGAL> ml(pos); !ml.end(); ++ml)
< 		{
< 			// If we have a searchMoves[] list then verify the move
< 			// is in the list before to add it.
< #if defined(NANOHA)
< 			for (sm = searchMoves; *sm!=MOVE_NONE && *sm != ml.move(); sm++) {}
< #else
< 			for (sm = searchMoves; *sm && *sm != ml.move(); sm++) {}
< #endif
< 
< #if defined(NANOHA)
< 			if (sm != searchMoves && *sm != ml.move())
< 				continue;
< #else
< 			if (sm != searchMoves && *sm != ml.move())
< 				continue;
< #endif
< 
< 			RootMove rm;
< 			rm.pv.push_back(ml.move());
< 			rm.pv.push_back(MOVE_NONE);
< 			rm.score = rm.prevScore = -VALUE_INFINITE;
< 			rm.nodes = 0;
< 			push_back(rm);
< 		}
< 	}
< 
< 	RootMove* RootMoveList::find(const Move& m, int startIndex) {
< 
< 		for (size_t i = startIndex; i < size(); i++)
< 			if ((*this)[i].pv[0] == m)
< 				return &(*this)[i];
< 
< 		return NULL;
< 	}
< 
< 	// extract_pv_from_tt() builds a PV by adding moves from the transposition table.
< 	// We consider also failing high nodes and not only VALUE_TYPE_EXACT nodes. This
< 	// allow to always have a ponder move even when we fail high at root and also a
< 	// long PV to print that is important for position analysis.
< 
< 	void RootMove::extract_pv_from_tt(Position& pos) {
< 
< 		StateInfo state[PLY_MAX_PLUS_2], *st = state;
< 		TTEntry* tte;
< 		int ply = 1;
< 		Move m = pv[0];
< 
< 		assert(m != MOVE_NONE && pos.is_pseudo_legal(m));
< 
< 		pv.clear();
< 		pv.push_back(m);
< 		pos.do_move(m, *st++);
< 
< #if defined(NANOHA)
< 		int dummy = 0;
< 		while (   (tte = TT.probe(pos.get_key(), pos.handValue_of_side())) != NULL
< #else
< 		while (   (tte = TT.probe(pos.get_key())) != NULL
< #endif
< 		       && tte->move() != MOVE_NONE
< #if defined(NANOHA)
< 		       && pos.pl_move_is_legal(tte->move())
< #else
< 		       && pos.is_pseudo_legal(tte->move())
< 		       && pos.pl_move_is_legal(tte->move(), pos.pinned_pieces())
< #endif
< 		       && ply < PLY_MAX
< #if defined(NANOHA)
< 		       && (!pos.is_draw(dummy) || ply < 2))
< #else
< 		       && (!pos.is_draw<false>() || ply < 2))
< #endif
< 		{
< 			pv.push_back(tte->move());
< 			pos.do_move(tte->move(), *st++);
< 			ply++;
< 		}
< 		pv.push_back(MOVE_NONE);
< 
< 		do pos.undo_move(pv[--ply]); while (ply);
< 	}
< 
< 	// insert_pv_in_tt() is called at the end of a search iteration, and inserts
< 	// the PV back into the TT. This makes sure the old PV moves are searched
< 	// first, even if the old TT entries have been overwritten.
< 
< 	void RootMove::insert_pv_in_tt(Position& pos) {
< 
< 		StateInfo state[PLY_MAX_PLUS_2], *st = state;
< 		TTEntry* tte;
< 		Key k;
< 		Value v, m = VALUE_NONE;
< 		int ply = 0;
< 
< 		assert(pv[0] != MOVE_NONE && pos.move_is_legal(pv[0]));
< 
< 		do {
< 			k = pos.get_key();
< #if defined(NANOHA)
< 			tte = TT.probe(k, pos.handValue_of_side());
< #else
< 			tte = TT.probe(k);
< #endif
< 
< 			// Don't overwrite existing correct entries
< 			if (!tte || tte->move() != pv[ply])
< 			{
< 				v = (pos.in_check() ? VALUE_NONE : evaluate(pos, m));
< #if defined(NANOHA)
< 				TT.store(k, pos.handValue_of_side(), VALUE_NONE, VALUE_TYPE_NONE, DEPTH_NONE, pv[ply], v, m);
< #else
< 				TT.store(k, VALUE_NONE, VALUE_TYPE_NONE, DEPTH_NONE, pv[ply], v, m);
< #endif
< 			}
< 			pos.do_move(pv[ply], *st++);
---
>     // Initialize a MovePicker object for the current position
>     MovePickerExt<SpNode, Root> mp(pos, ttMove, depth, H, ss, (PvNode ? -VALUE_INFINITE : beta));
>     CheckInfo ci(pos);
>     ss->bestMove = MOVE_NONE;
>     futilityBase = ss->eval + ss->evalMargin;
>     singularExtensionNode =   !Root
>                            && !SpNode
>                            && depth >= SingularExtensionDepth[PvNode]
>                            && tte
>                            && tte->move()
>                            && !excludedMove // Do not allow recursive singular extension search
>                            && (tte->type() & VALUE_TYPE_LOWER)
>                            && tte->depth() >= depth - 3 * ONE_PLY;
>     if (SpNode)
>     {
>         lock_grab(&(sp->lock));
>         bestValue = sp->bestValue;
>     }
> 
>     // Step 10. Loop through moves
>     // Loop through all legal moves until no moves remain or a beta cutoff occurs
>     while (   bestValue < beta
>            && (move = mp.get_next_move()) != MOVE_NONE
>            && !Threads[threadID].cutoff_occurred())
>     {
>       assert(move_is_ok(move));
> 
>       if (SpNode)
>       {
>           moveCount = ++sp->moveCount;
>           lock_release(&(sp->lock));
>       }
>       else if (move == excludedMove)
>           continue;
>       else
>           moveCount++;
> 
>       if (Root)
>       {
>           // This is used by time management
>           FirstRootMove = (moveCount == 1);
> 
>           // Save the current node count before the move is searched
>           nodes = pos.nodes_searched();
> 
>           // If it's time to send nodes info, do it here where we have the
>           // correct accumulated node counts searched by each thread.
>           if (SendSearchedNodes)
>           {
>               SendSearchedNodes = false;
>               cout << "info" << speed_to_uci(pos.nodes_searched()) << endl;
>           }
> 
>           if (current_search_time() > 2000)
>               cout << "info currmove " << move
>                    << " currmovenumber " << moveCount << endl;
>       }
> 
>       // At Root and at first iteration do a PV search on all the moves to score root moves
>       isPvMove = (PvNode && moveCount <= (Root ? depth <= ONE_PLY ? 1000 : MultiPV : 1));
>       givesCheck = pos.move_gives_check(move, ci);
>       captureOrPromotion = pos.move_is_capture_or_promotion(move);
> 
>       // Step 11. Decide the new search depth
>       ext = extension<PvNode>(pos, move, captureOrPromotion, givesCheck, &dangerous);
> 
>       // Singular extension search. If all moves but one fail low on a search of
>       // (alpha-s, beta-s), and just one fails high on (alpha, beta), then that move
>       // is singular and should be extended. To verify this we do a reduced search
>       // on all the other moves but the ttMove, if result is lower than ttValue minus
>       // a margin then we extend ttMove.
>       if (   singularExtensionNode
>           && move == tte->move()
>           && ext < ONE_PLY)
>       {
>           Value ttValue = value_from_tt(tte->value(), ss->ply);
> 
>           if (abs(ttValue) < VALUE_KNOWN_WIN)
>           {
>               Value rBeta = ttValue - int(depth);
>               ss->excludedMove = move;
>               ss->skipNullMove = true;
>               Value v = search<NonPV>(pos, ss, rBeta - 1, rBeta, depth / 2);
>               ss->skipNullMove = false;
>               ss->excludedMove = MOVE_NONE;
>               ss->bestMove = MOVE_NONE;
>               if (v < rBeta)
>                   ext = ONE_PLY;
>           }
>       }
> 
>       // Update current move (this must be done after singular extension search)
>       ss->currentMove = move;
>       newDepth = depth - ONE_PLY + ext;
> 
>       // Step 12. Futility pruning (is omitted in PV nodes)
>       if (   !PvNode
>           && !captureOrPromotion
>           && !inCheck
>           && !dangerous
>           &&  move != ttMove
>           && !move_is_castle(move))
>       {
>           // Move count based pruning
>           if (   moveCount >= futility_move_count(depth)
>               && (!threatMove || !connected_threat(pos, move, threatMove))
>               && bestValue > VALUE_MATED_IN_PLY_MAX) // FIXME bestValue is racy
>           {
>               if (SpNode)
>                   lock_grab(&(sp->lock));
> 
>               continue;
>           }
> 
>           // Value based pruning
>           // We illogically ignore reduction condition depth >= 3*ONE_PLY for predicted depth,
>           // but fixing this made program slightly weaker.
>           Depth predictedDepth = newDepth - reduction<NonPV>(depth, moveCount);
>           futilityValueScaled =  futilityBase + futility_margin(predictedDepth, moveCount)
>                                + H.gain(pos.piece_on(move_from(move)), move_to(move));
> 
>           if (futilityValueScaled < beta)
>           {
>               if (SpNode)
>               {
>                   lock_grab(&(sp->lock));
>                   if (futilityValueScaled > sp->bestValue)
>                       sp->bestValue = bestValue = futilityValueScaled;
>               }
>               else if (futilityValueScaled > bestValue)
>                   bestValue = futilityValueScaled;
> 
>               continue;
>           }
> 
>           // Prune moves with negative SEE at low depths
>           if (   predictedDepth < 2 * ONE_PLY
>               && bestValue > VALUE_MATED_IN_PLY_MAX
>               && pos.see_sign(move) < 0)
>           {
>               if (SpNode)
>                   lock_grab(&(sp->lock));
> 
>               continue;
>           }
>       }
> 
>       // Bad capture detection. Will be used by prob-cut search
>       isBadCap =   depth >= 3 * ONE_PLY
>                 && depth < 8 * ONE_PLY
>                 && captureOrPromotion
>                 && move != ttMove
>                 && !dangerous
>                 && !move_is_promotion(move)
>                 &&  abs(alpha) < VALUE_MATE_IN_PLY_MAX
>                 &&  pos.see_sign(move) < 0;
> 
>       // Step 13. Make the move
>       pos.do_move(move, st, ci, givesCheck);
> 
>       if (!SpNode && !captureOrPromotion)
>           movesSearched[playedMoveCount++] = move;
> 
>       // Step extra. pv search (only in PV nodes)
>       // The first move in list is the expected PV
>       if (isPvMove)
>       {
>           // Aspiration window is disabled in multi-pv case
>           if (Root && MultiPV > 1)
>               alpha = -VALUE_INFINITE;
> 
>           value = -search<PV>(pos, ss+1, -beta, -alpha, newDepth);
>       }
>       else
>       {
>           // Step 14. Reduced depth search
>           // If the move fails high will be re-searched at full depth.
>           bool doFullDepthSearch = true;
>           alpha = SpNode ? sp->alpha : alpha;
> 
>           if (    depth >= 3 * ONE_PLY
>               && !captureOrPromotion
>               && !dangerous
>               && !move_is_castle(move)
>               &&  ss->killers[0] != move
>               &&  ss->killers[1] != move)
>           {
>               ss->reduction = reduction<PvNode>(depth, moveCount);
>               if (ss->reduction)
>               {
>                   Depth d = newDepth - ss->reduction;
>                   value = -search<NonPV>(pos, ss+1, -(alpha+1), -alpha, d);
> 
>                   doFullDepthSearch = (value > alpha);
>               }
>               ss->reduction = DEPTH_ZERO; // Restore original reduction
>           }
> 
>           // Probcut search for bad captures. If a reduced search returns a value
>           // very below beta then we can (almost) safely prune the bad capture.
>           if (isBadCap)
>           {
>               ss->reduction = 3 * ONE_PLY;
>               Value rAlpha = alpha - 300;
>               Depth d = newDepth - ss->reduction;
>               value = -search<NonPV>(pos, ss+1, -(rAlpha+1), -rAlpha, d);
>               doFullDepthSearch = (value > rAlpha);
>               ss->reduction = DEPTH_ZERO; // Restore original reduction
>           }
> 
>           // Step 15. Full depth search
>           if (doFullDepthSearch)
>           {
>               alpha = SpNode ? sp->alpha : alpha;
>               value = -search<NonPV>(pos, ss+1, -(alpha+1), -alpha, newDepth);
> 
>               // Step extra. pv search (only in PV nodes)
>               // Search only for possible new PV nodes, if instead value >= beta then
>               // parent node fails low with value <= alpha and tries another move.
>               if (PvNode && value > alpha && (Root || value < beta))
>                   value = -search<PV>(pos, ss+1, -beta, -alpha, newDepth);
>           }
>       }
> 
>       // Step 16. Undo move
>       pos.undo_move(move);
> 
>       assert(value > -VALUE_INFINITE && value < VALUE_INFINITE);
> 
>       // Step 17. Check for new best move
>       if (SpNode)
>       {
>           lock_grab(&(sp->lock));
>           bestValue = sp->bestValue;
>           alpha = sp->alpha;
>       }
> 
>       if (value > bestValue && !(SpNode && Threads[threadID].cutoff_occurred()))
>       {
>           bestValue = value;
> 
>           if (SpNode)
>               sp->bestValue = value;
> 
>           if (!Root && value > alpha)
>           {
>               if (PvNode && value < beta) // We want always alpha < beta
>               {
>                   alpha = value;
> 
>                   if (SpNode)
>                       sp->alpha = value;
>               }
>               else if (SpNode)
>                   sp->is_betaCutoff = true;
> 
>               if (value == value_mate_in(ss->ply + 1))
>                   ss->mateKiller = move;
> 
>               ss->bestMove = move;
> 
>               if (SpNode)
>                   sp->ss->bestMove = move;
>           }
>       }
> 
>       if (Root)
>       {
>           // Finished searching the move. If StopRequest is true, the search
>           // was aborted because the user interrupted the search or because we
>           // ran out of time. In this case, the return value of the search cannot
>           // be trusted, and we break out of the loop without updating the best
>           // move and/or PV.
>           if (StopRequest)
>               break;
> 
>           // Remember searched nodes counts for this move
>           mp.rm->nodes += pos.nodes_searched() - nodes;
> 
>           // PV move or new best move ?
>           if (isPvMove || value > alpha)
>           {
>               // Update PV
>               ss->bestMove = move;
>               mp.rm->pv_score = value;
>               mp.rm->extract_pv_from_tt(pos);
> 
>               // We record how often the best move has been changed in each
>               // iteration. This information is used for time management: When
>               // the best move changes frequently, we allocate some more time.
>               if (!isPvMove && MultiPV == 1)
>                   Rml.bestMoveChanges++;
> 
>               Rml.sort_multipv(moveCount);
> 
>               // Update alpha. In multi-pv we don't use aspiration window, so
>               // set alpha equal to minimum score among the PV lines.
>               if (MultiPV > 1)
>                   alpha = Rml[Min(moveCount, MultiPV) - 1].pv_score; // FIXME why moveCount?
>               else if (value > alpha)
>                   alpha = value;
>           }
>           else
>               mp.rm->pv_score = -VALUE_INFINITE;
> 
>       } // Root
> 
>       // Step 18. Check for split
>       if (   !Root
>           && !SpNode
>           && depth >= Threads.min_split_depth()
>           && bestValue < beta
>           && Threads.available_slave_exists(threadID)
>           && !StopRequest
>           && !Threads[threadID].cutoff_occurred())
>           Threads.split<FakeSplit>(pos, ss, &alpha, beta, &bestValue, depth,
>                                    threatMove, moveCount, &mp, PvNode);
>     }
> 
>     // Step 19. Check for mate and stalemate
>     // All legal moves have been searched and if there are
>     // no legal moves, it must be mate or stalemate.
>     // If one move was excluded return fail low score.
>     if (!SpNode && !moveCount)
>         return excludedMove ? oldAlpha : inCheck ? value_mated_in(ss->ply) : VALUE_DRAW;
> 
>     // Step 20. Update tables
>     // If the search is not aborted, update the transposition table,
>     // history counters, and killer moves.
>     if (!SpNode && !StopRequest && !Threads[threadID].cutoff_occurred())
>     {
>         move = bestValue <= oldAlpha ? MOVE_NONE : ss->bestMove;
>         vt   = bestValue <= oldAlpha ? VALUE_TYPE_UPPER
>              : bestValue >= beta ? VALUE_TYPE_LOWER : VALUE_TYPE_EXACT;
> 
>         TT.store(posKey, value_to_tt(bestValue, ss->ply), vt, depth, move, ss->eval, ss->evalMargin);
> 
>         // Update killers and history only for non capture moves that fails high
>         if (    bestValue >= beta
>             && !pos.move_is_capture_or_promotion(move))
>         {
>             if (move != ss->killers[0])
>             {
>                 ss->killers[1] = ss->killers[0];
>                 ss->killers[0] = move;
>             }
>             update_history(pos, move, depth, movesSearched, playedMoveCount);
>         }
>     }
> 
>     if (SpNode)
>     {
>         // Here we have the lock still grabbed
>         sp->is_slave[threadID] = false;
>         sp->nodes += pos.nodes_searched();
>         lock_release(&(sp->lock));
>     }
> 
>     assert(bestValue > -VALUE_INFINITE && bestValue < VALUE_INFINITE);
> 
>     return bestValue;
>   }
> 
>   // qsearch() is the quiescence search function, which is called by the main
>   // search function when the remaining depth is zero (or, to be more precise,
>   // less than ONE_PLY).
> 
>   template <NodeType PvNode>
>   Value qsearch(Position& pos, SearchStack* ss, Value alpha, Value beta, Depth depth) {
> 
>     assert(alpha >= -VALUE_INFINITE && alpha <= VALUE_INFINITE);
>     assert(beta >= -VALUE_INFINITE && beta <= VALUE_INFINITE);
>     assert(PvNode || alpha == beta - 1);
>     assert(depth <= 0);
>     assert(pos.thread() >= 0 && pos.thread() < Threads.size());
> 
>     StateInfo st;
>     Move ttMove, move;
>     Value bestValue, value, evalMargin, futilityValue, futilityBase;
>     bool inCheck, enoughMaterial, givesCheck, evasionPrunable;
>     const TTEntry* tte;
>     Depth ttDepth;
>     Value oldAlpha = alpha;
> 
>     ss->bestMove = ss->currentMove = MOVE_NONE;
>     ss->ply = (ss-1)->ply + 1;
> 
>     // Check for an instant draw or maximum ply reached
>     if (ss->ply > PLY_MAX || pos.is_draw())
>         return VALUE_DRAW;
> 
>     // Decide whether or not to include checks, this fixes also the type of
>     // TT entry depth that we are going to use. Note that in qsearch we use
>     // only two types of depth in TT: DEPTH_QS_CHECKS or DEPTH_QS_NO_CHECKS.
>     inCheck = pos.in_check();
>     ttDepth = (inCheck || depth >= DEPTH_QS_CHECKS ? DEPTH_QS_CHECKS : DEPTH_QS_NO_CHECKS);
> 
>     // Transposition table lookup. At PV nodes, we don't use the TT for
>     // pruning, but only for move ordering.
>     tte = TT.probe(pos.get_key());
>     ttMove = (tte ? tte->move() : MOVE_NONE);
> 
>     if (!PvNode && tte && ok_to_use_TT(tte, ttDepth, beta, ss->ply))
>     {
>         ss->bestMove = ttMove; // Can be MOVE_NONE
>         return value_from_tt(tte->value(), ss->ply);
>     }
> 
>     // Evaluate the position statically
>     if (inCheck)
>     {
>         bestValue = futilityBase = -VALUE_INFINITE;
>         ss->eval = evalMargin = VALUE_NONE;
>         enoughMaterial = false;
>     }
>     else
>     {
>         if (tte)
>         {
>             assert(tte->static_value() != VALUE_NONE);
> 
>             evalMargin = tte->static_value_margin();
>             ss->eval = bestValue = tte->static_value();
>         }
>         else
>             ss->eval = bestValue = evaluate(pos, evalMargin);
> 
>         update_gains(pos, (ss-1)->currentMove, (ss-1)->eval, ss->eval);
> 
>         // Stand pat. Return immediately if static value is at least beta
>         if (bestValue >= beta)
>         {
>             if (!tte)
>                 TT.store(pos.get_key(), value_to_tt(bestValue, ss->ply), VALUE_TYPE_LOWER, DEPTH_NONE, MOVE_NONE, ss->eval, evalMargin);
> 
>             return bestValue;
>         }
> 
>         if (PvNode && bestValue > alpha)
>             alpha = bestValue;
> 
>         // Futility pruning parameters, not needed when in check
>         futilityBase = ss->eval + evalMargin + FutilityMarginQS;
>         enoughMaterial = pos.non_pawn_material(pos.side_to_move()) > RookValueMidgame;
>     }
> 
>     // Initialize a MovePicker object for the current position, and prepare
>     // to search the moves. Because the depth is <= 0 here, only captures,
>     // queen promotions and checks (only if depth >= DEPTH_QS_CHECKS) will
>     // be generated.
>     MovePicker mp(pos, ttMove, depth, H);
>     CheckInfo ci(pos);
> 
>     // Loop through the moves until no moves remain or a beta cutoff occurs
>     while (   alpha < beta
>            && (move = mp.get_next_move()) != MOVE_NONE)
>     {
>       assert(move_is_ok(move));
> 
>       givesCheck = pos.move_gives_check(move, ci);
> 
>       // Futility pruning
>       if (   !PvNode
>           && !inCheck
>           && !givesCheck
>           &&  move != ttMove
>           &&  enoughMaterial
>           && !move_is_promotion(move)
>           && !pos.move_is_passed_pawn_push(move))
>       {
>           futilityValue =  futilityBase
>                          + pos.endgame_value_of_piece_on(move_to(move))
>                          + (move_is_ep(move) ? PawnValueEndgame : VALUE_ZERO);
> 
>           if (futilityValue < alpha)
>           {
>               if (futilityValue > bestValue)
>                   bestValue = futilityValue;
>               continue;
>           }
> 
>           // Prune moves with negative or equal SEE
>           if (   futilityBase < beta
>               && depth < DEPTH_ZERO
>               && pos.see(move) <= 0)
>               continue;
>       }
> 
>       // Detect non-capture evasions that are candidate to be pruned
>       evasionPrunable =   inCheck
>                        && bestValue > VALUE_MATED_IN_PLY_MAX
>                        && !pos.move_is_capture(move)
>                        && !pos.can_castle(pos.side_to_move());
> 
>       // Don't search moves with negative SEE values
>       if (   !PvNode
>           && (!inCheck || evasionPrunable)
>           &&  move != ttMove
>           && !move_is_promotion(move)
>           &&  pos.see_sign(move) < 0)
>           continue;
> 
>       // Don't search useless checks
>       if (   !PvNode
>           && !inCheck
>           &&  givesCheck
>           &&  move != ttMove
>           && !pos.move_is_capture_or_promotion(move)
>           &&  ss->eval + PawnValueMidgame / 4 < beta
>           && !check_is_dangerous(pos, move, futilityBase, beta, &bestValue))
>       {
>           if (ss->eval + PawnValueMidgame / 4 > bestValue)
>               bestValue = ss->eval + PawnValueMidgame / 4;
> 
>           continue;
>       }
> 
>       // Update current move
>       ss->currentMove = move;
> 
>       // Make and search the move
>       pos.do_move(move, st, ci, givesCheck);
>       value = -qsearch<PvNode>(pos, ss+1, -beta, -alpha, depth-ONE_PLY);
>       pos.undo_move(move);
> 
>       assert(value > -VALUE_INFINITE && value < VALUE_INFINITE);
> 
>       // New best move?
>       if (value > bestValue)
>       {
>           bestValue = value;
>           if (value > alpha)
>           {
>               alpha = value;
>               ss->bestMove = move;
>           }
>        }
>     }
> 
>     // All legal moves have been searched. A special case: If we're in check
>     // and no legal moves were found, it is checkmate.
>     if (inCheck && bestValue == -VALUE_INFINITE)
>         return value_mated_in(ss->ply);
> 
>     // Update transposition table
>     ValueType vt = (bestValue <= oldAlpha ? VALUE_TYPE_UPPER : bestValue >= beta ? VALUE_TYPE_LOWER : VALUE_TYPE_EXACT);
>     TT.store(pos.get_key(), value_to_tt(bestValue, ss->ply), vt, ttDepth, ss->bestMove, ss->eval, evalMargin);
> 
>     assert(bestValue > -VALUE_INFINITE && bestValue < VALUE_INFINITE);
> 
>     return bestValue;
>   }
> 
> 
>   // check_is_dangerous() tests if a checking move can be pruned in qsearch().
>   // bestValue is updated only when returning false because in that case move
>   // will be pruned.
> 
>   bool check_is_dangerous(Position &pos, Move move, Value futilityBase, Value beta, Value *bestValue)
>   {
>     Bitboard b, occ, oldAtt, newAtt, kingAtt;
>     Square from, to, ksq, victimSq;
>     Piece pc;
>     Color them;
>     Value futilityValue, bv = *bestValue;
> 
>     from = move_from(move);
>     to = move_to(move);
>     them = opposite_color(pos.side_to_move());
>     ksq = pos.king_square(them);
>     kingAtt = pos.attacks_from<KING>(ksq);
>     pc = pos.piece_on(from);
> 
>     occ = pos.occupied_squares() & ~(1ULL << from) & ~(1ULL << ksq);
>     oldAtt = pos.attacks_from(pc, from, occ);
>     newAtt = pos.attacks_from(pc,   to, occ);
> 
>     // Rule 1. Checks which give opponent's king at most one escape square are dangerous
>     b = kingAtt & ~pos.pieces_of_color(them) & ~newAtt & ~(1ULL << to);
> 
>     if (!(b && (b & (b - 1))))
>         return true;
> 
>     // Rule 2. Queen contact check is very dangerous
>     if (   type_of_piece(pc) == QUEEN
>         && bit_is_set(kingAtt, to))
>         return true;
> 
>     // Rule 3. Creating new double threats with checks
>     b = pos.pieces_of_color(them) & newAtt & ~oldAtt & ~(1ULL << ksq);
> 
>     while (b)
>     {
>         victimSq = pop_1st_bit(&b);
>         futilityValue = futilityBase + pos.endgame_value_of_piece_on(victimSq);
> 
>         // Note that here we generate illegal "double move"!
>         if (   futilityValue >= beta
>             && pos.see_sign(make_move(from, victimSq)) >= 0)
>             return true;
> 
>         if (futilityValue > bv)
>             bv = futilityValue;
>     }
> 
>     // Update bestValue only if check is not dangerous (because we will prune the move)
>     *bestValue = bv;
>     return false;
>   }
> 
> 
>   // connected_moves() tests whether two moves are 'connected' in the sense
>   // that the first move somehow made the second move possible (for instance
>   // if the moving piece is the same in both moves). The first move is assumed
>   // to be the move that was made to reach the current position, while the
>   // second move is assumed to be a move from the current position.
> 
>   bool connected_moves(const Position& pos, Move m1, Move m2) {
> 
>     Square f1, t1, f2, t2;
>     Piece p;
> 
>     assert(m1 && move_is_ok(m1));
>     assert(m2 && move_is_ok(m2));
> 
>     // Case 1: The moving piece is the same in both moves
>     f2 = move_from(m2);
>     t1 = move_to(m1);
>     if (f2 == t1)
>         return true;
> 
>     // Case 2: The destination square for m2 was vacated by m1
>     t2 = move_to(m2);
>     f1 = move_from(m1);
>     if (t2 == f1)
>         return true;
> 
>     // Case 3: Moving through the vacated square
>     if (   piece_is_slider(pos.piece_on(f2))
>         && bit_is_set(squares_between(f2, t2), f1))
>       return true;
> 
>     // Case 4: The destination square for m2 is defended by the moving piece in m1
>     p = pos.piece_on(t1);
>     if (bit_is_set(pos.attacks_from(p, t1), t2))
>         return true;
> 
>     // Case 5: Discovered check, checking piece is the piece moved in m1
>     if (    piece_is_slider(p)
>         &&  bit_is_set(squares_between(t1, pos.king_square(pos.side_to_move())), f2)
>         && !bit_is_set(squares_between(t1, pos.king_square(pos.side_to_move())), t2))
>     {
>         // discovered_check_candidates() works also if the Position's side to
>         // move is the opposite of the checking piece.
>         Color them = opposite_color(pos.side_to_move());
>         Bitboard dcCandidates = pos.discovered_check_candidates(them);
> 
>         if (bit_is_set(dcCandidates, f2))
>             return true;
>     }
>     return false;
>   }
> 
> 
>   // value_to_tt() adjusts a mate score from "plies to mate from the root" to
>   // "plies to mate from the current ply".  Non-mate scores are unchanged.
>   // The function is called before storing a value to the transposition table.
> 
>   Value value_to_tt(Value v, int ply) {
> 
>     if (v >= VALUE_MATE_IN_PLY_MAX)
>       return v + ply;
> 
>     if (v <= VALUE_MATED_IN_PLY_MAX)
>       return v - ply;
> 
>     return v;
>   }
> 
> 
>   // value_from_tt() is the inverse of value_to_tt(): It adjusts a mate score from
>   // the transposition table to a mate score corrected for the current ply.
> 
>   Value value_from_tt(Value v, int ply) {
> 
>     if (v >= VALUE_MATE_IN_PLY_MAX)
>       return v - ply;
> 
>     if (v <= VALUE_MATED_IN_PLY_MAX)
>       return v + ply;
> 
>     return v;
>   }
> 
> 
>   // extension() decides whether a move should be searched with normal depth,
>   // or with extended depth. Certain classes of moves (checking moves, in
>   // particular) are searched with bigger depth than ordinary moves and in
>   // any case are marked as 'dangerous'. Note that also if a move is not
>   // extended, as example because the corresponding UCI option is set to zero,
>   // the move is marked as 'dangerous' so, at least, we avoid to prune it.
>   template <NodeType PvNode>
>   Depth extension(const Position& pos, Move m, bool captureOrPromotion,
>                   bool moveIsCheck, bool* dangerous) {
> 
>     assert(m != MOVE_NONE);
> 
>     Depth result = DEPTH_ZERO;
>     *dangerous = moveIsCheck;
> 
>     if (moveIsCheck && pos.see_sign(m) >= 0)
>         result += CheckExtension[PvNode];
> 
>     if (pos.type_of_piece_on(move_from(m)) == PAWN)
>     {
>         Color c = pos.side_to_move();
>         if (relative_rank(c, move_to(m)) == RANK_7)
>         {
>             result += PawnPushTo7thExtension[PvNode];
>             *dangerous = true;
>         }
>         if (pos.pawn_is_passed(c, move_to(m)))
>         {
>             result += PassedPawnExtension[PvNode];
>             *dangerous = true;
>         }
>     }
> 
>     if (   captureOrPromotion
>         && pos.type_of_piece_on(move_to(m)) != PAWN
>         && (  pos.non_pawn_material(WHITE) + pos.non_pawn_material(BLACK)
>             - pos.midgame_value_of_piece_on(move_to(m)) == VALUE_ZERO)
>         && !move_is_special(m))
>     {
>         result += PawnEndgameExtension[PvNode];
>         *dangerous = true;
>     }
> 
>     return Min(result, ONE_PLY);
>   }
> 
> 
>   // connected_threat() tests whether it is safe to forward prune a move or if
>   // is somehow connected to the threat move returned by null search.
> 
>   bool connected_threat(const Position& pos, Move m, Move threat) {
> 
>     assert(move_is_ok(m));
>     assert(threat && move_is_ok(threat));
>     assert(!pos.move_gives_check(m));
>     assert(!pos.move_is_capture_or_promotion(m));
>     assert(!pos.move_is_passed_pawn_push(m));
> 
>     Square mfrom, mto, tfrom, tto;
> 
>     mfrom = move_from(m);
>     mto = move_to(m);
>     tfrom = move_from(threat);
>     tto = move_to(threat);
> 
>     // Case 1: Don't prune moves which move the threatened piece
>     if (mfrom == tto)
>         return true;
> 
>     // Case 2: If the threatened piece has value less than or equal to the
>     // value of the threatening piece, don't prune moves which defend it.
>     if (   pos.move_is_capture(threat)
>         && (   pos.midgame_value_of_piece_on(tfrom) >= pos.midgame_value_of_piece_on(tto)
>             || pos.type_of_piece_on(tfrom) == KING)
>         && pos.move_attacks_square(m, tto))
>         return true;
> 
>     // Case 3: If the moving piece in the threatened move is a slider, don't
>     // prune safe moves which block its ray.
>     if (   piece_is_slider(pos.piece_on(tfrom))
>         && bit_is_set(squares_between(tfrom, tto), mto)
>         && pos.see_sign(m) >= 0)
>         return true;
> 
>     return false;
>   }
> 
> 
>   // ok_to_use_TT() returns true if a transposition table score
>   // can be used at a given point in search.
> 
>   bool ok_to_use_TT(const TTEntry* tte, Depth depth, Value beta, int ply) {
> 
>     Value v = value_from_tt(tte->value(), ply);
> 
>     return   (   tte->depth() >= depth
>               || v >= Max(VALUE_MATE_IN_PLY_MAX, beta)
>               || v < Min(VALUE_MATED_IN_PLY_MAX, beta))
> 
>           && (   ((tte->type() & VALUE_TYPE_LOWER) && v >= beta)
>               || ((tte->type() & VALUE_TYPE_UPPER) && v < beta));
>   }
> 
> 
>   // refine_eval() returns the transposition table score if
>   // possible otherwise falls back on static position evaluation.
> 
>   Value refine_eval(const TTEntry* tte, Value defaultEval, int ply) {
> 
>       assert(tte);
> 
>       Value v = value_from_tt(tte->value(), ply);
> 
>       if (   ((tte->type() & VALUE_TYPE_LOWER) && v >= defaultEval)
>           || ((tte->type() & VALUE_TYPE_UPPER) && v < defaultEval))
>           return v;
> 
>       return defaultEval;
>   }
> 
> 
>   // update_history() registers a good move that produced a beta-cutoff
>   // in history and marks as failures all the other moves of that ply.
> 
>   void update_history(const Position& pos, Move move, Depth depth,
>                       Move movesSearched[], int moveCount) {
>     Move m;
>     Value bonus = Value(int(depth) * int(depth));
> 
>     H.update(pos.piece_on(move_from(move)), move_to(move), bonus);
> 
>     for (int i = 0; i < moveCount - 1; i++)
>     {
>         m = movesSearched[i];
> 
>         assert(m != move);
> 
>         H.update(pos.piece_on(move_from(m)), move_to(m), -bonus);
>     }
>   }
> 
> 
>   // update_gains() updates the gains table of a non-capture move given
>   // the static position evaluation before and after the move.
> 
>   void update_gains(const Position& pos, Move m, Value before, Value after) {
> 
>     if (   m != MOVE_NULL
>         && before != VALUE_NONE
>         && after != VALUE_NONE
>         && pos.captured_piece_type() == PIECE_TYPE_NONE
>         && !move_is_special(m))
>         H.update_gain(pos.piece_on(move_to(m)), move_to(m), -(before + after));
>   }
> 
> 
>   // current_search_time() returns the number of milliseconds which have passed
>   // since the beginning of the current search.
> 
>   int current_search_time(int set) {
> 
>     static int searchStartTime;
> 
>     if (set)
>         searchStartTime = set;
> 
>     return get_system_time() - searchStartTime;
>   }
> 
> 
>   // value_to_uci() converts a value to a string suitable for use with the UCI
>   // protocol specifications:
>   //
>   // cp <x>     The score from the engine's point of view in centipawns.
>   // mate <y>   Mate in y moves, not plies. If the engine is getting mated
>   //            use negative values for y.
> 
>   std::string value_to_uci(Value v) {
> 
>     std::stringstream s;
> 
>     if (abs(v) < VALUE_MATE - PLY_MAX * ONE_PLY)
>         s << "cp " << int(v) * 100 / int(PawnValueMidgame); // Scale to centipawns
>     else
>         s << "mate " << (v > 0 ? VALUE_MATE - v + 1 : -VALUE_MATE - v) / 2;
> 
>     return s.str();
>   }
> 
> 
>   // speed_to_uci() returns a string with time stats of current search suitable
>   // to be sent to UCI gui.
> 
>   std::string speed_to_uci(int64_t nodes) {
> 
>     std::stringstream s;
>     int t = current_search_time();
> 
>     s << " nodes " << nodes
>       << " nps "   << (t > 0 ? int(nodes * 1000 / t) : 0)
>       << " time "  << t;
> 
>     return s.str();
>   }
> 
> 
>   // poll() performs two different functions: It polls for user input, and it
>   // looks at the time consumed so far and decides if it's time to abort the
>   // search.
> 
>   void poll(const Position& pos) {
> 
>     static int lastInfoTime;
>     int t = current_search_time();
> 
>     //  Poll for input
>     if (input_available())
>     {
>         // We are line oriented, don't read single chars
>         std::string command;
> 
>         if (!std::getline(std::cin, command) || command == "quit")
>         {
>             // Quit the program as soon as possible
>             Limits.ponder = false;
>             QuitRequest = StopRequest = true;
>             return;
>         }
>         else if (command == "stop")
>         {
>             // Stop calculating as soon as possible, but still send the "bestmove"
>             // and possibly the "ponder" token when finishing the search.
>             Limits.ponder = false;
>             StopRequest = true;
>         }
>         else if (command == "ponderhit")
>         {
>             // The opponent has played the expected move. GUI sends "ponderhit" if
>             // we were told to ponder on the same move the opponent has played. We
>             // should continue searching but switching from pondering to normal search.
>             Limits.ponder = false;
> 
>             if (StopOnPonderhit)
>                 StopRequest = true;
>         }
>     }
> 
>     // Print search information
>     if (t < 1000)
>         lastInfoTime = 0;
> 
>     else if (lastInfoTime > t)
>         // HACK: Must be a new search where we searched less than
>         // NodesBetweenPolls nodes during the first second of search.
>         lastInfoTime = 0;
> 
>     else if (t - lastInfoTime >= 1000)
>     {
>         lastInfoTime = t;
> 
>         dbg_print_mean();
>         dbg_print_hit_rate();
> 
>         // Send info on searched nodes as soon as we return to root
>         SendSearchedNodes = true;
>     }
> 
>     // Should we stop the search?
>     if (Limits.ponder)
>         return;
> 
>     bool stillAtFirstMove =    FirstRootMove
>                            && !AspirationFailLow
>                            &&  t > TimeMgr.available_time();
> 
>     bool noMoreTime =   t > TimeMgr.maximum_time()
>                      || stillAtFirstMove;
> 
>     if (   (Limits.useTimeManagement() && noMoreTime)
>         || (Limits.maxTime && t >= Limits.maxTime)
>         || (Limits.maxNodes && pos.nodes_searched() >= Limits.maxNodes)) // FIXME
>         StopRequest = true;
>   }
> 
> 
>   // wait_for_stop_or_ponderhit() is called when the maximum depth is reached
>   // while the program is pondering. The point is to work around a wrinkle in
>   // the UCI protocol: When pondering, the engine is not allowed to give a
>   // "bestmove" before the GUI sends it a "stop" or "ponderhit" command.
>   // We simply wait here until one of these commands is sent, and return,
>   // after which the bestmove and pondermove will be printed.
> 
>   void wait_for_stop_or_ponderhit() {
> 
>     std::string command;
> 
>     // Wait for a command from stdin
>     while (   std::getline(std::cin, command)
>            && command != "ponderhit" && command != "stop" && command != "quit") {};
> 
>     if (command != "ponderhit" && command != "stop")
>         QuitRequest = true; // Must be "quit" or getline() returned false
>   }
> 
> 
>   // When playing with strength handicap choose best move among the MultiPV set
>   // using a statistical rule dependent on SkillLevel. Idea by Heinz van Saanen.
>   void do_skill_level(Move* best, Move* ponder) {
> 
>     assert(MultiPV > 1);
> 
>     static RKISS rk;
> 
>     // Rml list is already sorted by pv_score in descending order
>     int s;
>     int max_s = -VALUE_INFINITE;
>     int size = Min(MultiPV, (int)Rml.size());
>     int max = Rml[0].pv_score;
>     int var = Min(max - Rml[size - 1].pv_score, PawnValueMidgame);
>     int wk = 120 - 2 * SkillLevel;
> 
>     // PRNG sequence should be non deterministic
>     for (int i = abs(get_system_time() % 50); i > 0; i--)
>         rk.rand<unsigned>();
> 
>     // Choose best move. For each move's score we add two terms both dependent
>     // on wk, one deterministic and bigger for weaker moves, and one random,
>     // then we choose the move with the resulting highest score.
>     for (int i = 0; i < size; i++)
>     {
>         s = Rml[i].pv_score;
> 
>         // Don't allow crazy blunders even at very low skills
>         if (i > 0 && Rml[i-1].pv_score > s + EasyMoveMargin)
>             break;
> 
>         // This is our magical formula
>         s += ((max - s) * wk + var * (rk.rand<unsigned>() % wk)) / 128;
> 
>         if (s > max_s)
>         {
>             max_s = s;
>             *best = Rml[i].pv[0];
>             *ponder = Rml[i].pv[1];
>         }
>     }
>   }
> 
> 
>   /// RootMove and RootMoveList method's definitions
> 
>   RootMove::RootMove() {
> 
>     nodes = 0;
>     pv_score = non_pv_score = -VALUE_INFINITE;
>     pv[0] = MOVE_NONE;
>   }
> 
>   RootMove& RootMove::operator=(const RootMove& rm) {
> 
>     const Move* src = rm.pv;
>     Move* dst = pv;
> 
>     // Avoid a costly full rm.pv[] copy
>     do *dst++ = *src; while (*src++ != MOVE_NONE);
> 
>     nodes = rm.nodes;
>     pv_score = rm.pv_score;
>     non_pv_score = rm.non_pv_score;
>     return *this;
>   }
> 
>   void RootMoveList::init(Position& pos, Move searchMoves[]) {
> 
>     MoveStack mlist[MAX_MOVES];
>     Move* sm;
> 
>     clear();
>     bestMoveChanges = 0;
> 
>     // Generate all legal moves and add them to RootMoveList
>     MoveStack* last = generate<MV_LEGAL>(pos, mlist);
>     for (MoveStack* cur = mlist; cur != last; cur++)
>     {
>         // If we have a searchMoves[] list then verify cur->move
>         // is in the list before to add it.
>         for (sm = searchMoves; *sm && *sm != cur->move; sm++) {}
> 
>         if (searchMoves[0] && *sm != cur->move)
>             continue;
> 
>         RootMove rm;
>         rm.pv[0] = cur->move;
>         rm.pv[1] = MOVE_NONE;
>         rm.pv_score = -VALUE_INFINITE;
>         push_back(rm);
>     }
>   }
> 
>   // extract_pv_from_tt() builds a PV by adding moves from the transposition table.
>   // We consider also failing high nodes and not only VALUE_TYPE_EXACT nodes. This
>   // allow to always have a ponder move even when we fail high at root and also a
>   // long PV to print that is important for position analysis.
> 
>   void RootMove::extract_pv_from_tt(Position& pos) {
> 
>     StateInfo state[PLY_MAX_PLUS_2], *st = state;
>     TTEntry* tte;
>     int ply = 1;
> 
>     assert(pv[0] != MOVE_NONE && pos.move_is_legal(pv[0]));
> 
>     pos.do_move(pv[0], *st++);
> 
>     while (   (tte = TT.probe(pos.get_key())) != NULL
>            && tte->move() != MOVE_NONE
>            && pos.move_is_legal(tte->move())
>            && ply < PLY_MAX
>            && (!pos.is_draw() || ply < 2))
>     {
>         pv[ply] = tte->move();
>         pos.do_move(pv[ply++], *st++);
>     }
>     pv[ply] = MOVE_NONE;
> 
>     do pos.undo_move(pv[--ply]); while (ply);
>   }
> 
>   // insert_pv_in_tt() is called at the end of a search iteration, and inserts
>   // the PV back into the TT. This makes sure the old PV moves are searched
>   // first, even if the old TT entries have been overwritten.
> 
>   void RootMove::insert_pv_in_tt(Position& pos) {
> 
>     StateInfo state[PLY_MAX_PLUS_2], *st = state;
>     TTEntry* tte;
>     Key k;
>     Value v, m = VALUE_NONE;
>     int ply = 0;
> 
>     assert(pv[0] != MOVE_NONE && pos.move_is_legal(pv[0]));
> 
>     do {
>         k = pos.get_key();
>         tte = TT.probe(k);
> 
>         // Don't overwrite existing correct entries
>         if (!tte || tte->move() != pv[ply])
>         {
>             v = (pos.in_check() ? VALUE_NONE : evaluate(pos, m));
>             TT.store(k, VALUE_NONE, VALUE_TYPE_NONE, DEPTH_NONE, pv[ply], v, m);
>         }
>         pos.do_move(pv[ply], *st++);
> 
>     } while (pv[++ply] != MOVE_NONE);
> 
>     do pos.undo_move(pv[--ply]); while (ply);
>   }
> 
>   // pv_info_to_uci() returns a string with information on the current PV line
>   // formatted according to UCI specification.
> 
>   std::string RootMove::pv_info_to_uci(Position& pos, int depth, int selDepth, Value alpha,
>                                        Value beta, int pvIdx) {
>     std::stringstream s;
> 
>     s << "info depth " << depth
>       << " seldepth " << selDepth
>       << " multipv " << pvIdx + 1
>       << " score " << value_to_uci(pv_score)
>       << (pv_score >= beta ? " lowerbound" : pv_score <= alpha ? " upperbound" : "")
>       << speed_to_uci(pos.nodes_searched())
>       << " pv ";
> 
>     for (Move* m = pv; *m != MOVE_NONE; m++)
>         s << *m << " ";
> 
>     return s.str();
>   }
> 
>   // Specializations for MovePickerExt in case of Root node
>   MovePickerExt<false, true>::MovePickerExt(const Position& p, Move ttm, Depth d,
>                                             const History& h, SearchStack* ss, Value b)
>                             : MovePicker(p, ttm, d, h, ss, b), firstCall(true) {
>     Move move;
>     Value score = VALUE_ZERO;
> 
>     // Score root moves using standard ordering used in main search, the moves
>     // are scored according to the order in which they are returned by MovePicker.
>     // This is the second order score that is used to compare the moves when
>     // the first orders pv_score of both moves are equal.
>     while ((move = MovePicker::get_next_move()) != MOVE_NONE)
>         for (rm = Rml.begin(); rm != Rml.end(); ++rm)
>             if (rm->pv[0] == move)
>             {
>                 rm->non_pv_score = score--;
>                 break;
>             }
> 
>     Rml.sort();
>     rm = Rml.begin();
>   }
> 
>   Move MovePickerExt<false, true>::get_next_move() {
> 
>     if (!firstCall)
>         ++rm;
>     else
>         firstCall = false;
2612c2085,2086
< 		} while (pv[++ply] != MOVE_NONE);
---
>     return rm != Rml.end() ? rm->pv[0] : MOVE_NONE;
>   }
2614,2615d2087
< 		do pos.undo_move(pv[--ply]); while (ply);
< 	}
2619,2719c2091,2197
< // Little helper used by idle_loop() to check that all the slave threads of a
< // split point have finished searching.
< 
< static bool all_slaves_finished(SplitPoint* sp) {
< 
< 	for (int i = 0; i < Threads.size(); i++)
< 		if (sp->is_slave[i])
< 			return false;
< 
< 	return true;
< }
< 
< 
< // Thread::idle_loop() is where the thread is parked when it has no work to do.
< // The parameter 'sp', if non-NULL, is a pointer to an active SplitPoint object
< // for which the thread is the master.
< 
< void Thread::idle_loop(SplitPoint* sp) {
< 
< 	while (true)
< 	{
< 		// If we are not searching, wait for a condition to be signaled
< 		// instead of wasting CPU time polling for work.
< 		while (   do_sleep
< 		       || do_terminate
< 		       || (Threads.use_sleeping_threads() && !is_searching))
< 		{
< 			assert((!sp && threadID) || Threads.use_sleeping_threads());
< 
< 			// Slave thread should exit as soon as do_terminate flag raises
< 			if (do_terminate)
< 			{
< 				assert(!sp);
< 				return;
< 			}
< 
< 			// Grab the lock to avoid races with Thread::wake_up()
< 			lock_grab(&sleepLock);
< 
< 			// If we are master and all slaves have finished don't go to sleep
< 			if (sp && all_slaves_finished(sp))
< 			{
< 				lock_release(&sleepLock);
< 				break;
< 			}
< 
< 			// Do sleep after retesting sleep conditions under lock protection, in
< 			// particular we need to avoid a deadlock in case a master thread has,
< 			// in the meanwhile, allocated us and sent the wake_up() call before we
< 			// had the chance to grab the lock.
< 			if (do_sleep || !is_searching)
< 				cond_wait(&sleepCond, &sleepLock);
< 
< 			lock_release(&sleepLock);
< 		}
< 
< 		// If this thread has been assigned work, launch a search
< 		if (is_searching)
< 		{
< 			assert(!do_terminate);
< 
< 			// Copy split point position and search stack and call search()
< 			SearchStack ss[PLY_MAX_PLUS_2];
< 			SplitPoint* tsp = splitPoint;
< 			Position pos(*tsp->pos, threadID);
< 
< 			memcpy(ss, tsp->ss - 1, 4 * sizeof(SearchStack));
< 			(ss+1)->sp = tsp;
< 
< 			if (tsp->nodeType == Root)
< 				search<SplitPointRoot>(pos, ss+1, tsp->alpha, tsp->beta, tsp->depth);
< 			else if (tsp->nodeType == PV)
< 				search<SplitPointPV>(pos, ss+1, tsp->alpha, tsp->beta, tsp->depth);
< 			else if (tsp->nodeType == NonPV)
< 				search<SplitPointNonPV>(pos, ss+1, tsp->alpha, tsp->beta, tsp->depth);
< 			else
< 				assert(false);
< 
< 			assert(is_searching);
< 
< 			is_searching = false;
< 
< 			// Wake up master thread so to allow it to return from the idle loop in
< 			// case we are the last slave of the split point.
< 			if (   Threads.use_sleeping_threads()
< 			    && threadID != tsp->master
< 			    && !Threads[tsp->master].is_searching)
< 				Threads[tsp->master].wake_up();
< 		}
< 
< 		// If this thread is the master of a split point and all slaves have
< 		// finished their work at this split point, return from the idle loop.
< 		if (sp && all_slaves_finished(sp))
< 		{
< 			// Because sp->is_slave[] is reset under lock protection,
< 			// be sure sp->lock has been released before to return.
< 			lock_grab(&(sp->lock));
< 			lock_release(&(sp->lock));
< 			return;
< 		}
< 	}
---
> // ThreadsManager::idle_loop() is where the threads are parked when they have no work
> // to do. The parameter 'sp', if non-NULL, is a pointer to an active SplitPoint
> // object for which the current thread is the master.
> 
> void ThreadsManager::idle_loop(int threadID, SplitPoint* sp) {
> 
>   assert(threadID >= 0 && threadID < MAX_THREADS);
> 
>   int i;
>   bool allFinished;
> 
>   while (true)
>   {
>       // Slave threads can exit as soon as AllThreadsShouldExit raises,
>       // master should exit as last one.
>       if (allThreadsShouldExit)
>       {
>           assert(!sp);
>           threads[threadID].state = Thread::TERMINATED;
>           return;
>       }
> 
>       // If we are not thinking, wait for a condition to be signaled
>       // instead of wasting CPU time polling for work.
>       while (   threadID >= activeThreads
>              || threads[threadID].state == Thread::INITIALIZING
>              || (useSleepingThreads && threads[threadID].state == Thread::AVAILABLE))
>       {
>           assert(!sp || useSleepingThreads);
>           assert(threadID != 0 || useSleepingThreads);
> 
>           if (threads[threadID].state == Thread::INITIALIZING)
>               threads[threadID].state = Thread::AVAILABLE;
> 
>           // Grab the lock to avoid races with Thread::wake_up()
>           lock_grab(&threads[threadID].sleepLock);
> 
>           // If we are master and all slaves have finished do not go to sleep
>           for (i = 0; sp && i < activeThreads && !sp->is_slave[i]; i++) {}
>           allFinished = (i == activeThreads);
> 
>           if (allFinished || allThreadsShouldExit)
>           {
>               lock_release(&threads[threadID].sleepLock);
>               break;
>           }
> 
>           // Do sleep here after retesting sleep conditions
>           if (threadID >= activeThreads || threads[threadID].state == Thread::AVAILABLE)
>               cond_wait(&threads[threadID].sleepCond, &threads[threadID].sleepLock);
> 
>           lock_release(&threads[threadID].sleepLock);
>       }
> 
>       // If this thread has been assigned work, launch a search
>       if (threads[threadID].state == Thread::WORKISWAITING)
>       {
>           assert(!allThreadsShouldExit);
> 
>           threads[threadID].state = Thread::SEARCHING;
> 
>           // Copy split point position and search stack and call search()
>           // with SplitPoint template parameter set to true.
>           SearchStack ss[PLY_MAX_PLUS_2];
>           SplitPoint* tsp = threads[threadID].splitPoint;
>           Position pos(*tsp->pos, threadID);
> 
>           memcpy(ss, tsp->ss - 1, 4 * sizeof(SearchStack));
>           (ss+1)->sp = tsp;
> 
>           if (tsp->pvNode)
>               search<PV, true, false>(pos, ss+1, tsp->alpha, tsp->beta, tsp->depth);
>           else
>               search<NonPV, true, false>(pos, ss+1, tsp->alpha, tsp->beta, tsp->depth);
> 
>           assert(threads[threadID].state == Thread::SEARCHING);
> 
>           threads[threadID].state = Thread::AVAILABLE;
> 
>           // Wake up master thread so to allow it to return from the idle loop in
>           // case we are the last slave of the split point.
>           if (   useSleepingThreads
>               && threadID != tsp->master
>               && threads[tsp->master].state == Thread::AVAILABLE)
>               threads[tsp->master].wake_up();
>       }
> 
>       // If this thread is the master of a split point and all slaves have
>       // finished their work at this split point, return from the idle loop.
>       for (i = 0; sp && i < activeThreads && !sp->is_slave[i]; i++) {}
>       allFinished = (i == activeThreads);
> 
>       if (allFinished)
>       {
>           // Because sp->slaves[] is reset under lock protection,
>           // be sure sp->lock has been released before to return.
>           lock_grab(&(sp->lock));
>           lock_release(&(sp->lock));
> 
>           // In helpful master concept a master can help only a sub-tree, and
>           // because here is all finished is not possible master is booked.
>           assert(threads[threadID].state == Thread::AVAILABLE);
> 
>           threads[threadID].state = Thread::SEARCHING;
>           return;
>       }
>   }
########################## shogi.cpp
########################## thread.cpp
2c2
<   NanohaMini, a USI shogi(japanese-chess) playing engine derived from Stockfish 2.1
---
>   Stockfish, a UCI chess playing engine derived from Glaurung 2.1
4,5c4
<   Copyright (C) 2008-2010 Marco Costalba, Joona Kiiski, Tord Romstad (Stockfish author)
<   Copyright (C) 2014 Kazuyuki Kawabata
---
>   Copyright (C) 2008-2010 Marco Costalba, Joona Kiiski, Tord Romstad
7c6
<   NanohaMini is free software: you can redistribute it and/or modify
---
>   Stockfish is free software: you can redistribute it and/or modify
12c11
<   NanohaMini is distributed in the hope that it will be useful,
---
>   Stockfish is distributed in the hope that it will be useful,
31c30
<  // is launched. It simply calls idle_loop() of the supplied thread.
---
>  // is launched. It simply calls idle_loop() with the supplied threadID.
35c34
< #if defined(_MSC_VER) || defined(_WIN32)
---
> #if defined(_MSC_VER)
37c36
< 	DWORD WINAPI start_routine(LPVOID thread) {
---
>   DWORD WINAPI start_routine(LPVOID threadID) {
39,41c38,40
< 		((Thread*)thread)->idle_loop(NULL);
< 		return 0;
< 	}
---
>     Threads.idle_loop(*(int*)threadID, NULL);
>     return 0;
>   }
45c44
< 	void* start_routine(void* thread) {
---
>   void* start_routine(void* threadID) {
47,49c46,48
< 		((Thread*)thread)->idle_loop(NULL);
< 		return NULL;
< 	}
---
>     Threads.idle_loop(*(int*)threadID, NULL);
>     return NULL;
>   }
61,63c60,62
< 	lock_grab(&sleepLock);
< 	cond_signal(&sleepCond);
< 	lock_release(&sleepLock);
---
>   lock_grab(&sleepLock);
>   cond_signal(&sleepCond);
>   lock_release(&sleepLock);
67,68c66,68
< // cutoff_occurred() checks whether a beta cutoff has occurred in the current
< // active split point, or in some ancestor of the split point.
---
> // cutoff_occurred() checks whether a beta cutoff has occurred in
> // the thread's currently active split point, or in some ancestor of
> // the current split point.
72,75c72,75
< 	for (SplitPoint* sp = splitPoint; sp; sp = sp->parent)
< 		if (sp->is_betaCutoff)
< 			return true;
< 	return false;
---
>   for (SplitPoint* sp = splitPoint; sp; sp = sp->parent)
>       if (sp->is_betaCutoff)
>           return true;
>   return false;
88,89c88,89
< 	if (is_searching)
< 		return false;
---
>   if (state != AVAILABLE)
>       return false;
91,99c91,99
< 	// Make a local copy to be sure doesn't become zero under our feet while
< 	// testing next condition and so leading to an out of bound access.
< 	int localActiveSplitPoints = activeSplitPoints;
< 
< 	// No active split points means that the thread is available as a slave for any
< 	// other thread otherwise apply the "helpful master" concept if possible.
< 	if (   !localActiveSplitPoints
< 	    || splitPoints[localActiveSplitPoints - 1].is_slave[master])
< 		return true;
---
>   // Make a local copy to be sure doesn't become zero under our feet while
>   // testing next condition and so leading to an out of bound access.
>   int localActiveSplitPoints = activeSplitPoints;
> 
>   // No active split points means that the thread is available as a slave for any
>   // other thread otherwise apply the "helpful master" concept if possible.
>   if (   !localActiveSplitPoints
>       || splitPoints[localActiveSplitPoints - 1].is_slave[master])
>       return true;
101c101
< 	return false;
---
>   return false;
111,144c111,114
< 	maxThreadsPerSplitPoint = Options["Maximum Number of Threads per Split Point"].value<int>();
< 	minimumSplitDepth       = Options["Minimum Split Depth"].value<int>() * ONE_PLY;
< 	useSleepingThreads      = Options["Use Sleeping Threads"].value<bool>();
< 
< 	set_size(Options["Threads"].value<int>());
< }
< 
< 
< // set_size() changes the number of active threads and raises do_sleep flag for
< // all the unused threads that will go immediately to sleep.
< 
< void ThreadsManager::set_size(int cnt) {
< 
< 	assert(cnt > 0 && cnt <= MAX_THREADS);
< 
< 	activeThreads = cnt;
< 
< 	for (int i = 0; i < MAX_THREADS; i++)
< 		if (i < activeThreads)
< 		{
< 			// Dynamically allocate pawn and material hash tables according to the
< 			// number of active threads. This avoids preallocating memory for all
< 			// possible threads if only few are used as, for instance, on mobile
< 			// devices where memory is scarce and allocating for MAX_THREADS could
< 			// even result in a crash.
< #if !defined(NANOHA)
< 			threads[i].pawnTable.init();
< 			threads[i].materialTable.init();
< #endif
< 
< 			threads[i].do_sleep = false;
< 		}
< 		else
< 			threads[i].do_sleep = true;
---
>   maxThreadsPerSplitPoint = Options["Maximum Number of Threads per Split Point"].value<int>();
>   minimumSplitDepth       = Options["Minimum Split Depth"].value<int>() * ONE_PLY;
>   useSleepingThreads      = Options["Use Sleeping Threads"].value<bool>();
>   activeThreads           = Options["Threads"].value<int>();
153,154c123
< 	// Initialize threads lock, used when allocating slaves during splitting
< 	lock_init(&threadsLock);
---
>   int threadID[MAX_THREADS];
156,191c125,154
< 	// Initialize sleep and split point locks
< 	for (int i = 0; i < MAX_THREADS; i++)
< 	{
< 		lock_init(&threads[i].sleepLock);
< 		cond_init(&threads[i].sleepCond);
< 
< 		for (int j = 0; j < MAX_ACTIVE_SPLIT_POINTS; j++)
< 			lock_init(&(threads[i].splitPoints[j].lock));
< 	}
< 
< 	// Initialize main thread's associated data
< 	threads[0].is_searching = true;
< 	threads[0].threadID = 0;
< 	set_size(1); // This makes all the threads but the main to go to sleep
< 
< 	// Create and launch all the threads but the main that is already running,
< 	// threads will go immediately to sleep.
< 	for (int i = 1; i < MAX_THREADS; i++)
< 	{
< 		threads[i].is_searching = false;
< 		threads[i].threadID = i;
< 
< #if defined(_MSC_VER) || defined(_WIN32) 
< #if defined(NANOHA)
< 		// とりあえず、スタックサイズ32MB
< 		threads[i].handle = CreateThread(NULL, 1024*1024*32, start_routine, (LPVOID)&threads[i], 0, NULL);
< #else
< 		threads[i].handle = CreateThread(NULL, 0, start_routine, (LPVOID)&threads[i], 0, NULL);
< #endif
< 		bool ok = (threads[i].handle != NULL);
< #else
< #if defined(NANOHA)
< 		pthread_attr_t attr  ;
< 		pthread_attr_init(&attr);
< 		pthread_attr_setstacksize(&attr,1024*1024*32);
< 		bool ok = (pthread_create(&threads[i].handle, &attr, start_routine, (void*)&threads[i]) == 0);
---
>   // This flag is needed to properly end the threads when program exits
>   allThreadsShouldExit = false;
> 
>   // Threads will sent to sleep as soon as created, only main thread is kept alive
>   activeThreads = 1;
>   threads[0].state = Thread::SEARCHING;
> 
>   // Allocate pawn and material hash tables for main thread
>   init_hash_tables();
> 
>   lock_init(&mpLock);
> 
>   // Initialize thread and split point locks
>   for (int i = 0; i < MAX_THREADS; i++)
>   {
>       lock_init(&threads[i].sleepLock);
>       cond_init(&threads[i].sleepCond);
> 
>       for (int j = 0; j < MAX_ACTIVE_SPLIT_POINTS; j++)
>           lock_init(&(threads[i].splitPoints[j].lock));
>   }
> 
>   // Create and startup all the threads but the main that is already running
>   for (int i = 1; i < MAX_THREADS; i++)
>   {
>       threads[i].state = Thread::INITIALIZING;
>       threadID[i] = i;
> 
> #if defined(_MSC_VER)
>       bool ok = (CreateThread(NULL, 0, start_routine, (LPVOID)&threadID[i], 0, NULL) != NULL);
193,194c156,158
< 		bool ok = (pthread_create(&threads[i].handle, NULL, start_routine, (void*)&threads[i]) == 0);
< #endif
---
>       pthread_t pthreadID;
>       bool ok = (pthread_create(&pthreadID, NULL, start_routine, (void*)&threadID[i]) == 0);
>       pthread_detach(pthreadID);
196,201c160,168
< 		if (!ok)
< 		{
< 			std::cerr << "Failed to create thread number " << i << std::endl;
< 			::exit(EXIT_FAILURE);
< 		}
< 	}
---
>       if (!ok)
>       {
>           std::cout << "Failed to create thread number " << i << std::endl;
>           ::exit(EXIT_FAILURE);
>       }
> 
>       // Wait until the thread has finished launching and is gone to sleep
>       while (threads[i].state == Thread::INITIALIZING) {}
>   }
205c172
< // exit() is called to cleanly terminate the threads when the program finishes
---
> // exit() is called to cleanly exit the threads when the program finishes
209,228c176,194
< 	// Wake up all the slave threads at once. This is faster than "wake and wait"
< 	// for each thread and avoids a rare crash once every 10K games under Linux.
< 	for (int i = 1; i < MAX_THREADS; i++)
< 	{
< 		threads[i].do_terminate = true;
< 		threads[i].wake_up();
< 	}
< 
< 	for (int i = 0; i < MAX_THREADS; i++)
< 	{
< 		if (i != 0)
< 		{
< 			// Wait for slave termination
< #if defined(_MSC_VER)
< 			WaitForSingleObject(threads[i].handle, 0);
< 			CloseHandle(threads[i].handle);
< #else
< 			pthread_join(threads[i].handle, NULL);
< #endif
< 		}
---
>   // Force the woken up threads to exit idle_loop() and hence terminate
>   allThreadsShouldExit = true;
> 
>   for (int i = 0; i < MAX_THREADS; i++)
>   {
>       // Wake up all the threads and waits for termination
>       if (i != 0)
>       {
>           threads[i].wake_up();
>           while (threads[i].state != Thread::TERMINATED) {}
>       }
> 
>       // Now we can safely destroy the locks and wait conditions
>       lock_destroy(&threads[i].sleepLock);
>       cond_destroy(&threads[i].sleepCond);
> 
>       for (int j = 0; j < MAX_ACTIVE_SPLIT_POINTS; j++)
>           lock_destroy(&(threads[i].splitPoints[j].lock));
>   }
230,232c196,197
< 		// Now we can safely destroy locks and wait conditions
< 		lock_destroy(&threads[i].sleepLock);
< 		cond_destroy(&threads[i].sleepCond);
---
>   lock_destroy(&mpLock);
> }
234,236d198
< 		for (int j = 0; j < MAX_ACTIVE_SPLIT_POINTS; j++)
< 			lock_destroy(&(threads[i].splitPoints[j].lock));
< 	}
238c200,212
< 	lock_destroy(&threadsLock);
---
> // init_hash_tables() dynamically allocates pawn and material hash tables
> // according to the number of active threads. This avoids preallocating
> // memory for all possible threads if only few are used as, for instance,
> // on mobile devices where memory is scarce and allocating for MAX_THREADS
> // threads could even result in a crash.
> 
> void ThreadsManager::init_hash_tables() {
> 
>   for (int i = 0; i < activeThreads; i++)
>   {
>       threads[i].pawnTable.init();
>       threads[i].materialTable.init();
>   }
247c221
< 	assert(master >= 0 && master < activeThreads);
---
>   assert(master >= 0 && master < activeThreads);
249,251c223,225
< 	for (int i = 0; i < activeThreads; i++)
< 		if (i != master && threads[i].is_available_to(master))
< 			return true;
---
>   for (int i = 0; i < activeThreads; i++)
>       if (i != master && threads[i].is_available_to(master))
>           return true;
253c227
< 	return false;
---
>   return false;
267,362c241,338
< Value ThreadsManager::split(Position& pos, SearchStack* ss, Value alpha, Value beta,
< 	                          Value bestValue, Depth depth, Move threatMove,
< 	                          int moveCount, MovePicker* mp, int nodeType) {
< 	assert(pos.is_ok());
< 	assert(bestValue >= -VALUE_INFINITE);
< 	assert(bestValue <= alpha);
< 	assert(alpha < beta);
< 	assert(beta <= VALUE_INFINITE);
< 	assert(depth > DEPTH_ZERO);
< 	assert(pos.thread() >= 0 && pos.thread() < activeThreads);
< 	assert(activeThreads > 1);
< 
< 	int i, master = pos.thread();
< 	Thread& masterThread = threads[master];
< 
< 	// If we already have too many active split points, don't split
< 	if (masterThread.activeSplitPoints >= MAX_ACTIVE_SPLIT_POINTS)
< 		return bestValue;
< 
< 	// Pick the next available split point object from the split point stack
< 	SplitPoint* sp = masterThread.splitPoints + masterThread.activeSplitPoints;
< 
< 	// Initialize the split point object
< 	sp->parent = masterThread.splitPoint;
< 	sp->master = master;
< 	sp->is_betaCutoff = false;
< 	sp->depth = depth;
< 	sp->threatMove = threatMove;
< 	sp->alpha = alpha;
< 	sp->beta = beta;
< 	sp->nodeType = nodeType;
< 	sp->bestValue = bestValue;
< 	sp->mp = mp;
< 	sp->moveCount = moveCount;
< 	sp->pos = &pos;
< 	sp->nodes = 0;
< 	sp->ss = ss;
< 	for (i = 0; i < activeThreads; i++)
< 		sp->is_slave[i] = false;
< 
< 	// If we are here it means we are not available
< 	assert(masterThread.is_searching);
< 
< 	int workersCnt = 1; // At least the master is included
< 
< 	// Try to allocate available threads and ask them to start searching setting
< 	// the state to Thread::WORKISWAITING, this must be done under lock protection
< 	// to avoid concurrent allocation of the same slave by another master.
< 	lock_grab(&threadsLock);
< 
< 	for (i = 0; !Fake && i < activeThreads && workersCnt < maxThreadsPerSplitPoint; i++)
< 		if (i != master && threads[i].is_available_to(master))
< 		{
< 			workersCnt++;
< 			sp->is_slave[i] = true;
< 			threads[i].splitPoint = sp;
< 
< 			// This makes the slave to exit from idle_loop()
< 			threads[i].is_searching = true;
< 
< 			if (useSleepingThreads)
< 				threads[i].wake_up();
< 		}
< 
< 	lock_release(&threadsLock);
< 
< 	// We failed to allocate even one slave, return
< 	if (!Fake && workersCnt == 1)
< 		return bestValue;
< 
< 	masterThread.splitPoint = sp;
< 	masterThread.activeSplitPoints++;
< 
< 	// Everything is set up. The master thread enters the idle loop, from which
< 	// it will instantly launch a search, because its is_searching flag is set.
< 	// We pass the split point as a parameter to the idle loop, which means that
< 	// the thread will return from the idle loop when all slaves have finished
< 	// their work at this split point.
< 	masterThread.idle_loop(sp);
< 
< 	// In helpful master concept a master can help only a sub-tree, and
< 	// because here is all finished is not possible master is booked.
< 	assert(!masterThread.is_searching);
< 
< 	// We have returned from the idle loop, which means that all threads are
< 	// finished. Note that changing state and decreasing activeSplitPoints is done
< 	// under lock protection to avoid a race with Thread::is_available_to().
< 	lock_grab(&threadsLock);
< 
< 	masterThread.is_searching = true;
< 	masterThread.activeSplitPoints--;
< 
< 	lock_release(&threadsLock);
< 
< 	masterThread.splitPoint = sp->parent;
< 	pos.set_nodes_searched(pos.nodes_searched() + sp->nodes);
---
> void ThreadsManager::split(Position& pos, SearchStack* ss, Value* alpha, const Value beta,
>                            Value* bestValue, Depth depth, Move threatMove,
>                            int moveCount, MovePicker* mp, bool pvNode) {
>   assert(pos.is_ok());
>   assert(*bestValue >= -VALUE_INFINITE);
>   assert(*bestValue <= *alpha);
>   assert(*alpha < beta);
>   assert(beta <= VALUE_INFINITE);
>   assert(depth > DEPTH_ZERO);
>   assert(pos.thread() >= 0 && pos.thread() < activeThreads);
>   assert(activeThreads > 1);
> 
>   int i, master = pos.thread();
>   Thread& masterThread = threads[master];
> 
>   lock_grab(&mpLock);
> 
>   // If no other thread is available to help us, or if we have too many
>   // active split points, don't split.
>   if (   !available_slave_exists(master)
>       || masterThread.activeSplitPoints >= MAX_ACTIVE_SPLIT_POINTS)
>   {
>       lock_release(&mpLock);
>       return;
>   }
> 
>   // Pick the next available split point object from the split point stack
>   SplitPoint& splitPoint = masterThread.splitPoints[masterThread.activeSplitPoints++];
> 
>   // Initialize the split point object
>   splitPoint.parent = masterThread.splitPoint;
>   splitPoint.master = master;
>   splitPoint.is_betaCutoff = false;
>   splitPoint.depth = depth;
>   splitPoint.threatMove = threatMove;
>   splitPoint.alpha = *alpha;
>   splitPoint.beta = beta;
>   splitPoint.pvNode = pvNode;
>   splitPoint.bestValue = *bestValue;
>   splitPoint.mp = mp;
>   splitPoint.moveCount = moveCount;
>   splitPoint.pos = &pos;
>   splitPoint.nodes = 0;
>   splitPoint.ss = ss;
>   for (i = 0; i < activeThreads; i++)
>       splitPoint.is_slave[i] = false;
> 
>   masterThread.splitPoint = &splitPoint;
> 
>   // If we are here it means we are not available
>   assert(masterThread.state != Thread::AVAILABLE);
> 
>   int workersCnt = 1; // At least the master is included
> 
>   // Allocate available threads setting state to THREAD_BOOKED
>   for (i = 0; !Fake && i < activeThreads && workersCnt < maxThreadsPerSplitPoint; i++)
>       if (i != master && threads[i].is_available_to(master))
>       {
>           threads[i].state = Thread::BOOKED;
>           threads[i].splitPoint = &splitPoint;
>           splitPoint.is_slave[i] = true;
>           workersCnt++;
>       }
> 
>   assert(Fake || workersCnt > 1);
> 
>   // We can release the lock because slave threads are already booked and master is not available
>   lock_release(&mpLock);
> 
>   // Tell the threads that they have work to do. This will make them leave
>   // their idle loop.
>   for (i = 0; i < activeThreads; i++)
>       if (i == master || splitPoint.is_slave[i])
>       {
>           assert(i == master || threads[i].state == Thread::BOOKED);
> 
>           threads[i].state = Thread::WORKISWAITING; // This makes the slave to exit from idle_loop()
> 
>           if (useSleepingThreads && i != master)
>               threads[i].wake_up();
>       }
> 
>   // Everything is set up. The master thread enters the idle loop, from
>   // which it will instantly launch a search, because its state is
>   // THREAD_WORKISWAITING.  We send the split point as a second parameter to the
>   // idle loop, which means that the main thread will return from the idle
>   // loop when all threads have finished their work at this split point.
>   idle_loop(master, &splitPoint);
> 
>   // We have returned from the idle loop, which means that all threads are
>   // finished. Update alpha and bestValue, and return.
>   lock_grab(&mpLock);
> 
>   *alpha = splitPoint.alpha;
>   *bestValue = splitPoint.bestValue;
>   masterThread.activeSplitPoints--;
>   masterThread.splitPoint = splitPoint.parent;
>   pos.set_nodes_searched(pos.nodes_searched() + splitPoint.nodes);
364c340
< 	return sp->bestValue;
---
>   lock_release(&mpLock);
368,369c344,345
< template Value ThreadsManager::split<false>(Position&, SearchStack*, Value, Value, Value, Depth, Move, int, MovePicker*, int);
< template Value ThreadsManager::split<true>(Position&, SearchStack*, Value, Value, Value, Depth, Move, int, MovePicker*, int);
---
> template void ThreadsManager::split<false>(Position&, SearchStack*, Value*, const Value, Value*, Depth, Move, int, MovePicker*, bool);
> template void ThreadsManager::split<true>(Position&, SearchStack*, Value*, const Value, Value*, Depth, Move, int, MovePicker*, bool);
########################## timeman.cpp
2c2
<   NanohaMini, a USI shogi(japanese-chess) playing engine derived from Stockfish 2.1
---
>   Stockfish, a UCI chess playing engine derived from Glaurung 2.1
4,5c4
<   Copyright (C) 2008-2010 Marco Costalba, Joona Kiiski, Tord Romstad (Stockfish author)
<   Copyright (C) 2014 Kazuyuki Kawabata
---
>   Copyright (C) 2008-2010 Marco Costalba, Joona Kiiski, Tord Romstad
7c6
<   NanohaMini is free software: you can redistribute it and/or modify
---
>   Stockfish is free software: you can redistribute it and/or modify
12c11
<   NanohaMini is distributed in the hope that it will be useful,
---
>   Stockfish is distributed in the hope that it will be useful,
30c29
< 	/// Constants
---
>   /// Constants
32,72c31,67
< #if defined(NANOHA)
< 	const int MoveHorizon  = 60;    // Plan time management at most this many moves ahead
< #else
< 	const int MoveHorizon  = 50;    // Plan time management at most this many moves ahead
< #endif
< 	const float MaxRatio   = 3.0f;  // When in trouble, we can step over reserved time with this ratio
< 	const float StealRatio = 0.33f; // However we must not steal time from remaining moves over this ratio
< 
< 
< 	// MoveImportance[] is based on naive statistical analysis of "how many games are still undecided
< 	// after n half-moves". Game is considered "undecided" as long as neither side has >275cp advantage.
< 	// Data was extracted from CCRL game database with some simple filtering criteria.
< 	const int MoveImportance[512] = {
< 	  7780, 7780, 7780, 7780, 7780, 7780, 7780, 7780, 7780, 7780, 7780, 7780, 7780, 7780, 7780, 7780,
< 	  7780, 7780, 7780, 7780, 7778, 7778, 7776, 7776, 7776, 7773, 7770, 7768, 7766, 7763, 7757, 7751,
< 	  7743, 7735, 7724, 7713, 7696, 7689, 7670, 7656, 7627, 7605, 7571, 7549, 7522, 7493, 7462, 7425,
< 	  7385, 7350, 7308, 7272, 7230, 7180, 7139, 7094, 7055, 7010, 6959, 6902, 6841, 6778, 6705, 6651,
< 	  6569, 6508, 6435, 6378, 6323, 6253, 6152, 6085, 5995, 5931, 5859, 5794, 5717, 5646, 5544, 5462,
< 	  5364, 5282, 5172, 5078, 4988, 4901, 4831, 4764, 4688, 4609, 4536, 4443, 4365, 4293, 4225, 4155,
< 	  4085, 4005, 3927, 3844, 3765, 3693, 3634, 3560, 3479, 3404, 3331, 3268, 3207, 3146, 3077, 3011,
< 	  2947, 2894, 2828, 2776, 2727, 2676, 2626, 2589, 2538, 2490, 2442, 2394, 2345, 2302, 2243, 2192,
< 	  2156, 2115, 2078, 2043, 2004, 1967, 1922, 1893, 1845, 1809, 1772, 1736, 1702, 1674, 1640, 1605,
< 	  1566, 1536, 1509, 1479, 1452, 1423, 1388, 1362, 1332, 1304, 1289, 1266, 1250, 1228, 1206, 1180,
< 	  1160, 1134, 1118, 1100, 1080, 1068, 1051, 1034, 1012, 1001, 980, 960, 945, 934, 916, 900, 888,
< 	  878, 865, 852, 828, 807, 787, 770, 753, 744, 731, 722, 706, 700, 683, 676, 671, 664, 652, 641,
< 	  634, 627, 613, 604, 591, 582, 568, 560, 552, 540, 534, 529, 519, 509, 495, 484, 474, 467, 460,
< 	  450, 438, 427, 419, 410, 406, 399, 394, 387, 382, 377, 372, 366, 359, 353, 348, 343, 337, 333,
< 	  328, 321, 315, 309, 303, 298, 293, 287, 284, 281, 277, 273, 265, 261, 255, 251, 247, 241, 240,
< 	  235, 229, 218, 217, 213, 212, 208, 206, 197, 193, 191, 189, 185, 184, 180, 177, 172, 170, 170,
< 	  170, 166, 163, 159, 158, 156, 155, 151, 146, 141, 138, 136, 132, 130, 128, 125, 123, 122, 118,
< 	  118, 118, 117, 115, 114, 108, 107, 105, 105, 105, 102, 97, 97, 95, 94, 93, 91, 88, 86, 83, 80,
< 	  80, 79, 79, 79, 78, 76, 75, 72, 72, 71, 70, 68, 65, 63, 61, 61, 59, 59, 59, 58, 56, 55, 54, 54,
< 	  52, 49, 48, 48, 48, 48, 45, 45, 45, 44, 43, 41, 41, 41, 41, 40, 40, 38, 37, 36, 34, 34, 34, 33,
< 	  31, 29, 29, 29, 28, 28, 28, 28, 28, 28, 28, 27, 27, 27, 27, 27, 24, 24, 23, 23, 22, 21, 20, 20,
< 	  19, 19, 19, 19, 19, 18, 18, 18, 18, 17, 17, 17, 17, 17, 16, 16, 15, 15, 14, 14, 14, 12, 12, 11,
< 	  9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
< 	  8, 8, 8, 8, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
< 	  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 2, 2, 2, 2,
< 	  2, 1, 1, 1, 1, 1, 1, 1 };
< 
< 	int move_importance(int ply) { return MoveImportance[Min(ply, 511)]; }
---
>   const int MoveHorizon  = 50;    // Plan time management at most this many moves ahead
>   const float MaxRatio   = 3.0f;  // When in trouble, we can step over reserved time with this ratio
>   const float StealRatio = 0.33f; // However we must not steal time from remaining moves over this ratio
> 
> 
>   // MoveImportance[] is based on naive statistical analysis of "how many games are still undecided
>   // after n half-moves". Game is considered "undecided" as long as neither side has >275cp advantage.
>   // Data was extracted from CCRL game database with some simple filtering criteria.
>   const int MoveImportance[512] = {
>     7780, 7780, 7780, 7780, 7780, 7780, 7780, 7780, 7780, 7780, 7780, 7780, 7780, 7780, 7780, 7780,
>     7780, 7780, 7780, 7780, 7778, 7778, 7776, 7776, 7776, 7773, 7770, 7768, 7766, 7763, 7757, 7751,
>     7743, 7735, 7724, 7713, 7696, 7689, 7670, 7656, 7627, 7605, 7571, 7549, 7522, 7493, 7462, 7425,
>     7385, 7350, 7308, 7272, 7230, 7180, 7139, 7094, 7055, 7010, 6959, 6902, 6841, 6778, 6705, 6651,
>     6569, 6508, 6435, 6378, 6323, 6253, 6152, 6085, 5995, 5931, 5859, 5794, 5717, 5646, 5544, 5462,
>     5364, 5282, 5172, 5078, 4988, 4901, 4831, 4764, 4688, 4609, 4536, 4443, 4365, 4293, 4225, 4155,
>     4085, 4005, 3927, 3844, 3765, 3693, 3634, 3560, 3479, 3404, 3331, 3268, 3207, 3146, 3077, 3011,
>     2947, 2894, 2828, 2776, 2727, 2676, 2626, 2589, 2538, 2490, 2442, 2394, 2345, 2302, 2243, 2192,
>     2156, 2115, 2078, 2043, 2004, 1967, 1922, 1893, 1845, 1809, 1772, 1736, 1702, 1674, 1640, 1605,
>     1566, 1536, 1509, 1479, 1452, 1423, 1388, 1362, 1332, 1304, 1289, 1266, 1250, 1228, 1206, 1180,
>     1160, 1134, 1118, 1100, 1080, 1068, 1051, 1034, 1012, 1001, 980, 960, 945, 934, 916, 900, 888,
>     878, 865, 852, 828, 807, 787, 770, 753, 744, 731, 722, 706, 700, 683, 676, 671, 664, 652, 641,
>     634, 627, 613, 604, 591, 582, 568, 560, 552, 540, 534, 529, 519, 509, 495, 484, 474, 467, 460,
>     450, 438, 427, 419, 410, 406, 399, 394, 387, 382, 377, 372, 366, 359, 353, 348, 343, 337, 333,
>     328, 321, 315, 309, 303, 298, 293, 287, 284, 281, 277, 273, 265, 261, 255, 251, 247, 241, 240,
>     235, 229, 218, 217, 213, 212, 208, 206, 197, 193, 191, 189, 185, 184, 180, 177, 172, 170, 170,
>     170, 166, 163, 159, 158, 156, 155, 151, 146, 141, 138, 136, 132, 130, 128, 125, 123, 122, 118,
>     118, 118, 117, 115, 114, 108, 107, 105, 105, 105, 102, 97, 97, 95, 94, 93, 91, 88, 86, 83, 80,
>     80, 79, 79, 79, 78, 76, 75, 72, 72, 71, 70, 68, 65, 63, 61, 61, 59, 59, 59, 58, 56, 55, 54, 54,
>     52, 49, 48, 48, 48, 48, 45, 45, 45, 44, 43, 41, 41, 41, 41, 40, 40, 38, 37, 36, 34, 34, 34, 33,
>     31, 29, 29, 29, 28, 28, 28, 28, 28, 28, 28, 27, 27, 27, 27, 27, 24, 24, 23, 23, 22, 21, 20, 20,
>     19, 19, 19, 19, 19, 18, 18, 18, 18, 17, 17, 17, 17, 17, 16, 16, 15, 15, 14, 14, 14, 12, 12, 11,
>     9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
>     8, 8, 8, 8, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
>     4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 2, 2, 2, 2,
>     2, 1, 1, 1, 1, 1, 1, 1 };
> 
>   int move_importance(int ply) { return MoveImportance[Min(ply, 511)]; }
75c70
< 	/// Function Prototypes
---
>   /// Function Prototypes
77c72
< 	enum TimeType { OptimumTime, MaxTime };
---
>   enum TimeType { OptimumTime, MaxTime };
79,80c74,75
< 	template<TimeType>
< 	int remaining(int myTime, int movesToGo, int currentPly);
---
>   template<TimeType>
>   int remaining(int myTime, int movesToGo, int currentPly);
86,87c81,82
< 	unstablePVExtraTime =  curChanges  * (optimumSearchTime / 2)
< 	                     + prevChanges * (optimumSearchTime / 3);
---
>     unstablePVExtraTime =  curChanges  * (optimumSearchTime / 2)
>                          + prevChanges * (optimumSearchTime / 3);
93c88
< 	/* We support four different kind of time controls:
---
>   /* We support four different kind of time controls:
95,137c90,132
< 	    increment == 0 && movesToGo == 0 means: x basetime  [sudden death!]
< 	    increment == 0 && movesToGo != 0 means: x moves in y minutes
< 	    increment >  0 && movesToGo == 0 means: x basetime + z increment
< 	    increment >  0 && movesToGo != 0 means: x moves in y minutes + z increment
< 
< 	  Time management is adjusted by following UCI parameters:
< 
< 	    emergencyMoveHorizon: Be prepared to always play at least this many moves
< 	    emergencyBaseTime   : Always attempt to keep at least this much time (in ms) at clock
< 	    emergencyMoveTime   : Plus attempt to keep at least this much time for each remaining emergency move
< 	    minThinkingTime     : No matter what, use at least this much thinking before doing the move
< 	*/
< 
< 	int hypMTG, hypMyTime, t1, t2;
< 
< 	// Read uci parameters
< 	int emergencyMoveHorizon = Options["Emergency Move Horizon"].value<int>();
< 	int emergencyBaseTime    = Options["Emergency Base Time"].value<int>();
< 	int emergencyMoveTime    = Options["Emergency Move Time"].value<int>();
< 	int minThinkingTime      = Options["Minimum Thinking Time"].value<int>();
< 
< 	// Initialize to maximum values but unstablePVExtraTime that is reset
< 	unstablePVExtraTime = 0;
< 	optimumSearchTime = maximumSearchTime = limits.time;
< 
< 	// We calculate optimum time usage for different hypothetic "moves to go"-values and choose the
< 	// minimum of calculated search time values. Usually the greatest hypMTG gives the minimum values.
< 	for (hypMTG = 1; hypMTG <= (limits.movesToGo ? Min(limits.movesToGo, MoveHorizon) : MoveHorizon); hypMTG++)
< 	{
< 		// Calculate thinking time for hypothetic "moves to go"-value
< 		hypMyTime =  limits.time
< 		           + limits.increment * (hypMTG - 1)
< 		           - emergencyBaseTime
< 		           - emergencyMoveTime * Min(hypMTG, emergencyMoveHorizon);
< 
< 		hypMyTime = Max(hypMyTime, 0);
< 
< 		t1 = minThinkingTime + remaining<OptimumTime>(hypMyTime, hypMTG, currentPly);
< 		t2 = minThinkingTime + remaining<MaxTime>(hypMyTime, hypMTG, currentPly);
< 
< 		optimumSearchTime = Min(optimumSearchTime, t1);
< 		maximumSearchTime = Min(maximumSearchTime, t2);
< 	}
---
>       increment == 0 && movesToGo == 0 means: x basetime  [sudden death!]
>       increment == 0 && movesToGo != 0 means: x moves in y minutes
>       increment >  0 && movesToGo == 0 means: x basetime + z increment
>       increment >  0 && movesToGo != 0 means: x moves in y minutes + z increment
> 
>     Time management is adjusted by following UCI parameters:
> 
>       emergencyMoveHorizon: Be prepared to always play at least this many moves
>       emergencyBaseTime   : Always attempt to keep at least this much time (in ms) at clock
>       emergencyMoveTime   : Plus attempt to keep at least this much time for each remaining emergency move
>       minThinkingTime     : No matter what, use at least this much thinking before doing the move
>   */
> 
>   int hypMTG, hypMyTime, t1, t2;
> 
>   // Read uci parameters
>   int emergencyMoveHorizon = Options["Emergency Move Horizon"].value<int>();
>   int emergencyBaseTime    = Options["Emergency Base Time"].value<int>();
>   int emergencyMoveTime    = Options["Emergency Move Time"].value<int>();
>   int minThinkingTime      = Options["Minimum Thinking Time"].value<int>();
> 
>   // Initialize to maximum values but unstablePVExtraTime that is reset
>   unstablePVExtraTime = 0;
>   optimumSearchTime = maximumSearchTime = limits.time;
> 
>   // We calculate optimum time usage for different hypothetic "moves to go"-values and choose the
>   // minimum of calculated search time values. Usually the greatest hypMTG gives the minimum values.
>   for (hypMTG = 1; hypMTG <= (limits.movesToGo ? Min(limits.movesToGo, MoveHorizon) : MoveHorizon); hypMTG++)
>   {
>       // Calculate thinking time for hypothetic "moves to go"-value
>       hypMyTime =  limits.time
>                  + limits.increment * (hypMTG - 1)
>                  - emergencyBaseTime
>                  - emergencyMoveTime * Min(hypMTG, emergencyMoveHorizon);
> 
>       hypMyTime = Max(hypMyTime, 0);
> 
>       t1 = minThinkingTime + remaining<OptimumTime>(hypMyTime, hypMTG, currentPly);
>       t2 = minThinkingTime + remaining<MaxTime>(hypMyTime, hypMTG, currentPly);
> 
>       optimumSearchTime = Min(optimumSearchTime, t1);
>       maximumSearchTime = Min(maximumSearchTime, t2);
>   }
139,140c134,135
< 	if (Options["Ponder"].value<bool>())
< 		optimumSearchTime += optimumSearchTime / 4;
---
>   if (Options["Ponder"].value<bool>())
>       optimumSearchTime += optimumSearchTime / 4;
142,143c137,138
< 	// Make sure that maxSearchTime is not over absoluteMaxSearchTime
< 	optimumSearchTime = Min(optimumSearchTime, maximumSearchTime);
---
>   // Make sure that maxSearchTime is not over absoluteMaxSearchTime
>   optimumSearchTime = Min(optimumSearchTime, maximumSearchTime);
149,156c144,151
< 	template<TimeType T>
< 	int remaining(int myTime, int movesToGo, int currentPly)
< 	{
< 		const float TMaxRatio   = (T == OptimumTime ? 1 : MaxRatio);
< 		const float TStealRatio = (T == OptimumTime ? 0 : StealRatio);
< 
< 		int thisMoveImportance = move_importance(currentPly);
< 		int otherMovesImportance = 0;
---
>   template<TimeType T>
>   int remaining(int myTime, int movesToGo, int currentPly)
>   {
>     const float TMaxRatio   = (T == OptimumTime ? 1 : MaxRatio);
>     const float TStealRatio = (T == OptimumTime ? 0 : StealRatio);
> 
>     int thisMoveImportance = move_importance(currentPly);
>     int otherMovesImportance = 0;
158,159c153,154
< 		for (int i = 1; i < movesToGo; i++)
< 			otherMovesImportance += move_importance(currentPly + 2 * i);
---
>     for (int i = 1; i < movesToGo; i++)
>         otherMovesImportance += move_importance(currentPly + 2 * i);
161,162c156,157
< 		float ratio1 = (TMaxRatio * thisMoveImportance) / float(TMaxRatio * thisMoveImportance + otherMovesImportance);
< 		float ratio2 = (thisMoveImportance + TStealRatio * otherMovesImportance) / float(thisMoveImportance + otherMovesImportance);
---
>     float ratio1 = (TMaxRatio * thisMoveImportance) / float(TMaxRatio * thisMoveImportance + otherMovesImportance);
>     float ratio2 = (thisMoveImportance + TStealRatio * otherMovesImportance) / float(thisMoveImportance + otherMovesImportance);
164,165c159,160
< 		return int(floor(myTime * Min(ratio1, ratio2)));
< 	}
---
>     return int(floor(myTime * Min(ratio1, ratio2)));
>   }
########################## tt.cpp
2c2
<   NanohaMini, a USI shogi(japanese-chess) playing engine derived from Stockfish 2.1
---
>   Stockfish, a UCI chess playing engine derived from Glaurung 2.1
4,5c4
<   Copyright (C) 2008-2010 Marco Costalba, Joona Kiiski, Tord Romstad (Stockfish author)
<   Copyright (C) 2014 Kazuyuki Kawabata
---
>   Copyright (C) 2008-2010 Marco Costalba, Joona Kiiski, Tord Romstad
7c6
<   NanohaMini is free software: you can redistribute it and/or modify
---
>   Stockfish is free software: you can redistribute it and/or modify
12c11
<   NanohaMini is distributed in the hope that it will be useful,
---
>   Stockfish is distributed in the hope that it will be useful,
20a20
> #include <cassert>
30,31c30,31
< 	size = generation = 0;
< 	entries = NULL;
---
>   size = generation = 0;
>   entries = NULL;
36c36
< 	delete [] entries;
---
>   delete [] entries;
45c45
< 	size_t newSize = 1024;
---
>   size_t newSize = 1024;
47,66c47,66
< 	// Transposition table consists of clusters and each cluster consists
< 	// of ClusterSize number of TTEntries. Each non-empty entry contains
< 	// information of exactly one position and newSize is the number of
< 	// clusters we are going to allocate.
< 	while (2ULL * newSize * sizeof(TTCluster) <= (mbSize << 20))
< 		newSize *= 2;
< 
< 	if (newSize == size)
< 		return;
< 
< 	size = newSize;
< 	delete [] entries;
< 	entries = new (std::nothrow) TTCluster[size];
< 	if (!entries)
< 	{
< 		std::cerr << "Failed to allocate " << mbSize
< 		          << "MB for transposition table." << std::endl;
< 		exit(EXIT_FAILURE);
< 	}
< 	clear();
---
>   // Transposition table consists of clusters and each cluster consists
>   // of ClusterSize number of TTEntries. Each non-empty entry contains
>   // information of exactly one position and newSize is the number of
>   // clusters we are going to allocate.
>   while (2ULL * newSize * sizeof(TTCluster) <= (mbSize << 20))
>       newSize *= 2;
> 
>   if (newSize == size)
>       return;
> 
>   size = newSize;
>   delete [] entries;
>   entries = new (std::nothrow) TTCluster[size];
>   if (!entries)
>   {
>       std::cerr << "Failed to allocate " << mbSize
>                 << " MB for transposition table." << std::endl;
>       exit(EXIT_FAILURE);
>   }
>   clear();
76c76
< 	memset(entries, 0, size * sizeof(TTCluster));
---
>   memset(entries, 0, size * sizeof(TTCluster));
88,90d87
< #if defined(NANOHA)
< void TranspositionTable::store(const Key posKey, uint32_t h, Value v, ValueType t, Depth d, Move m, Value statV, Value kingD) {
< #else
92,135c89,116
< #endif
< 	int c1, c2, c3;
< 	TTEntry *tte, *replace;
< #if defined(NANOHA)
< 	uint64_t posKey48 = (posKey & ~UINT64_C(0xFFFF)); // Use the high 48 bits as key inside the cluster
< #else
< 	uint32_t posKey32 = posKey >> 32; // Use the high 32 bits as key inside the cluster
< #endif
< 
< 	tte = replace = first_entry(posKey);
< 
< 	for (int i = 0; i < ClusterSize; i++, tte++)
< 	{
< #if defined(NANOHA)
< 		if (!tte->key() || (tte->key() == posKey48 && tte->hand() == h)) // Empty or overwrite old
< #else
< 		if (!tte->key() || tte->key() == posKey32) // Empty or overwrite old
< #endif
< 		{
< 			// Preserve any existing ttMove
< 			if (m == MOVE_NONE)
< 				m = tte->move();
< 
< #if defined(NANOHA)
< 			tte->save(posKey48, h, v, t, d, m, generation, statV, kingD);
< #else
< 			tte->save(posKey32, v, t, d, m, generation, statV, kingD);
< #endif
< 			return;
< 		}
< 
< 		// Implement replace strategy
< 		c1 = (replace->generation() == generation ?  2 : 0);
< 		c2 = (tte->generation() == generation || tte->type() == VALUE_TYPE_EXACT ? -2 : 0);
< 		c3 = (tte->depth() < replace->depth() ?  1 : 0);
< 
< 		if (c1 + c2 + c3 > 0)
< 			replace = tte;
< 	}
< #if defined(NANOHA)
< 	replace->save(posKey48, h, v, t, d, m, generation, statV, kingD);
< #else
< 	replace->save(posKey32, v, t, d, m, generation, statV, kingD);
< #endif
---
> 
>   int c1, c2, c3;
>   TTEntry *tte, *replace;
>   uint32_t posKey32 = posKey >> 32; // Use the high 32 bits as key inside the cluster
> 
>   tte = replace = first_entry(posKey);
> 
>   for (int i = 0; i < ClusterSize; i++, tte++)
>   {
>       if (!tte->key() || tte->key() == posKey32) // Empty or overwrite old
>       {
>           // Preserve any existing ttMove
>           if (m == MOVE_NONE)
>               m = tte->move();
> 
>           tte->save(posKey32, v, t, d, m, generation, statV, kingD);
>           return;
>       }
> 
>       // Implement replace strategy
>       c1 = (replace->generation() == generation ?  2 : 0);
>       c2 = (tte->generation() == generation || tte->type() == VALUE_TYPE_EXACT ? -2 : 0);
>       c3 = (tte->depth() < replace->depth() ?  1 : 0);
> 
>       if (c1 + c2 + c3 > 0)
>           replace = tte;
>   }
>   replace->save(posKey32, v, t, d, m, generation, statV, kingD);
143,151d123
< #if defined(NANOHA)
< TTEntry* TranspositionTable::probe(const Key posKey, uint32_t h) const {
< 	uint64_t posKey48 = (posKey & ~UINT64_C(0xFFFF));
< 	TTEntry* tte = first_entry(posKey);
< 
< 	for (int i = 0; i < ClusterSize; i++, tte++)
< 		if (tte->key() == posKey48 && tte->hand() == h)
< 			return tte;
< #else
153,154d124
< 	uint32_t posKey32 = posKey >> 32;
< 	TTEntry* tte = first_entry(posKey);
156,159c126,131
< 	for (int i = 0; i < ClusterSize; i++, tte++)
< 		if (tte->key() == posKey32)
< 			return tte;
< #endif
---
>   uint32_t posKey32 = posKey >> 32;
>   TTEntry* tte = first_entry(posKey);
> 
>   for (int i = 0; i < ClusterSize; i++, tte++)
>       if (tte->key() == posKey32)
>           return tte;
161c133
< 	return NULL;
---
>   return NULL;
171c143
< 	generation++;
---
>   generation++;
########################## uci.cpp
2c2
<   NanohaMini, a USI shogi(japanese-chess) playing engine derived from Stockfish 2.1
---
>   Stockfish, a UCI chess playing engine derived from Glaurung 2.1
4,5c4
<   Copyright (C) 2008-2010 Marco Costalba, Joona Kiiski, Tord Romstad (Stockfish author)
<   Copyright (C) 2014 Kazuyuki Kawabata
---
>   Copyright (C) 2008-2010 Marco Costalba, Joona Kiiski, Tord Romstad
7c6
<   NanohaMini is free software: you can redistribute it and/or modify
---
>   Stockfish is free software: you can redistribute it and/or modify
12c11
<   NanohaMini is distributed in the hope that it will be useful,
---
>   Stockfish is distributed in the hope that it will be useful,
25d23
< #include <vector>
38,53c36,46
< 	// FEN string for the initial position
< #if defined(NANOHA)
< 	const char* StarFEN = "lnsgkgsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL b - 1";
< #else
< 	const char* StarFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
< #endif
< 
< 	// Keep track of position keys along the setup moves (from start position to the
< 	// position just before to start searching). This is needed by draw detection
< 	// where, due to 50 moves rule, we need to check at most 100 plies back.
< 	StateInfo StateRingBuf[102], *SetupState = StateRingBuf;
< 
< 	void set_option(istringstream& up);
< 	void set_position(Position& pos, istringstream& up);
< 	bool go(Position& pos, istringstream& up);
< 	void perft(Position& pos, istringstream& up);
---
>   // FEN string for the initial position
>   const string StartPositionFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
> 
>   // UCIParser is a class for parsing UCI input. The class
>   // is actually a string stream built on a given input string.
>   typedef istringstream UCIParser;
> 
>   void set_option(UCIParser& up);
>   void set_position(Position& pos, UCIParser& up);
>   bool go(Position& pos, UCIParser& up);
>   void perft(Position& pos, UCIParser& up);
57,159c50,110
< /// Wait for a command from the user, parse this text string as an UCI command,
< /// and calls the appropriate functions. Also intercepts EOF from stdin to
< /// ensure that we exit gracefully if the GUI dies unexpectedly. In addition to
< /// the UCI commands, the function also supports a few debug commands.
< 
< void uci_loop() {
< 
< #if defined(NANOHA)
< 	Position pos(StarFEN, 0); // The root position
< #else
< 	Position pos(StarFEN, false, 0); // The root position
< #endif
< 	string cmd, token;
< 	bool quit = false;
< 
< 	while (!quit && getline(cin, cmd))
< 	{
< 		istringstream is(cmd);
< 
< 		is >> skipws >> token;
< 
< 		if (token == "quit")
< 			quit = true;
< 
< 		else if (token == "go")
< 			quit = !go(pos, is);
< 
< #if defined(NANOHA)
< 		else if (token == "usinewgame")
< 			pos.from_fen(StarFEN);
< #else
< 		else if (token == "ucinewgame")
< 			pos.from_fen(StarFEN, false);
< #endif
< 
< #if defined(NANOHA)
< 		else if (token == "isready") {
< 			// TODO:本来は時間がかかる初期化をここで行う.
< 			cout << "readyok" << endl;
< 		}
< #else
< 		else if (token == "isready")
< 			cout << "readyok" << endl;
< #endif
< 
< 		else if (token == "position")
< 			set_position(pos, is);
< 
< 		else if (token == "setoption")
< 			set_option(is);
< 
< 		else if (token == "perft")
< 			perft(pos, is);
< 
< 		else if (token == "d")
< 			pos.print();
< 
< #if !defined(NANOHA)
< 		else if (token == "flip")
< 			pos.flip_me();
< #endif
< 
< #if !defined(NANOHA)
< 		else if (token == "eval")
< 		{
< 			read_evaluation_uci_options(pos.side_to_move());
< 			cout << trace_evaluate(pos) << endl;
< 		}
< #endif
< 		else if (token == "key")
< #if defined(NANOHA)
< 			cout << "key: " << hex     << pos.get_key() << dec << endl;
< #else
< 			cout << "key: " << hex     << pos.get_key()
< 			     << "\nmaterial key: " << pos.get_material_key()
< 			     << "\npawn key: "     << pos.get_pawn_key() << endl;
< #endif
< 
< #if defined(NANOHA)
< 		else if (token == "usi")
< #else
< 		else if (token == "uci")
< #endif
< 			cout << "id name "     << engine_name()
< 			     << "\nid author " << engine_authors()
< #if defined(NANOHA)
< 			     << Options.print_all()
< 			     << "\nusiok"      << endl;
< #else
< 			     << "\n"           << Options.print_all()
< 			     << "\nuciok"      << endl;
< #endif
< #if defined(NANOHA)
< 		else if (token == "stop"){
< 		}
< 		else if (token == "echo"){
< 			is >> token;
< 			cout << token << endl;
< 		}
< #endif
< 		else
< 			cout << "Unknown command: " << cmd << endl;
< 	}
---
> /// execute_uci_command() takes a string as input, uses a UCIParser
> /// object to parse this text string as a UCI command, and calls
> /// the appropriate functions. In addition to the UCI commands,
> /// the function also supports a few debug commands.
> 
> bool execute_uci_command(const string& cmd) {
> 
>   static Position pos(StartPositionFEN, false, 0); // The root position
> 
>   UCIParser up(cmd);
>   string token;
> 
>   up >> token; // operator>>() skips any whitespace
> 
>   if (token == "quit")
>       return false;
> 
>   if (token == "go")
>       return go(pos, up);
> 
>   if (token == "ucinewgame")
>       pos.from_fen(StartPositionFEN, false);
> 
>   else if (token == "isready")
>       cout << "readyok" << endl;
> 
>   else if (token == "position")
>       set_position(pos, up);
> 
>   else if (token == "setoption")
>       set_option(up);
> 
>   else if (token == "perft")
>       perft(pos, up);
> 
>   else if (token == "d")
>       pos.print();
> 
>   else if (token == "flip")
>       pos.flip();
> 
>   else if (token == "eval")
>   {
>       read_evaluation_uci_options(pos.side_to_move());
>       cout << trace_evaluate(pos) << endl;
>   }
> 
>   else if (token == "key")
>       cout << "key: " << hex     << pos.get_key()
>            << "\nmaterial key: " << pos.get_material_key()
>            << "\npawn key: "     << pos.get_pawn_key() << endl;
> 
>   else if (token == "uci")
>       cout << "id name "     << engine_name()
>            << "\nid author " << engine_authors()
>            << "\n"           << Options.print_all()
>            << "\nuciok"      << endl;
>   else
>       cout << "Unknown command: " << cmd << endl;
> 
>   return true;
165,316c116,246
< 	// set_position() is called when engine receives the "position" UCI
< 	// command. The function sets up the position described in the given
< 	// fen string ("fen") or the starting position ("startpos") and then
< 	// makes the moves given in the following move list ("moves").
< 
< 	void set_position(Position& pos, istringstream& is) {
< 
< 		Move m;
< 		string token, fen;
< 
< 		is >> token;
< 
< 		if (token == "startpos")
< 		{
< 			fen = StarFEN;
< 			is >> token; // Consume "moves" token if any
< 		}
< #if defined(NANOHA)
< 		else if (token == "sfen")
< #else
< 		else if (token == "fen")
< #endif
< 			while (is >> token && token != "moves")
< 				fen += token + " ";
< 		else
< 			return;
< 
< #if defined(NANOHA)
< 		pos.from_fen(fen);
< #else
< 		pos.from_fen(fen, Options["UCI_Chess960"].value<bool>());
< #endif
< 
< 		// Parse move list (if any)
< 		while (is >> token && (m = move_from_uci(pos, token)) != MOVE_NONE)
< 		{
< 			pos.do_move(m, *SetupState);
< 
< 			// Increment pointer to StateRingBuf circular buffer
< 			if (++SetupState - StateRingBuf >= 102)
< 				SetupState = StateRingBuf;
< 		}
< 	}
< 
< 
< 	// set_option() is called when engine receives the "setoption" UCI
< 	// command. The function updates the corresponding UCI option ("name")
< 	// to the given value ("value").
< 
< 	void set_option(istringstream& is) {
< 
< 		string token, name, value;
< 
< 		is >> token; // Consume "name" token
< 
< 		// Read option name (can contain spaces)
< 		while (is >> token && token != "value")
< 			name += string(" ", !name.empty()) + token;
< 
< 		// Read option value (can contain spaces)
< 		while (is >> token)
< 			value += string(" ", !value.empty()) + token;
< 
< 		if (Options.find(name) != Options.end())
< 			Options[name].set_value(value.empty() ? "true" : value); // UCI buttons don't have "value"
< 		else
< 			cout << "No such option: " << name << endl;
< 	}
< 
< 
< 	// go() is called when engine receives the "go" UCI command. The
< 	// function sets the thinking time and other parameters from the input
< 	// string, and then calls think(). Returns false if a quit command
< 	// is received while thinking, true otherwise.
< 
< 	bool go(Position& pos, istringstream& is) {
< 
< 		string token;
< 		SearchLimits limits;
< 		std::vector<Move> searchMoves;
< 		int time[] = { 0, 0 }, inc[] = { 0, 0 };
< 
< 		while (is >> token)
< 		{
< 			if (token == "infinite")
< 				limits.infinite = true;
< 			else if (token == "ponder")
< 				limits.ponder = true;
< 			else if (token == "wtime")
< 				is >> time[WHITE];
< 			else if (token == "btime")
< 				is >> time[BLACK];
< 			else if (token == "winc")
< 				is >> inc[WHITE];
< 			else if (token == "binc")
< 				is >> inc[BLACK];
< 			else if (token == "movestogo")
< 				is >> limits.movesToGo;
< 			else if (token == "depth")
< 				is >> limits.maxDepth;
< 			else if (token == "nodes")
< 				is >> limits.maxNodes;
< #if defined(NANOHA)
< 			else if (token == "movetime" || token=="byoyomi") {
< 				is >> limits.maxTime;
< 				int mg = Options["ByoyomiMargin"].value<int>();
< 				if (limits.maxTime - 100 > mg) {
< 					limits.maxTime -= mg;
< 				}
< 			} else if (token == "mate") {
< 				std::cout << "checkmate notimplemented" << std::endl;
< 				return true;
< 			}
< #else
< 			else if (token == "movetime")
< 				is >> limits.maxTime;
< #endif
< 			else if (token == "searchmoves")
< 				while (is >> token)
< 					searchMoves.push_back(move_from_uci(pos, token));
< 		}
< 
< 		searchMoves.push_back(MOVE_NONE);
< 		limits.time = time[pos.side_to_move()];
< 		limits.increment = inc[pos.side_to_move()];
< 
< 		return think(pos, limits, &searchMoves[0]);
< 	}
< 
< 
< 	// perft() is called when engine receives the "perft" command.
< 	// The function calls perft() passing the required search depth
< 	// then prints counted leaf nodes and elapsed time.
< 
< 	void perft(Position& pos, istringstream& is) {
< 
< 		int depth, time;
< 		int64_t n;
< 
< 		if (!(is >> depth))
< 			return;
< 
< 		time = get_system_time();
< 
< 		n = perft(pos, depth * ONE_PLY);
< 
< 		time = get_system_time() - time;
< 
< 		std::cout << "\nNodes " << n
< 		          << "\nTime (ms) " << time
< 		          << "\nNodes/second " << int(n / (time / 1000.0)) << std::endl;
< 	}
---
>   // set_position() is called when engine receives the "position" UCI
>   // command. The function sets up the position described in the given
>   // fen string ("fen") or the starting position ("startpos") and then
>   // makes the moves given in the following move list ("moves").
> 
>   void set_position(Position& pos, UCIParser& up) {
> 
>     string token, fen;
> 
>     up >> token; // operator>>() skips any whitespace
> 
>     if (token == "startpos")
>     {
>         pos.from_fen(StartPositionFEN, false);
>         up >> token; // Consume "moves" token if any
>     }
>     else if (token == "fen")
>     {
>         while (up >> token && token != "moves")
>             fen += token + " ";
> 
>         pos.from_fen(fen, Options["UCI_Chess960"].value<bool>());
>     }
>     else return;
> 
>     // Parse move list (if any)
>     while (up >> token)
>         pos.do_setup_move(move_from_uci(pos, token));
>   }
> 
> 
>   // set_option() is called when engine receives the "setoption" UCI
>   // command. The function updates the corresponding UCI option ("name")
>   // to the given value ("value").
> 
>   void set_option(UCIParser& up) {
> 
>     string token, name;
>     string value = "true"; // UCI buttons don't have a "value" field
> 
>     up >> token; // Consume "name" token
>     up >> name;  // Read option name
> 
>     // Handle names with included spaces
>     while (up >> token && token != "value")
>         name += " " + token;
> 
>     up >> value; // Read option value
> 
>     // Handle values with included spaces
>     while (up >> token)
>         value += " " + token;
> 
>     if (Options.find(name) != Options.end())
>         Options[name].set_value(value);
>     else
>         cout << "No such option: " << name << endl;
>   }
> 
> 
>   // go() is called when engine receives the "go" UCI command. The
>   // function sets the thinking time and other parameters from the input
>   // string, and then calls think(). Returns false if a quit command
>   // is received while thinking, true otherwise.
> 
>   bool go(Position& pos, UCIParser& up) {
> 
>     string token;
>     SearchLimits limits;
>     Move searchMoves[MAX_MOVES], *cur = searchMoves;
>     int time[] = { 0, 0 }, inc[] = { 0, 0 };
> 
>     while (up >> token)
>     {
>         if (token == "infinite")
>             limits.infinite = true;
>         else if (token == "ponder")
>             limits.ponder = true;
>         else if (token == "wtime")
>             up >> time[WHITE];
>         else if (token == "btime")
>             up >> time[BLACK];
>         else if (token == "winc")
>             up >> inc[WHITE];
>         else if (token == "binc")
>             up >> inc[BLACK];
>         else if (token == "movestogo")
>             up >> limits.movesToGo;
>         else if (token == "depth")
>             up >> limits.maxDepth;
>         else if (token == "nodes")
>             up >> limits.maxNodes;
>         else if (token == "movetime")
>             up >> limits.maxTime;
>         else if (token == "searchmoves")
>             while (up >> token)
>                 *cur++ = move_from_uci(pos, token);
>     }
> 
>     *cur = MOVE_NONE;
>     limits.time = time[pos.side_to_move()];
>     limits.increment = inc[pos.side_to_move()];
> 
>     assert(pos.is_ok());
> 
>     return think(pos, limits, searchMoves);
>   }
> 
> 
>   // perft() is called when engine receives the "perft" command.
>   // The function calls perft() passing the required search depth
>   // then prints counted leaf nodes and elapsed time.
> 
>   void perft(Position& pos, UCIParser& up) {
> 
>     int depth, time;
>     int64_t n;
> 
>     if (!(up >> depth))
>         return;
> 
>     time = get_system_time();
> 
>     n = perft(pos, depth * ONE_PLY);
> 
>     time = get_system_time() - time;
> 
>     std::cout << "\nNodes " << n
>               << "\nTime (ms) " << time
>               << "\nNodes/second " << int(n / (time / 1000.0)) << std::endl;
>   }
########################## ucioption.cpp
2c2
<   NanohaMini, a USI shogi(japanese-chess) playing engine derived from Stockfish 2.1
---
>   Stockfish, a UCI chess playing engine derived from Glaurung 2.1
4,5c4
<   Copyright (C) 2008-2010 Marco Costalba, Joona Kiiski, Tord Romstad (Stockfish author)
<   Copyright (C) 2014 Kazuyuki Kawabata
---
>   Copyright (C) 2008-2010 Marco Costalba, Joona Kiiski, Tord Romstad
7c6
<   NanohaMini is free software: you can redistribute it and/or modify
---
>   Stockfish is free software: you can redistribute it and/or modify
12c11
<   NanohaMini is distributed in the hope that it will be useful,
---
>   Stockfish is distributed in the hope that it will be useful,
23a23
> 
38,39c38,39
< 	int c1, c2;
< 	size_t i = 0;
---
>   int c1, c2;
>   size_t i = 0;
41,49c41,49
< 	while (i < s1.size() && i < s2.size())
< 	{
< 		c1 = tolower(s1[i]);
< 		c2 = tolower(s2[i++]);
< 
< 		if (c1 != c2)
< 			return c1 < c2;
< 	}
< 	return s1.size() < s2.size();
---
>   while (i < s1.size() && i < s2.size())
>   {
>       c1 = tolower(s1[i]);
>       c2 = tolower(s2[i++]);
> 
>       if (c1 != c2)
>           return c1 < c2;
>   }
>   return s1.size() < s2.size();
57,59c57,59
< 	std::ostringstream ss;
< 	ss << v;
< 	return ss.str();
---
>   std::ostringstream ss;
>   ss << v;
>   return ss.str();
69c69,101
< 	OptionsMap& o = *this;
---
>   OptionsMap& o = *this;
> 
>   o["Use Search Log"] = UCIOption(false);
>   o["Search Log Filename"] = UCIOption("SearchLog.txt");
>   o["Book File"] = UCIOption("book.bin");
>   o["Best Book Move"] = UCIOption(false);
>   o["Mobility (Middle Game)"] = UCIOption(100, 0, 200);
>   o["Mobility (Endgame)"] = UCIOption(100, 0, 200);
>   o["Passed Pawns (Middle Game)"] = UCIOption(100, 0, 200);
>   o["Passed Pawns (Endgame)"] = UCIOption(100, 0, 200);
>   o["Space"] = UCIOption(100, 0, 200);
>   o["Aggressiveness"] = UCIOption(100, 0, 200);
>   o["Cowardice"] = UCIOption(100, 0, 200);
>   o["Minimum Split Depth"] = UCIOption(4, 4, 7);
>   o["Maximum Number of Threads per Split Point"] = UCIOption(5, 4, 8);
>   o["Threads"] = UCIOption(1, 1, MAX_THREADS);
>   o["Use Sleeping Threads"] = UCIOption(false);
>   o["Hash"] = UCIOption(32, 4, 8192);
>   o["Clear Hash"] = UCIOption(false, "button");
>   o["Ponder"] = UCIOption(true);
>   o["OwnBook"] = UCIOption(true);
>   o["MultiPV"] = UCIOption(1, 1, 500);
>   o["Skill Level"] = UCIOption(20, 0, 20);
>   o["Emergency Move Horizon"] = UCIOption(40, 0, 50);
>   o["Emergency Base Time"] = UCIOption(200, 0, 30000);
>   o["Emergency Move Time"] = UCIOption(70, 0, 5000);
>   o["Minimum Thinking Time"] = UCIOption(20, 0, 5000);
>   o["UCI_Chess960"] = UCIOption(false);
>   o["UCI_AnalyseMode"] = UCIOption(false);
> 
>   // Set some SMP parameters accordingly to the detected CPU count
>   UCIOption& thr = o["Threads"];
>   UCIOption& msd = o["Minimum Split Depth"];
71,119c103
< 	// 定跡
< 	o["OwnBook"] = UCIOption(true);
< 	o["RandomBookSelect"] = UCIOption(true);
< #if defined(NANOHA)
< 	o["BookFile"] = UCIOption("book_40.jsk");
< #else
< 	o["BookFile"] = UCIOption("book.bin");
< #endif
< #if defined(NANOHA)
< 	o["Ponder"] = UCIOption(false);
< #else
< 	o["Ponder"] = UCIOption(true);
< #endif
< 	o["Threads"] = UCIOption(1, 1, MAX_THREADS);
< 	o["Hash"] = UCIOption(256, 4, 1024);
< 
< 	o["Use Search Log"] = UCIOption(false);
< 	o["Search Log Filename"] = UCIOption("SearchLog.txt");
< 	o["Minimum Split Depth"] = UCIOption(4, 4, 7);
< 	o["Maximum Number of Threads per Split Point"] = UCIOption(5, 4, 8);
< 	o["Use Sleeping Threads"] = UCIOption(false);
< 	o["Clear Hash"] = UCIOption(false, "button");
< 	o["MultiPV"] = UCIOption(1, 1, 500);
< 	o["Skill Level"] = UCIOption(20, 0, 20);
< #if defined(NANOHA)
< 	// TODO: 要調整；時間制御のパラメータ
< 	o["Emergency Move Horizon"] = UCIOption(50, 0, 60);
< 	o["Emergency Base Time"] = UCIOption(20000, 0, 30000);
< 	o["Emergency Move Time"] = UCIOption(1000, 0, 5000);
< #else
< 	o["Emergency Move Horizon"] = UCIOption(40, 0, 50);
< 	o["Emergency Base Time"] = UCIOption(200, 0, 30000);
< 	o["Emergency Move Time"] = UCIOption(70, 0, 5000);
< #endif
< 	o["Minimum Thinking Time"] = UCIOption(20, 0, 5000);
< #if defined(NANOHA)
< 	// 引き分け(千日手)の点数
< 	o["DrawValue"] = UCIOption(0, -30000, 30000);
< 	o["Output_AllDepth"] = UCIOption(false);
< 	o["ByoyomiMargin"] = UCIOption(100, 0, 3000);
< #endif
< 
< 	// Set some SMP parameters accordingly to the detected CPU count
< 	UCIOption& thr = o["Threads"];
< 	UCIOption& msd = o["Minimum Split Depth"];
< 
< 	// スレッド数
< 	int thr_num = Min(cpu_count(), MAX_THREADS);
< 	thr.defaultValue = thr.currentValue = stringify(thr_num);
---
>   thr.defaultValue = thr.currentValue = stringify(cpu_count());
121,122c105,106
< 	if (cpu_count() >= 8)
< 		msd.defaultValue = msd.currentValue = stringify(7);
---
>   if (cpu_count() >= 8)
>       msd.defaultValue = msd.currentValue = stringify(7);
131c115
< 	std::stringstream s;
---
>   std::stringstream s;
133,152c117,132
< 	for (size_t i = 0; i <= size(); i++)
< 		for (OptionsMap::const_iterator it = begin(); it != end(); ++it)
< 			if (it->second.idx == i && (it->first.find(" ") == string::npos))
< 			{
< #if defined(NANOHA)
< 				if (it->first == "MultiPV") continue;
< 				if (it->first == "DrawValue") continue;
< #endif
< 				const UCIOption& o = it->second;
< 				s << "\noption name " << it->first << " type " << o.type;
< 
< 				if (o.type != "button")
< 					s << " default " << o.defaultValue;
< 
< 				if (o.type == "spin")
< 					s << " min " << o.minValue << " max " << o.maxValue;
< 
< 				break;
< 			}
< 	return s.str();
---
>   for (size_t i = 0; i <= size(); i++)
>       for (OptionsMap::const_iterator it = begin(); it != end(); ++it)
>           if (it->second.idx == i)
>           {
>               const UCIOption& o = it->second;
>               s << "\noption name " << it->first << " type " << o.type;
> 
>               if (o.type != "button")
>                   s << " default " << o.defaultValue;
> 
>               if (o.type == "spin")
>                   s << " min " << o.minValue << " max " << o.maxValue;
> 
>               break;
>           }
>   return s.str();
174c154
< 	assert(!type.empty());
---
>   assert(!type.empty());
176,177c156,157
< 	if (v.empty())
< 		return;
---
>   if (v.empty())
>       return;
179,180c159,160
< 	if ((type == "check" || type == "button") != (v == "true" || v == "false"))
< 		return;
---
>   if ((type == "check" || type == "button") != (v == "true" || v == "false"))
>       return;
182,187c162,167
< 	if (type == "spin")
< 	{
< 		int val = atoi(v.c_str());
< 		if (val < minValue || val > maxValue)
< 			return;
< 	}
---
>   if (type == "spin")
>   {
>       int val = atoi(v.c_str());
>       if (val < minValue || val > maxValue)
>           return;
>   }
189c169
< 	currentValue = v;
---
>   currentValue = v;
